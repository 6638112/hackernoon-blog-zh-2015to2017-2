<html>
<head>
<title>Building a simple static page generator with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js构建一个简单的静态页面生成器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-simple-static-page-generator-with-node-js-4f58f680c47d?source=collection_archive---------2-----------------------#2017-11-29">https://medium.com/hackernoon/building-a-simple-static-page-generator-with-node-js-4f58f680c47d?source=collection_archive---------2-----------------------#2017-11-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2e8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开发相当简单的网站时，静态页面生成器非常棒，而且超级方便。我已经使用了大概两到三个看起来像是现在可用的100个中的<a class="ae jp" href="https://www.staticgen.com/" rel="noopener ugc nofollow" target="_blank">。但对我来说，使用一个工具是不够的，这是通常的情况，因为我真的喜欢构建自己的工具来了解幕后发生的事情。因此，今天我将与你分享我自己的方法，用Node.js创建一个简单的静态页面生成器。</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/e564521429fa528453475cb5e1c79fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSN1a2xVtV1exzcD8fpzhA.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Photo by <a class="ae jp" href="https://unsplash.com/photos/p-xSl33Wxyc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Farzad Nazifi</a> on <a class="ae jp" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="0111" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">步骤0:成分列表(也称为依赖性和须知)</h2><ul class=""><li id="bfd1" class="lb lc hu it b iu ld iy le jc lf jg lg jk lh jo li lj lk ll dt translated">我假设大多数人都熟悉创建一个包，所以我不打算在这里深入讨论。如果您需要一些指导，请看一下<a class="ae jp" href="https://docs.npmjs.com/cli/init" rel="noopener ugc nofollow" target="_blank">文档</a>。</li><li id="69e5" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><code class="eh lm ln lo lp b"><a class="ae jp" href="https://www.npmjs.com/package/live-server" rel="noopener ugc nofollow" target="_blank">npm i -s live-server</a></code> —生成网站的服务器，支持热重装。这个包可以替代任何其他热重装服务器包，但我非常喜欢它，因为它非常简单，可以完成工作。</li><li id="3f8a" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><code class="eh lm ln lo lp b"><a class="ae jp" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank">npm i -s nodemon </a></code> —监视文件并运行指定的任务。当文件改变时，我们将使用这个包自动重建我们的静态网站。</li><li id="4f32" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><code class="eh lm ln lo lp b"><a class="ae jp" href="https://www.npmjs.com/package/concurrently" rel="noopener ugc nofollow" target="_blank">npm i -s concurrently</a></code> —脚本/任务的并发执行是一切顺利运行所必需的。我很确定有很多很棒的包可以完成同样的事情，但是我对这个特别的包很熟悉，所以我会坚持使用它。</li><li id="ce47" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">节点的<a class="ae jp" href="https://nodejs.org/api/fs.html#fs_file_system" rel="noopener ugc nofollow" target="_blank">文件系统模块</a>和<code class="eh lm ln lo lp b"><a class="ae jp" href="https://www.npmjs.com/package/fs-extra" rel="noopener ugc nofollow" target="_blank">npm i -s fs-extra</a></code> —文件系统模块是读/写/删除文件所必需的，所以我们将使用它来实际生成静态网站。是在此基础上的一个很好的扩展，允许你执行更多的操作，比如删除整个文件夹而不管内容，这特别有用。</li><li id="a683" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">我们将在Markdown中编写页面内容，所以我们将使用这个包作为它们的解析器。非常简单，如果你需要的话，它有很多插件。</li><li id="67c1" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> Javascript模板文字</a> —如果你不熟悉模板文字，不要担心。对于本文的目的，您需要知道的是，您可以使用反斜杠(<code class="eh lm ln lo lp b">`</code>)来编写多行字符串，并且使用<code class="eh lm ln lo lp b">${expression}</code>将会用内部表达式的结果替换美元符号和花括号。</li></ul><div class="lv lw fm fo lx ly"><a href="https://dev.to/sarah_chima/an-introduction-to-es6-template-literals-94l" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab ej"><div class="ma ab mb cl cj mc"><h2 class="bd hv fv z el md eo ep me er et ht dt translated">ES6模板文字简介</h2><div class="mf l"><h3 class="bd b fv z el md eo ep me er et ek translated">还记得当您必须在一个字符串中插入几个变量时，JavaScript中的编码有多糟糕吗？哦，数不清的…</h3></div><div class="mg l"><p class="bd b gc z el md eo ep me er et ek translated">开发到</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ka ly"/></div></div></a></div><h2 id="c714" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">步骤1:创建必要的目录和文件</h2><p id="ec4c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">在我们进入代码之前，我们需要为整个项目定义一个结构。请记住，这是我对这个问题的<em class="mq">看法</em>，它绝不是唯一或最好的看法，所以请随意做任何你喜欢的调整:</p><ul class=""><li id="665c" class="lb lc hu it b iu iv iy iz jc mr jg ms jk mt jo li lj lk ll dt translated">目录:在这个目录中，我将添加我的页面，用Markdown编写。然后这些将被转换成HTML文件，使用适当的脚本。</li><li id="19d5" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><strong class="it hv"> pages_meta </strong>目录:我觉得通用元数据不是最好的主意，所以我将使用这个目录中的JSON文件来添加特定于每个页面的元数据。除了文件扩展名之外，每个JSON文件的名称必须与pages目录中的markdown文件的名称完全匹配(例如，<code class="eh lm ln lo lp b">index.json</code>是<code class="eh lm ln lo lp b">index.md</code>的元数据文件)。JSON文件的内容如下所示:</li></ul><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mu mv l"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">JSON file metadata structure</figcaption></figure><ul class=""><li id="9fd1" class="lb lc hu it b iu iv iy iz jc mr jg ms jk mt jo li lj lk ll dt translated"><strong class="it hv"> build_scripts </strong>目录:我将在这里添加脚本，将Markdown和JSON文件转换成HTML文档。我将使用两个文件，一个是<strong class="it hv"> builder.js </strong>脚本，它将是静态页面生成器的主要入口点，另一个是<strong class="it hv"> page_template.js </strong>，我将使用它作为呈现每个页面的模板。将代码分成两个文件可能是一个好主意，因为根据某些条件，您可能会扩展构建文件中的逻辑以使用不同的模板，因此这允许您独立于核心构建逻辑来处理页面呈现。</li><li id="42d5" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><strong class="it hv"> css </strong>、<strong class="it hv"> js </strong>和<strong class="it hv"> images </strong>目录:这些目录包含页面将依赖的css文件、它们可能使用的脚本和可能显示的图像。它们都将被复制到输出目录中。</li><li id="c22e" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated"><strong class="it hv">构建</strong>目录:这是静态页面生成器的输出目录。您生成的静态页面和所有需要复制的文件都将保存在这个文件夹中。您不应该手动更改这里的任何内容，因为构建脚本应该在输出每个新构建之前清理这个文件夹。</li></ul><h2 id="1465" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">步骤2:设置环境</h2><p id="0394" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">我们几乎准备好开始写一些代码，但是首先我们需要在我们的<code class="eh lm ln lo lp b">package.json</code>中定义脚本，这样我们就可以启动我们的静态页面生成器。我设置我的方式是这样的:</p><pre class="jr js jt ju fq mw lp mx my aw mz dt"><span id="eed8" class="kg kh hu lp b fv na nb l nc nd">"build-pages": "node ./build_scripts/builder.js",                           "start": "concurrently --kill-others \"nodemon -e js,json,css,md -i build -x \\\"npm run build-pages\\\"\" \"live-server ./build\""</span></pre><p id="778d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们需要<code class="eh lm ln lo lp b">build-pages</code>脚本来告诉Node.js运行我们的构建脚本。一旦我们编写了必要的代码，这将从我们的文件生成静态网站。</p><p id="4afa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个剧本，<code class="eh lm ln lo lp b">start</code>，稍微复杂一些。我们使用<code class="eh lm ln lo lp b">concurrently</code>同时运行两个进程。第一个是<code class="eh lm ln lo lp b">nodemon</code>，我们明确地让它监视扩展名为<code class="eh lm ln lo lp b">js, json, css, md</code>的文件中的变化，并忽略<code class="eh lm ln lo lp b">build</code>目录。一旦<code class="eh lm ln lo lp b">nodemon</code>看到变化，它就会执行<code class="eh lm ln lo lp b">build-pages</code>脚本，这样静态网站就会重建。第二个进程正在从<code class="eh lm ln lo lp b">build</code>文件夹中运行<code class="eh lm ln lo lp b">live-server</code>。这就是我们启动和运行静态页面生成器所需要的全部内容。现在我们只需要编写一些代码，将Markdown和JSON文件转换成HTML文档。</p><h2 id="4746" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">第2.5步:喝杯咖啡(可选，但强烈推荐)</h2><p id="49a0" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">如果你已经做到了这一步，你做得很好！在接下来的几个步骤中，您将编写决定最终结果的代码，所以您可能想在开始工作之前喝杯咖啡(或任何其他饮料)。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/b34d902040184af25d58ac327b79bde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*jySYBfnqVvet2mwiUilHtA.gif"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Coffee break</figcaption></figure><h2 id="5196" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">步骤3:为你的页面创建一个模板</h2><p id="3f19" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">请记住，我们使用<code class="eh lm ln lo lp b">markdown-it</code>将我们的Markdown文件呈现为HTML。然而，我们还需要输出一堆不是由<code class="eh lm ln lo lp b">markdown-it</code>创建的html文档的部分，比如元数据和HTML的包装标签、head和body。我们将使用我们的<strong class="it hv"> page_template.js </strong>文件来做到这一点，并通过在模板中创建一个默认的元数据对象来确保没有元数据丢失。</p><p id="d6af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会详细解释每一个小步骤，但在向您展示我的源代码之前，我想强调一件非常重要的事情:</p><pre class="jr js jt ju fq mw lp mx my aw mz dt"><span id="4e72" class="kg kh hu lp b fv na nb l nc nd">`${pageMeta.hasOwnProperty('stylesheets')                                  <br/>  ? pageMeta.stylesheets.length                                 <br/>    ? pageMeta.stylesheets.map(value =&gt; `&lt;link rel="stylesheet" href="${value}"&gt;`)                                 <br/>    : ''                               <br/>  : this.defaultMeta.stylesheets.map(value =&gt; `&lt;link rel="stylesheet" href="${value}"&gt;`)                           <br/>}`</span></pre><p id="2cc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的代码片段中，您可以看到如何利用表达式和嵌套模板文本在最终的HTML文档中创建多个元素。简而言之，它判断应该使用模板中定义的默认<code class="eh lm ln lo lp b">stylesheets</code>属性还是为特定页面定义的属性，然后继续生成链接到样式表列表中定义的每个CSS文件的适当标签。我相信这个例子展示了模板文字有多强大，以及使用它们可以完成多少工作。</p><p id="5898" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">话虽如此，我们正在创建的模板必须为每个页面处理一些事情:</p><ul class=""><li id="01fa" class="lb lc hu it b iu iv iy iz jc mr jg ms jk mt jo li lj lk ll dt translated">输出<code class="eh lm ln lo lp b">&lt;!DOCTYPE html&gt;</code>，文档开始和结束的适当的<code class="eh lm ln lo lp b">&lt;html&gt;</code>标签，以及<code class="eh lm ln lo lp b">&lt;head&gt;</code>和<code class="eh lm ln lo lp b">&lt;body&gt;</code>标签。</li><li id="1f9b" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">根据提供的元数据，输出一个合适的<code class="eh lm ln lo lp b">&lt;title&gt;</code>。</li><li id="ebec" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">从提供的元数据中输出所有适当的<code class="eh lm ln lo lp b">&lt;meta&gt;</code>标签。</li><li id="f367" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">根据需要，输出脚本和样式表的<code class="eh lm ln lo lp b">&lt;script&gt;</code>和<code class="eh lm ln lo lp b">&lt;link&gt;</code>标签列表。</li><li id="c057" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">最后，输出从<code class="eh lm ln lo lp b">&lt;body&gt;</code>中的Markdown文件生成的HTML。</li></ul><p id="431b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在实现了所有这些特性之后，你应该得到类似于<a class="ae jp" href="https://github.com/Chalarangelo/node-static-page-generator/blob/master/build_scripts/page_template.js" rel="noopener ugc nofollow" target="_blank">我的模板</a>的东西。</p><h2 id="acdd" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">步骤4:创建构建脚本</h2><p id="e904" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">你就快到了！现在我们只需要编写构建脚本，它将根据需要把所有的东西放在一起。请记住，有多种方法可以做到这一点，您肯定可以调整这个脚本来创建更复杂的网站和处理不同的情况，但现在我们将坚持一个非常基本的实现，它只会做我认为构建静态网站所必需的事情:</p><ol class=""><li id="7362" class="lb lc hu it b iu iv iy iz jc mr jg ms jk mt jo nf lj lk ll dt translated">加载<code class="eh lm ln lo lp b">fs-extra</code>、<code class="eh lm ln lo lp b">path</code>和你的<code class="eh lm ln lo lp b">./page_template</code>。</li><li id="1e4b" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo nf lj lk ll dt translated">声明您的<strong class="it hv"> pages </strong>、<strong class="it hv"> pages_meta </strong>、<strong class="it hv"> css </strong>、<strong class="it hv"> js </strong>、<strong class="it hv"> images </strong>和<strong class="it hv"> build </strong>目录相对于您的<code class="eh lm ln lo lp b">package.json</code>文件的路径。我们将在后面的代码中使用这些来减少混乱。</li><li id="411f" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo nf lj lk ll dt translated">使用同步方法，比如对所有事情都使用<code class="eh lm ln lo lp b"><a class="ae jp" href="https://nodejs.org/api/fs.html#fs_fs_readdirsync_path_options" rel="noopener ugc nofollow" target="_blank">readdirSync</a></code>。这将确保我们的代码从上到下运行。如果你对自己的异步编程技能有信心，那么就继续下去，异步实现所有的东西，不管怎样，这可能更有效率。</li><li id="aa6e" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo nf lj lk ll dt translated">清理<strong class="it hv">建立</strong>目录。</li><li id="bd14" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo nf lj lk ll dt translated">循环遍历<strong class="it hv"> pages </strong>目录中的所有页面，并将它们存储在一个列表中。对<strong class="it hv"> pages_meta </strong>目录中的元数据文件执行相同的操作。</li><li id="d9e7" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo nf lj lk ll dt translated">使用Markdown和JSON文件作为模板文件的<code class="eh lm ln lo lp b">generatePage()</code>函数的参数来生成每个页面。</li><li id="5682" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo nf lj lk ll dt translated">将<strong class="it hv"> css </strong>、<strong class="it hv"> js </strong>和<strong class="it hv"> images </strong>目录原样复制到<strong class="it hv"> build </strong>目录中。</li></ol><p id="b404" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是让构建过程正常工作所需要做的全部工作。如果你做的一切都正确，你应该会得到一个类似于<a class="ae jp" href="https://github.com/Chalarangelo/node-static-page-generator/blob/master/build_scripts/builder.js" rel="noopener ugc nofollow" target="_blank">这个</a>的构建脚本。</p><h2 id="7197" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">第五步:发挥创意，建立你一直想要的网站</h2><p id="5935" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">如果您一直坚持下去，现在应该已经有了一个静态页面生成器。现在有趣的部分开始了！你可以随心所欲地定制它，创建你想要的内容，并添加你需要的所有功能，但在其他地方找不到。没有什么是你做不到的！</p><p id="99e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对改进和试验它的建议:</p><ul class=""><li id="9b5d" class="lb lc hu it b iu iv iy iz jc mr jg ms jk mt jo li lj lk ll dt translated">添加将在特定条件下应用的第二个模板。</li><li id="b1ee" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">向模板文件添加导航栏、页眉或页脚，为静态网站创建应用程序外壳。</li><li id="94a8" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">调整<code class="eh lm ln lo lp b">markdown-it</code>的<a class="ae jp" href="https://markdown-it.github.io/markdown-it/#MarkdownIt.configure" rel="noopener ugc nofollow" target="_blank">配置</a>或者增加几个<a class="ae jp" href="https://www.npmjs.com/browse/keyword/markdown-it-plugin" rel="noopener ugc nofollow" target="_blank">插件</a>。</li><li id="369f" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">将构建脚本转换为异步脚本。</li><li id="a1f4" class="lb lc hu it b iu lq iy lr jc ls jg lt jk lu jo li lj lk ll dt translated">支持不同格式的页面和文件。</li></ul></div><div class="ab cl ng nh hc ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hn ho hp hq hr"><p id="5036" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mq">本文的完整源代码可以在</em><a class="ae jp" href="https://github.com/Chalarangelo/node-static-page-generator" rel="noopener ugc nofollow" target="_blank"><em class="mq">Github</em></a><em class="mq">上找到。记住启动存储库，这样您可以在以后找到返回的方法！</em></p></div></div>    
</body>
</html>