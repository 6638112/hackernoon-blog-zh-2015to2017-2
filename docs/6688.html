<html>
<head>
<title>Python duck typing (or automatic interfaces)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python鸭类型(或自动接口)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/python-duck-typing-or-automatic-interfaces-73988ec9037f?source=collection_archive---------1-----------------------#2017-09-30">https://medium.com/hackernoon/python-duck-typing-or-automatic-interfaces-73988ec9037f?source=collection_archive---------1-----------------------#2017-09-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c5acdb83b1d7e7141341feecc6a181dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPeGjUlwLBKovESpYTioHA.jpeg"/></div></div></figure><p id="3def" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我全职使用python，更多的时候，我对它的做事方式有了一些见解(或者对一些人来说是python的T2禅)。在我的日常生活中，有一件事让我印象深刻，那就是鸭子打字。老实说，这不是python独有的特性，因为几乎每种动态语言都有这种行为。不过说好听点，我喜欢Python。</p><p id="7331" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果有些读者不知道它是什么，鸭子类型是类型系统的一个特性，其中类的语义是由它对一些消息(方法或属性)的响应能力决定的。典型的例子(以及名字背后的原因)是<a class="ae ka" href="https://en.wikipedia.org/wiki/Duck_test" rel="noopener ugc nofollow" target="_blank">鸭子测试</a> : <em class="kb">如果它看起来像鸭子，游泳像鸭子，嘎嘎叫也像鸭子，那么它很可能就是一只鸭子。</em></p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="81fb" class="kl km hu kh b fv kn ko l kp kq">class Duck:<br/>   def quack():<br/>      print('Quack!')</span><span id="624e" class="kl km hu kh b fv kr ko l kp kq">class Goose:<br/>   def quack():<br/>      print('Quack')</span><span id="760a" class="kl km hu kh b fv kr ko l kp kq">Goose().quack()<br/>&gt;&gt; Quack!</span><span id="f54b" class="kl km hu kh b fv kr ko l kp kq">Duck().quack()<br/>&gt;&gt; Quack!</span></pre><p id="11d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，但是有什么问题呢？这里没有什么新东西。是的，没什么新的。我想展示的是这种行为在系统架构中的含义。我主张这是一个好的暗示。让我解释一下。</p><p id="3ba8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一个名为<em class="kb"> Car </em>的类:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="be19" class="kl km hu kh b fv kn ko l kp kq">class Car:<br/>   def __init__(self, engine):<br/>      self.engine = engine</span><span id="2bb3" class="kl km hu kh b fv kr ko l kp kq">   def run():<br/>       self.engine.turn_on()</span></pre><p id="ac23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是依赖注入的一个经典例子。我的类<em class="kb"> Car </em>接收一个引擎实例，并在run方法中使用它，在那里它调用<em class="kb"> turn_on </em>方法。注意，我的<em class="kb">汽车</em>不依赖于引擎的任何具体实现。而且我没有导入任何其他类型！仅仅使用依赖注入的实例来响应<em class="kb"> turn_on </em>消息。我可以说我的类<em class="kb"> Car </em>依赖于一个接口。但是我不需要申报。是自动界面！</p><p id="921c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在没有duck typing的语言中，我可能必须声明一个显式接口，例如命名为<em class="kb"> IEngine </em>，拥有实现(例如<em class="kb"> EngineV1 </em>)并显式定义我的<em class="kb"> Car </em>参数为<em class="kb"> IEngine </em>的实现。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="8cfb" class="kl km hu kh b fv kn ko l kp kq">interface IEngine {<br/>    void turnOn();<br/>}</span><span id="179a" class="kl km hu kh b fv kr ko l kp kq">public class EngineV1 implements IEngine {<br/>    public void turnOn() {<br/>        // do something here<br/>    }<br/>}</span><span id="b59d" class="kl km hu kh b fv kr ko l kp kq">public class Car {<br/>    public Car(IEngine engine) {<br/>       this.engine = engine;<br/>    }</span><span id="7a73" class="kl km hu kh b fv kr ko l kp kq">    public void run() {<br/>        this.engine.turnOn();<br/>    }</span><span id="de5f" class="kl km hu kh b fv kr ko l kp kq">}</span></pre><p id="5b9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">啊！多少代码。</p><p id="1482" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，你可以看到效果是一样的。我的类<em class="kb"> Car </em>在这两种情况下都依赖于一个接口。但是在第一种情况下，代码更少，我不需要显式实现接口。如果我定义了方法<em class="kb"> turn_on </em>，它就已经实现了。</p><h2 id="cdc9" class="kl km hu bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">弱点</h2><p id="e521" class="pw-post-body-paragraph jc jd hu je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">这里我可以看到两个问题。</p><ol class=""><li id="355c" class="lq lr hu je b jf jg jj jk jn ls jr lt jv lu jz lv lw lx ly dt translated">脂肪界面</li></ol><p id="08d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先是对<a class="ae ka" href="https://en.m.wikipedia.org/wiki/Interface_bloat" rel="noopener ugc nofollow" target="_blank">接口膨胀</a>的刺激。由于我们没有明确定义API，这可能导致接口中有太多的粒度方法。</p><p id="f031" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.未命名的依赖项</p><p id="0189" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们不知道一个类所依赖的接口的名字，所以我们没有自动的依赖树。因此，所有依赖注入框架都必须以某种方式解决依赖解析。</p><p id="990d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，<a class="ae ka" href="http://injector.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">注入器库</a>必须实现<a class="ae ka" href="http://injector.readthedocs.io/en/latest/terminology.html#keys" rel="noopener ugc nofollow" target="_blank">键</a>的概念，以允许自动解析依赖树。在injector术语中，键只不过是命名/标识类实现的接口的一种方式。</p><h2 id="ba10" class="kl km hu bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">结论</h2><p id="53cb" class="pw-post-body-paragraph jc jd hu je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">我不认为鸭子打字是故意设计成有这种行为的。我甚至不认为duck typing是在一种语言中有意设计的，而是这些类型系统的动态性质的副作用。但是有趣的是它能给系统<a class="ae ka" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>和架构带来简洁和低耦合。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>