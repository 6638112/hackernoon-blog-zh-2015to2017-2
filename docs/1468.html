<html>
<head>
<title>Getting to Grips with ES6: Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握ES6:箭头功能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-to-grips-with-es6-arrow-functions-ebfa62c5c5d6?source=collection_archive---------1-----------------------#2016-11-03">https://medium.com/hackernoon/getting-to-grips-with-es6-arrow-functions-ebfa62c5c5d6?source=collection_archive---------1-----------------------#2016-11-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/63de466da92fbf101000db58b95892bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIP_jAQMs432seqknYrTZg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="f689" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">第二部分:理解箭头函数</h2></div><p id="8b67" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><a class="ae kq" rel="noopener" href="/@andrewjrhill/getting-to-grips-with-es6-template-literals-9a42e4389e1e#.5opel5frn"> <em class="kr">点击这里查看第三部分:理解标准的、嵌入式的、多行的和带标签的模板文字。</em> </a></p><h2 id="d2b8" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">前言</strong></h2><p id="74ad" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">这篇文章是为希望更好地理解ES6 arrow函数的初级到中级开发人员设计的入门读物。</p><p id="9483" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">作为我的“掌握ES6”系列的一部分，我的目标是创建一个参考，其中包含简单明了的解释，以帮助我们理解这些概念，并将它们直接应用到我们当前的开发过程中。</p><p id="8958" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">由安德鲁·希尔撰写。<br/>你可以在<a class="ae kq" href="http://www.linkedin.com/in/andrewjrhill" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kq" href="https://twitter.com/andrewjrhill" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kq" href="https://www.instagram.com/andrewshills/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae kq" href="https://github.com/Sntax/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="4ebc" class="lz kt if bd ku ma mb mc ky md me mf lc jl mg jm lf jo mh jp li jr mi js ll mj dt translated">箭头功能</h1><p id="4f26" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">箭头函数(通常称为胖箭头函数或lambda函数)是一种简洁的函数编写方式，它不会在其他函数中重新绑定上下文(<code class="eh mk ml mm mn b">this</code>)。它们的简短语法由于能够在一行单一返回函数中隐式返回值而得到进一步增强。</p><p id="2d2b" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">箭头函数不能被命名，因此总是被认为是匿名函数。</p><h2 id="ecba" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">传统功能定义</strong></h2><p id="6ac1" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">到目前为止，JavaScript已经对匿名函数使用了以下语法:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="6c55" class="ks kt if mn b fv mw mx l my mz">var double = function(a) {<br/>  return a * 2;<br/>}</span><span id="605c" class="ks kt if mn b fv na mx l my mz">double(100);</span><span id="ecdc" class="ks kt if mn b fv na mx l my mz">// Output: 200</span></pre><p id="fd9e" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">有各种各样的语法可用于箭头函数；完整的名单可以在EcmaScript.org找到。为了简洁起见，本文中的例子将使用最常见的例子。</p><h2 id="2eb8" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">箭头功能定义</strong></h2><p id="6c40" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">通过引入箭头函数，我们可以将给出的示例重写如下:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="a2a1" class="ks kt if mn b fv mw mx l my mz">const double = (a) =&gt; {<br/>  return a * 2;<br/>}</span><span id="2baf" class="ks kt if mn b fv na mx l my mz">double(100);</span><span id="1d21" class="ks kt if mn b fv na mx l my mz">// Output: 200</span></pre><h2 id="712e" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">参数和括号</strong></h2><p id="6ea7" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">带多个参数的箭头函数需要括号:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="6dcf" class="ks kt if mn b fv mw mx l my mz">const add = (a, b) =&gt; {<br/>  return a + b;<br/>}</span><span id="b0aa" class="ks kt if mn b fv na mx l my mz">add(100, 200);</span><span id="e614" class="ks kt if mn b fv na mx l my mz">// Output: 300</span></pre><p id="aa10" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在完全不包含任何参数的箭头函数中也需要括号:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="25f3" class="ks kt if mn b fv mw mx l my mz">const fullName = () =&gt; {<br/>  return 'Andrew Hill';<br/>}</span><span id="60c6" class="ks kt if mn b fv na mx l my mz">name();</span><span id="3ad1" class="ks kt if mn b fv na mx l my mz">// Output: Andrew Hill</span></pre><p id="ee38" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">包含单个<a class="ae kq" href="https://hackernoon.com/tagged/parameter" rel="noopener ugc nofollow" target="_blank">参数</a>的函数允许我们一起省略<a class="ae kq" href="https://hackernoon.com/tagged/function" rel="noopener ugc nofollow" target="_blank">函数</a>定义中的括号:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="339a" class="ks kt if mn b fv mw mx l my mz">const double = a =&gt; {<br/>  return a * 2;<br/>}</span><span id="73ee" class="ks kt if mn b fv na mx l my mz">double(100);</span><span id="9d65" class="ks kt if mn b fv na mx l my mz">// Output: 200</span></pre><h2 id="3955" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated"><strong class="ak">隐式返回</strong></h2><p id="15ca" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">我们的例子是一个简单的单行函数，它立即返回一个值。在这样的用例中，我们被允许省略函数花括号，以便<em class="kr">隐式返回</em>它的结果:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="2db7" class="ks kt if mn b fv mw mx l my mz">const double5 = a =&gt; a * 2;</span><span id="bdcc" class="ks kt if mn b fv na mx l my mz">double5(100);</span><span id="1951" class="ks kt if mn b fv na mx l my mz">// Output: 200</span></pre><h2 id="e22b" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">隐式返回对象文本</h2><p id="a7b9" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">传统上，如果我们想返回一个对象文字，我们应该这样写我们的函数:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="9afc" class="ks kt if mn b fv mw mx l my mz">var animal = function(type, name) {<br/>  return {<br/>    type: type,<br/>    name: name,<br/>  }<br/>}</span><span id="d4a7" class="ks kt if mn b fv na mx l my mz">animal('dog', 'Damon');</span><span id="9908" class="ks kt if mn b fv na mx l my mz">// Output: Object {type: "dog", name: "Damon"}</span></pre><p id="488b" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">切换到箭头函数并试图隐式返回对象将导致错误，因为引擎无法判断花括号是属于对象还是功能块:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="a9eb" class="ks kt if mn b fv mw mx l my mz">const animal = (type, name) =&gt; { type: type, name: name };</span><span id="2d77" class="ks kt if mn b fv na mx l my mz">animal('dog', 'Damon');</span><span id="612c" class="ks kt if mn b fv na mx l my mz">// Output: [SyntaxError] Unexpected token :</span></pre><p id="630b" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">为了解决这个问题，我们可以告诉arrow函数，我们通过将对象放在一组附加的括号中来隐式返回对象:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="e186" class="ks kt if mn b fv mw mx l my mz">const animal = (type, name) =&gt; ({ type: type, name: name });</span><span id="903a" class="ks kt if mn b fv na mx l my mz">animal('dog', 'Damon');</span><span id="ff88" class="ks kt if mn b fv na mx l my mz">// Output: Object {type: "dog", name: "Damon"}</span></pre><p id="b9f1" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">顺便提一下，在ES6中共享一个名称的键和值可以用如下简写:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="7746" class="ks kt if mn b fv mw mx l my mz">const animal2 = (type, name) =&gt; ({ type, name });</span><span id="0978" class="ks kt if mn b fv na mx l my mz">animal2('dog', 'Damon');</span><span id="f71c" class="ks kt if mn b fv na mx l my mz">// Output: Object {type: "dog", name: "Damon"}</span></pre><p id="3010" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><em class="kr">好美！</em></p><h2 id="87ab" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">语境</h2><p id="8eee" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">让我们来看看传统函数处理上下文的方式，将事件监听器绑定到按钮，并在单击时记录<code class="eh mk ml mm mn b">this</code>:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="217f" class="ks kt if mn b fv mw mx l my mz">var button = document.getElementById('contextButton');</span><span id="0f05" class="ks kt if mn b fv na mx l my mz">button.addEventListener('click', function(){<br/>  console.log(this);<br/>});</span><span id="2f4c" class="ks kt if mn b fv na mx l my mz">// Output on click: &lt;button id="contextButton"&gt;...&lt;/button&gt; </span></pre><p id="66f3" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在这个例子中，传统函数将<code class="eh mk ml mm mn b">this</code>的值绑定到事件监听器被分配到的元素。</p><p id="153c" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">请考虑以下使用箭头函数的示例:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="53bd" class="ks kt if mn b fv mw mx l my mz">const button = document.getElementById('contextButton');</span><span id="b1c6" class="ks kt if mn b fv na mx l my mz">button.addEventListener('click', () =&gt; {<br/>  console.log(this);<br/>});</span><span id="7808" class="ks kt if mn b fv na mx l my mz">// Output on click: Window { ... }</span></pre><p id="ae75" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这里我们说明了arrow函数如何利用词法绑定从父上下文中继承<code class="eh mk ml mm mn b">this</code>的值。由于这段代码存在于全局范围内，它的父对象(以及<code class="eh mk ml mm mn b">this</code>的结果)是<code class="eh mk ml mm mn b">Window {}</code>对象。</p><h2 id="b6fb" class="ks kt if bd ku kv kw kx ky kz la lb lc kd ld le lf kh lg lh li kl lj lk ll lm dt translated">细微差别和最终想法</h2><p id="e389" class="pw-post-body-paragraph ju jv if jw b jx ln jg jz ka lo jj kc kd lp kf kg kh lq kj kk kl lr kn ko kp hn dt translated">要考虑的最后一个细微差别是<code class="eh mk ml mm mn b">arguments</code>对象对箭头函数不可用。</p><p id="60ee" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">在下面的例子中，我们利用一个传统的函数，使用<code class="eh mk ml mm mn b">arguments</code>对象返回一个“参数值”数组:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="f8ba" class="ks kt if mn b fv mw mx l my mz">var test = function(a, b) {<br/>  return arguments;<br/>}</span><span id="4ca4" class="ks kt if mn b fv na mx l my mz">test(100, 200);</span><span id="57c1" class="ks kt if mn b fv na mx l my mz">// Output: [100, 200]</span></pre><p id="9f4b" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">使用arrow函数尝试同样的事情会导致错误:</p><pre class="mo mp mq mr fq ms mn mt mu aw mv dt"><span id="2e1d" class="ks kt if mn b fv mw mx l my mz">const test = (a, b) =&gt; arguments;</span><span id="9a2a" class="ks kt if mn b fv na mx l my mz">test(100, 200);</span><span id="5edb" class="ks kt if mn b fv na mx l my mz">// Output: [Uncaught ReferenceError] arguments is not defined</span></pre><p id="8734" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">最后，重要的是要认识到，即使箭头函数是美丽的、简短的和简洁的，它们也不能代替传统的函数。他们对词法绑定的使用意味着有明确的用例，我们应该和不应该使用箭头函数。</p><p id="03c4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">感谢阅读。如果您喜欢这篇文章，请考虑推荐它来支持本系列的未来安装。👏</p><p id="48dc" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><a class="ae kq" rel="noopener" href="/@andrewjrhill/getting-to-grips-with-es6-template-literals-9a42e4389e1e#.5opel5frn"> <em class="kr">点击这里查看第三部分:理解标准的、嵌入式的、多行的和带标签的模板文字。</em> </a></p><figure class="mo mp mq mr fq hw"><div class="bz el l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>