<html>
<head>
<title>Async testing Koa with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest异步测试Koa</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/async-testing-koa-with-jest-1b6e84521b71?source=collection_archive---------3-----------------------#2017-10-18">https://medium.com/hackernoon/async-testing-koa-with-jest-1b6e84521b71?source=collection_archive---------3-----------------------#2017-10-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/7b9e102496b1fa9872f0c7a02cbffdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqHRzO0eQZOmZgK1aex6Ew.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><em class="ih">Koa</em> is a species of tree on Hawaii (not pictured). Photo by <a class="ae ii" href="https://unsplash.com/photos/wdo4V0sBoZE" rel="noopener ugc nofollow" target="_blank">Ozark Drones</a>.</figcaption></figure><div class=""/><div class=""><h2 id="606a" class="pw-subtitle-paragraph ji ik il bd b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ek translated">利用鲜为人知的特性简化API和中间件测试</h2></div><blockquote class="ka kb kc"><p id="a4fd" class="kd ke kf kg b kh ki jm kj kk kl jp km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">这是一份在柏林会议上所做报告的文字记录。</p></blockquote></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h1 id="1aa0" class="lh li il bd lj lk ll lm ln lo lp lq lr jr ls js lt ju lu jv lv jx lw jy lx ly dt translated">什么是Koa，什么是Jest</h1><p id="257a" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">让我们简单描述一下我们将要使用的库。</p><p id="58ba" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated"><strong class="kg im">Koa</strong>(<a class="ae ii" href="http://koajs.com/" rel="noopener ugc nofollow" target="_blank">koajs.com</a>)是一个JavaScript web服务器框架。它是由一个更著名的Express背后的人开发的，作为一个轻量级和富有表现力的“精神继承者”。</p><p id="fbda" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">它也是基于中间件的。但是，它没有附带任何功能。是的，没有路由器，没有主体解析器，也没有代理。利用ES2017 <em class="kf">异步/等待</em>功能带来用户友好的功能和端到端流量控制。(你不熟悉<em class="kf"> async/await </em>？阅读<a class="ae ii" href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" rel="noopener ugc nofollow" target="_blank">穆斯塔法·加法尔</a>的这篇有用的介绍。我们会经常使用它们。)这意味着我们可以对回调地狱说‘拜拜’了，我们从Express了解到。我们将使用第二个版本；在Koa v1发电机提供了流量控制。</p><p id="180e" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">Jest是一个来自脸书的现代单元测试框架。它给主流JavaScript测试带来了几个概念:零配置、一流的模仿和快照。</p><p id="a7cd" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">如果说Koa是Express的(精神)继承者，Jest可谓是Jasmine和Expect(后来<a class="ae ii" href="https://github.com/facebook/jest/issues/1679" rel="noopener ugc nofollow" target="_blank">捐赠给Jest </a>)的(精神)继承者。</p><p id="673b" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">五月发布的包含了一个更好的异步/承诺支持，我认为它还没有得到应有的关注。我希望它是清楚的，那是我们以后将使用的。</p><p id="a097" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">就个人而言，我对Jest更有经验，我每天都用它来测试基于React的应用。另一方面，Koa是我的爱好，我只把它用在私人项目上。</p><h1 id="17d1" class="lh li il bd lj lk mj lm ln lo mk lq lr jr ml js lt ju mm jv lv jx mn jy lx ly dt translated">测试中间件</h1><p id="2f32" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">Koa中间件通常具有以下形式:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="4766" class="mx li il mt b fv my mz l na nb">const greetings = async (ctx, next) =&gt; {<br/>  ctx.body = 'Hello.'</span><span id="d6ef" class="mx li il mt b fv nc mz l na nb">  await next()</span><span id="40da" class="mx li il mt b fv nc mz l na nb">  ctx.body += ' Remember to subscribe.'<br/>}</span><span id="c9bd" class="mx li il mt b fv nc mz l na nb">const app = new Koa()<br/>app.use(greetings)<br/>app.listen(3000)</span></pre><p id="66c6" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">它接收包含请求和响应信息的上下文<code class="eh nd ne nf mt b">ctx</code>。改变这个对象是中间件通信的唯一方式。没有返回值；如果有，它将被忽略。因此，测试中间件意味着观察上下文的变化。</p><p id="e9a5" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">第二个参数是回调，它挂起当前的中间件，并将控制权传递给下一个中间件。这个回调要么被等待，要么根本不被调用——启动中间件订单执行。当然，可能不会调用多次。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ng"><img src="../Images/c851dfa4cf0fa7bf03c0d25445a79c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s1Pn5FjXVCs2bBE5sBsaBw.gif"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Read more details in the well-written <a class="ae ii" href="https://github.com/koajs/koa/blob/master/docs/guide.md" rel="noopener ugc nofollow" target="_blank">guide</a>, from where I borrowed this animation</figcaption></figure><h2 id="2008" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">简单测试</h2><p id="2aa4" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">上面的<code class="eh nd ne nf mt b">greeting</code>中间件的一个简单测试如下所示:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="dcc3" class="mx li il mt b fv my mz l na nb">test('greetings works', async () =&gt; {<br/>  const ctx = {}</span><span id="e1b0" class="mx li il mt b fv nc mz l na nb">  await greetings(ctx, () =&gt; {})</span><span id="c9eb" class="mx li il mt b fv nc mz l na nb">  expect(ctx.body).toBe(<br/>    'Hello. Remember to subscribe.'<br/>  )<br/>})</span></pre><p id="6adc" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">首先，是的，你可以开玩笑地使用<em class="kf"> async </em>。框架将等待所有异步操作完成。</p><p id="a574" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated"><code class="eh nd ne nf mt b">next</code>回调是一个空函数——这是最低要求。它只是将流立即返回给我们的函数。</p><p id="73dd" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">上下文对象是一个模拟对象。我们可以提供其他数据，如请求的网址或标题。</p><p id="7856" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">当整个中间件完成时，我们在上下文对象上运行断言。</p><p id="9098" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">如您所见，我们无法区分变化是何时发生的——“之前”还是“之后”<code class="eh nd ne nf mt b">await next()</code>，我们只知道结果。然而，对于许多中间件来说，这已经足够了。尤其是那些只在下一个中间件之前或之后运行小程序的应用程序。</p><p id="f77d" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">如果我们需要更多呢？</p><h2 id="17ec" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">前后测试</h2><p id="977e" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">如果在传递到下一个中间件之前或之后运行，读取文件、记录时间和生成ETag是必要的。</p><p id="4d7d" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">此类测试可能如下所示:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="cd62" class="mx li il mt b fv my mz l na nb">test('greetings works before-and-after', async () =&gt; {<br/>  const ctx = {}</span><span id="cf22" class="mx li il mt b fv nc mz l na nb">  const next = jest.fn(() =&gt; {<br/>    expect(ctx.body).toBe('Hello.')  // (1)<br/>    ctx.body += ' I am content.'<br/>  })</span><span id="73b0" class="mx li il mt b fv nc mz l na nb">  await greetings(ctx, next)</span><span id="2588" class="mx li il mt b fv nc mz l na nb">  expect(next).toHaveBeenCalledTimes(1)</span><span id="e033" class="mx li il mt b fv nc mz l na nb">  expect(ctx.body).toBe(             // (2)<br/>    'Hello. I am content. Remember to subscribe.'<br/>  )<br/>})</span></pre><p id="3dc6" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">哇，长高了一点。但是不要害怕，这很容易。</p><p id="ab56" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">最重要的变化是<code class="eh nd ne nf mt b">next</code>内部的回调。它不再是noop了。这是用(1)标记的地方，我们在这里测试<code class="eh nd ne nf mt b">ctx</code>如何“以前”改变。在这里，我们也可以为在(2)断言的“之后”部分做准备。</p><p id="25b0" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">请注意，我们将<code class="eh nd ne nf mt b">next</code>包装在<code class="eh nd ne nf mt b">jest.fn</code>中，这样我们可以检查它的运行以及其中的断言是否通过。否则，可以通过不调用<code class="eh nd ne nf mt b">await next()</code>来跳过它们。如果您在单独的测试中测试它，则可以移除它。或者，我们可以在顶部添加<code class="eh nd ne nf mt b">expect.assertions(2)</code>——并保持更新。</p><p id="82eb" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">一个小小的警告:我见过有人试图通过调用中间件而不等待<em class="kf">来将测试分成两部分。这是错误和危险的，因为“之后”部分也可能被调用。此外，如果在“以前”中有异步操作，它将不起作用</em></p><h2 id="709e" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">完整的中间件测试</h2><p id="bde8" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">下面是一个使用快照测试的更新示例。额外的好处是，它将捕捉额外的变化，否则你可能会错过。</p><p id="c4f7" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">它还展示了如何在Koa提供的工具上测试函数调用，在我们的例子中是<code class="eh nd ne nf mt b">response.set</code>。它使用了一个简短的版本来测试调用次数和每个调用中的参数，顺序敏感。</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="a44d" class="mx li il mt b fv my mz l na nb">test('greetings works complete', async () =&gt; {<br/>  const ctx = {<br/>    response: { set: jest.fn() }<br/>    /* ADD OTHER MOCKS */<br/>  }</span><span id="23dd" class="mx li il mt b fv nc mz l na nb">  const next = jest.fn(() =&gt; {<br/>    expect(ctx).toMatchSnapshot()<br/>  })</span><span id="1a57" class="mx li il mt b fv nc mz l na nb">  await expect(greetings(ctx, next))<br/>    .resolves.toBeUndefined()</span><span id="0be2" class="mx li il mt b fv nc mz l na nb">  expect(next).toHaveBeenCalledTimes(1)</span><span id="aa81" class="mx li il mt b fv nc mz l na nb">  expect(ctx).toMatchSnapshot()<br/>  expect(ctx.response.set.mock.calls).toMatchSnapshot()<br/>})</span></pre><p id="357b" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">你可以看到，最后一个增强是在Jest 20中添加的<code class="eh nd ne nf mt b">.resolves</code> matcher。它做两件事:检查中间件不返回任何东西，并在出现问题时提供更好的消息。比较:</p><p id="4e49" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">之前:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="3e91" class="mx li il mt b fv my mz l na nb">Read error</span></pre><p id="894e" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">之后:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="58cd" class="mx li il mt b fv my mz l na nb">Expected received Promise to resolve, instead it rejected to value<br/> [Error: Read error]</span></pre><p id="f7b8" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">当我们预计会出现错误时，这种差异会更加明显。更多内容，请看我的演示示例:<a class="ae ii" href="https://www.youtube.com/watch?v=bw10S2BK-5w" rel="noopener ugc nofollow" target="_blank">玩笑式异步测试</a>。</p><h2 id="bc69" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">接下来呢？</h2><p id="5b90" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">测试小单元。这是不是意味着我们结束了？不。我喜欢这个GIF:</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/8b551cd8be6bdb227ac7daddb8c37699.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Aj4uKEWlXBkXhJxxx-XIGA.gif"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Still love this one. Unit testers be like: “Looks like it’s working” — <a class="mh mi gr" href="https://medium.com/u/db72389e89d8?source=post_page-----1b6e84521b71--------------------------------" rel="noopener" target="_blank">Kent C. Dodds</a></figcaption></figure><p id="39f9" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">我们需要自信。我们的应用程序对最终用户很有信心。当我们假装使用应用程序时，我们会建立它。</p><h1 id="e22c" class="lh li il bd lj lk mj lm ln lo mk lq lr jr ml js lt ju mm jv lv jx mn jy lx ly dt translated">测试完整的API</h1><p id="4c5d" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">从技术上讲，整个应用程序是一个中间件，是所有应用中间件的<a class="ae ii" href="https://github.com/koajs/compose" rel="noopener ugc nofollow" target="_blank">组合</a>，由我们编写或从库中获取。用<code class="eh nd ne nf mt b">app.middleware</code>获取列表并以如上所述的相同方式进行测试可能很有诱惑力。那将是错误的。</p><p id="366a" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">在构建中间件的基础上，Koa包装了本地响应和请求对象，并做了一些其他事情。我们想测试整个应用程序。不是单元测试，姑且称之为API测试吧。</p><p id="8aa2" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">Jest本身无法做到这一点，对于HTTP断言，我们将使用<a class="ae ii" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> supertest </a>。Supertest是<a class="ae ii" href="http://visionmedia.github.io/superagent/" rel="noopener ugc nofollow" target="_blank"> SuperAgent </a>的一个小包装器。最大的好处是它支持开箱即用的承诺。</p><h2 id="201d" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">示例应用程序和测试样板</h2><p id="3712" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">示例应用程序摘自<a class="mh mi gr" href="https://medium.com/u/18e37911137f?source=post_page-----1b6e84521b71--------------------------------" rel="noopener" target="_blank"> Valentino Gagliardi </a>的文章<a class="ae ii" href="https://www.valentinog.com/blog/testing-api-koa-jest/" rel="noopener ugc nofollow" target="_blank">一篇用Jest和Supertest测试Koa的简明介绍</a>。读吧！它运行起来有点慢，并且包含一个逐步的指南来让它运行起来。</p><p id="664a" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">在这里，我将展示一些其他方法来测试应用程序。</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="29ef" class="mx li il mt b fv my mz l na nb">// server/index.js<br/>const Koa = require('koa')<br/>const Router = require('koa-router')<br/>const router = new Router()</span><span id="c002" class="mx li il mt b fv nc mz l na nb">const app = new Koa()</span><span id="bf9c" class="mx li il mt b fv nc mz l na nb">router.get('/', async ctx =&gt; {<br/>  ctx.body = {<br/>    data: 'Sending some JSON',<br/>    person: {<br/>      name: 'Ferdinand',<br/>      lastname: 'Vaněk',<br/>      role: 'Brewery worker',<br/>      age: 42<br/>    }<br/>  }<br/>})</span><span id="5348" class="mx li il mt b fv nc mz l na nb">app.use(router.routes())</span><span id="fda9" class="mx li il mt b fv nc mz l na nb">module.exports = app</span></pre><p id="cb67" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">在调用<code class="eh nd ne nf mt b">app.listen(3000)</code>之前，导出koa服务器实例是很重要的。这样，在测试中，我们可以访问<code class="eh nd ne nf mt b">app.callback</code>，我们将避免API测试中最常见的一个错误:不关闭服务器以及随后的内存泄漏。Supertest将为我们打开和关闭服务器。</p><p id="08a0" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">测试的基本模板非常简单:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="cb3c" class="mx li il mt b fv my mz l na nb">// test/root.spec.js</span><span id="be88" class="mx li il mt b fv nc mz l na nb">const request = require('supertest')<br/>const app = require('../server')</span><span id="1aac" class="mx li il mt b fv nc mz l na nb">test('root route', async () =&gt; {<br/>  const response = await request(app.callback()).get('/')</span><span id="44d6" class="mx li il mt b fv nc mz l na nb">  expect(response).toBeDefined() // @TODO<br/>})</span></pre><p id="f4b1" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">首先，我们描述请求:指定路径、设置标题或追加数据。结果是一个响应承诺。我们等待它获取内容。</p><p id="f467" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">其次，我们对响应运行断言。在下文中，我们将用更复杂的东西替换样板文件中类似占位符的<code class="eh nd ne nf mt b">expect(response).toBeDefined</code>。</p><h2 id="6244" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">项目级断言</h2><p id="87b6" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">当然，<code class="eh nd ne nf mt b">response</code>只是另一个JS对象，所以我们可以使用通常的断言。这是华伦天奴做的:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="3b24" class="mx li il mt b fv my mz l na nb">expect(response.status).toEqual(200)<br/>expect(response.type).toEqual('application/json')<br/>expect(response.body.data).toEqual('Sending some JSON')<br/>expect(Object.keys(response.body.person)).toEqual(<br/>  expect.arrayContaining(['name', 'lastname', 'role', 'age'])<br/>)</span></pre><p id="d53c" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">很好，除了最后一个期望。那本很混乱，不好读。</p><p id="3d02" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">就可读性和可维护性而言，我更喜欢Expect中更具表现力的语法。</p><h2 id="d0a9" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">对象相等</h2><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="2990" class="mx li il mt b fv my mz l na nb">expect(response.body).toEqual(<br/>  expect.objectContaining({<br/>    person: {<br/>      name: expect.anything(),<br/>      lastname: expect.any(String),<br/>      role: expect.stringMatching(/^Brewery/),<br/>      age: expect.any(Number)<br/>    }<br/>  })<br/>)</span></pre><p id="1b0d" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">在这里，我们描述结构。想想流或prop类型。</p><p id="e4ed" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">Expect有几个实用程序:<code class="eh nd ne nf mt b"><a class="ae ii" href="http://facebook.github.io/jest/docs/en/expect.html#expectanything" rel="noopener ugc nofollow" target="_blank">expect.anything()</a></code>、<code class="eh nd ne nf mt b"><a class="ae ii" href="http://facebook.github.io/jest/docs/en/expect.html#expectanyconstructor" rel="noopener ugc nofollow" target="_blank">expect.any(constructor)</a></code>、<code class="eh nd ne nf mt b"><a class="ae ii" href="http://facebook.github.io/jest/docs/en/expect.html#expectstringcontainingstring" rel="noopener ugc nofollow" target="_blank">expect.stringContaining(string)</a></code>、<code class="eh nd ne nf mt b"><a class="ae ii" href="http://facebook.github.io/jest/docs/en/expect.html#expectstringmatchingregexp" rel="noopener ugc nofollow" target="_blank">expect.stringMatching(regexp)</a></code>，还有一些<a class="ae ii" href="http://facebook.github.io/jest/docs/en/expect.html#methods" rel="noopener ugc nofollow" target="_blank">其他的</a>。</p><p id="5b42" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">Jest将尝试匹配整个对象。所以当我们添加字段<code class="eh nd ne nf mt b">nationality</code>时，它会失败。要忽略其他属性，使用<code class="eh nd ne nf mt b">expect.objectContaining</code>，就像我们处理整个主体一样(记住它也包括字段<code class="eh nd ne nf mt b">data</code>)。</p><h2 id="df79" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">快照</h2><p id="6675" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">还有一个替代方案:快照。可能已经注意到，它们与TDD相反。人们无法合理地遵循TDD并使用快照。当我们在观察模式下一点一点地逐步构建API时，或者当我们为已经工作的服务器添加测试时，它们显示了它们的力量。</p><p id="fd3e" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">从快照开始再简单不过了:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="3381" class="mx li il mt b fv my mz l na nb">expect(response.body).toMatchSnapshot()</span></pre><p id="6900" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">并且保存了快照:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="b5bc" class="mx li il mt b fv my mz l na nb">// test/__snapshots__/root.spec.js.snap</span><span id="f8eb" class="mx li il mt b fv nc mz l na nb">exports[`root route with snapshots 1`] = `<br/>Object {<br/>  "data": "Sending some JSON",<br/>  "person": Object {<br/>    "age": 42,<br/>    "lastname": "Vaněk",<br/>    "name": "Ferdinand",<br/>    "role": "Brewery worker",<br/>  },<br/>}<br/>`;</span></pre><p id="9306" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">我要重复一遍:这再简单不过了。</p><p id="ed1b" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">然而，它确保我们返回我们需要的东西，而不是额外的东西——这同样重要。</p><h1 id="9ab1" class="lh li il bd lj lk mj lm ln lo mk lq lr jr ml js lt ju mm jv lv jx mn jy lx ly dt translated">不仅是Koa</h1><p id="e170" class="pw-post-body-paragraph kd ke il kg b kh lz jm kj kk ma jp km mb mc kp kq md me kt ku mf mg kx ky kz hn dt translated">当然，我们展示的一切也适用于其他框架。例如，API测试对于Express来说是一样的——对于重构来说是多么的方便！</p><blockquote class="ka kb kc"><p id="6acf" class="kd ke kf kg b kh ki jm kj kk kl jp km kn ko kp kq kr ks kt ku kv kw kx ky kz hn dt translated">所有代码在GitHub上都有:<a class="ae ii" href="https://github.com/robinpokorny/jest-example-koa" rel="noopener ugc nofollow" target="_blank">robinpokorny/jest-example-KOA</a>。</p></blockquote><p id="48e8" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">如果您有任何意见或建议，请联系我。我喜欢解谜，所以我会看你发给我的任何关于Jest的问题。</p></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h2 id="1d1c" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">幻灯片:</h2><figure class="mo mp mq mr fq hw"><div class="bz el l di"><div class="nv nw l"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Slides from the presentation in Berlin</figcaption></figure></div><div class="ab cl la lb hc lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hn ho hp hq hr"><h2 id="55a7" class="mx li il bd lj nh ni nj ln nk nl nm lr mb nn no lt md np nq lv mf nr ns lx nt dt translated">相关:</h2><ul class=""><li id="7243" class="nx ny il kg b kh lz kk ma mb nz md oa mf ob kz oc od oe of dt translated"><a class="ae ii" href="https://www.valentinog.com/blog/testing-api-koa-jest/" rel="noopener ugc nofollow" target="_blank">用Jest和Supertest测试Koa的简明介绍</a>作者<a class="mh mi gr" href="https://medium.com/u/18e37911137f?source=post_page-----1b6e84521b71--------------------------------" rel="noopener" target="_blank">瓦伦蒂诺·加利亚迪</a></li><li id="81c2" class="nx ny il kg b kh og kk oh mb oi md oj mf ok kz oc od oe of dt translated">用Koa 2、Mocha和Chai构建TDD RESTful APIs的介绍</li><li id="fdb4" class="nx ny il kg b kh og kk oh mb oi md oj mf ok kz oc od oe of dt translated"><a class="ae ii" href="https://hackernoon.com/api-testing-with-jest-d1ab74005c0a" rel="noopener ugc nofollow" target="_blank">Koen van Gilst</a>用Jest 进行API测试</li><li id="4d63" class="nx ny il kg b kh og kk oh mb oi md oj mf ok kz oc od oe of dt translated"><a class="ae ii" href="https://github.com/koajs/koa/issues/1017" rel="noopener ugc nofollow" target="_blank">测试异步/等待中间件？</a> (GitHub问题)</li><li id="6c34" class="nx ny il kg b kh og kk oh mb oi md oj mf ok kz oc od oe of dt translated"><a class="ae ii" href="https://www.youtube.com/watch?v=bw10S2BK-5w" rel="noopener ugc nofollow" target="_blank">玩笑异步测试</a>(演示记录)</li><li id="01ca" class="nx ny il kg b kh og kk oh mb oi md oj mf ok kz oc od oe of dt translated"><a class="ae ii" href="https://daveceddia.com/snapshot-testing-apis-with-jest/" rel="noopener ugc nofollow" target="_blank">用Jest对API进行快照测试</a>作者<a class="mh mi gr" href="https://medium.com/u/3f6706a859f8?source=post_page-----1b6e84521b71--------------------------------" rel="noopener" target="_blank">戴夫·塞迪亚</a></li><li id="c757" class="nx ny il kg b kh og kk oh mb oi md oj mf ok kz oc od oe of dt translated"><a class="ae ii" href="https://www.youtube.com/watch?v=yUlfFMhVfZo" rel="noopener ugc nofollow" target="_blank">玩笑快照测试</a>(演示记录)</li></ul><p id="e639" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated"><em class="kf">如果你喜欢这个帖子，请别忘了给个</em>👏<em class="kf">下面的</em>。每一个鼓掌通知对我来说都是一种激励。</p><p id="6aed" class="pw-post-body-paragraph kd ke il kg b kh ki jm kj kk kl jp km mb ko kp kq md ks kt ku mf kw kx ky kz hn dt translated">如果你想了解更多，我最近在YouTube上开了一个关于JavaScript的频道。我每周都会发布新视频，所以可以考虑订阅。从一开始就在那里，帮助我变得更好。</p><div class="ht hu fm fo hv ol"><a href="https://www.youtube.com/c/robinpokorny?sub_confirmation=1" rel="noopener  ugc nofollow" target="_blank"><div class="om ab ej"><div class="on ab oo cl cj op"><h2 class="bd im fv z el oq eo ep or er et ik dt translated">YouTube上的罗宾·波科尔尼</h2><div class="os l"><h3 class="bd b fv z el oq eo ep or er et ek translated">JavaScript是我的激情所在:我喜欢写JavaScript，我喜欢读JavaScript，我喜欢说JavaScript。</h3></div><div class="ot l"><p class="bd b gc z el oq eo ep or er et ek translated">www.youtube.com/c/robinpokorny</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ib ol"/></div></div></a></div></div></div>    
</body>
</html>