<html>
<head>
<title>Understanding the enigma of RxJava (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解RxJava之谜(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-the-enigma-of-rxjava-part-1-8e04a456d9de?source=collection_archive---------4-----------------------#2016-10-03">https://medium.com/hackernoon/understanding-the-enigma-of-rxjava-part-1-8e04a456d9de?source=collection_archive---------4-----------------------#2016-10-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5136" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第一次听说<strong class="it hv"> <em class="jp">函数式反应式编程</em> </strong> ( <strong class="it hv"> <em class="jp"> FRP </em> </strong>)和<strong class="it hv"> <em class="jp"> RxJava </em> </strong>的时候我想到的第一件事就是为什么？！为什么要从我舒适的命令式编程和AsyncTask世界中切换出来？当时答案并不明确，但经过最近的经历，我觉得有必要这样做。在这一部分，我会试着说服你，老实说我自己也有一点，去学习<em class="jp"> RxJava </em>，然后我们会讨论我们试图使用<em class="jp"> RxJava </em>实现什么(Psst…提示，这是一个范例)。在后面的部分中，我们将介绍RxJava的基础知识以及它在现实生活中基于android应用程序的实现。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="23a6" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">为什么要用RxJava？</h1><p id="6937" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">如果你在问这个问题，那很好。我们开始吧！我开始了这个名为<a class="ae la" href="https://github.com/GauravChaddha1996/Pokify" rel="noopener ugc nofollow" target="_blank"> Pokify </a>的项目，它是基于神奇宝贝的。在那个项目中，我创建了一个简单的SQLlite Helper类，并将Executor服务用于线程化，将AsyncTask用于其他异步操作。管理所有这些是一件痛苦的事情，在无数次咒骂和修复我的愚蠢错误之后，我意识到我的线程和异步操作需要<em class="jp"> RxJava </em>。甚至没有浪费一秒钟，我就把自己交给了RxJava，因为这就是开发人员做的事情，当他们对自己手中的东西不满意时，他们会学习新的东西。</p><blockquote class="lb"><p id="2a3f" class="lc ld hu bd le lf lg lh li lj lk jo ek translated">如果你也诅咒了AsyncTask，那么是时候停止诅咒，开始前进了。</p></blockquote><p id="3924" class="pw-post-body-paragraph ir is hu it b iu lm iw ix iy ln ja jb jc lo je jf jg lp ji jj jk lq jm jn jo hn dt translated">哦，我有足够的理由说服你继续前进！<br/>下面是使用<em class="jp"> RxJava </em>的一些<strong class="it hv"> <em class="jp">优点</em> </strong>:</p><ol class=""><li id="37ea" class="lr ls hu it b iu iv iy iz jc lt jg lu jk lv jo lw lx ly lz dt translated"><strong class="it hv"> <em class="jp">避开</em> </strong> <a class="ae la" href="https://www.quora.com/What-is-callback-hell" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="jp">回调地狱</em> </strong> </a> <strong class="it hv"> <em class="jp">。如果你曾经做过嵌套网络调用，你就知道我在说什么。这是一个非常常见的问题，也是一个可怕的问题，RxJava很容易解决这个问题。</em></strong></li><li id="7045" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated"><strong class="it hv"> <em class="jp">穿线轻松百倍。</em> </strong> <br/>再也不用担心更新视图和得到可怕的“~UI线程崩溃”。</li><li id="8a2f" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated">使用RxJava，异步操作变得更加容易。  <br/>使用AsyncTasks你有一大套问题。代码不干净，测试它是一件痛苦的事，或者如果你试图在设备旋转时缓存一个AsyncTask的下载，那么祝你好运！此外，无论是活动生命周期的处理，还是多个网络调用，甚至是嵌套AsyncTasks的错误处理……我都可以继续下去，但我想您已经看到了问题所在，对吗？有了RxJava，所有这些都可以很容易地解决。</li><li id="209b" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated"><strong class="it hv"> <em class="jp"> UI和视图处理。</em> </strong> <br/>当用户在编辑视图中搜索某样东西时，是否曾发出网络呼叫？我们不想对每个' R '，' Rx '，' RxJa '或' Rxjava '进行网络调用。我们只想在用户停止输入至少250毫秒后这样做。如果你开始考虑命令式编码的解决方案，你会发现其中的缺陷，对吗？有了RxJava，我们可以使用<a class="ae la" href="http://reactivex.io/documentation/operators/debounce.html" rel="noopener ugc nofollow" target="_blank">去抖</a>操作符很容易地解决这个问题。<br/>其他视图处理工作，比如监听双击或三击，对于RxJava来说是小菜一碟。收听编辑视图文本更改要容易无限倍。想要为按钮点击创建多个监听器吗？没问题！使用RxJava，您还可以利用许多其他很酷的优势来完成这一切。</li><li id="5b45" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated"><strong class="it hv"> <em class="jp">一种标准的错误处理机制。</em> </strong> <br/>有没有做过简单的天气app？你必须首先获取位置，然后是天气。如果使用AsyncTasks，它将有嵌套的任务和嵌套的错误处理机制，这不是很干净。使用RxJava，您可以获得处理所有这些错误的标准方法。整洁，对不对？</li><li id="246b" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated"><strong class="it hv"> <em class="jp"> RxJava有很多，字面意思，很多运算符供你使用。</em> </strong> <br/>你能想到的任何东西都很可能已经有了操作符。那也全都测试过了！</li><li id="9362" class="lr ls hu it b iu ma iy mb jc mc jg md jk me jo lw lx ly lz dt translated">使用<em class="jp"> FRP </em>范型(范型的库是RxJava ),您将能够轻松地添加或删除代码。如果你正确地遵循了FRP，大多数时候你的结构会告诉你错误是从哪里来的，然后我们就可以消灭它！</li></ol><p id="53e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我说服你了吗？很好。 </p><p id="71ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我告诉你真相。我们想用<strong class="it hv"> <em class="jp"> RxJava </em> </strong>实现的想法，其实就是<strong class="it hv"> <em class="jp">函数式反应式编程(FRP) </em> </strong>。这是我们应该如何编写程序或项目的范例。事实上，它是像OOPS paradigm等许多其他范例中的一个。在android中轻松跟随它的方法是通过RxJava，这是一个用于Java的<a class="ae la" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"> Reactive </a> X的扩展库，也可以在Android中用于FRP中的编程。FRP范式在某些地方也可以不使用RxJava来实现，这将在FRP的分解中得到明确。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="5be7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">函数式反应式编程的崩溃</h1><p id="6a33" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">好了，现在你在我这边了，我们将分解<em class="jp">函数式反应式编程</em>来清楚地理解它的所有方面；它是什么，以及我们将如何使用RxJava在我们的项目中实现它。它由两部分组成:<strong class="it hv"> <em class="jp">功能编程</em> </strong>和<strong class="it hv"> <em class="jp">反应编程</em> </strong>。</p><h2 id="a161" class="mf jy hu bd jz mg mh mi kd mj mk ml kh jc mm mn kl jg mo mp kp jk mq mr kt ms dt translated">什么是函数式编程？</h2><p id="34c0" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">通常，我们大多数人都有一种命令式思维。我们把事物看作是集合了两种东西的对象:数据和作用于数据的函数。在OOPS范式中，数据可以被改变或变异。但是在<strong class="it hv"> <em class="jp">函数式编程</em> </strong>中，我们这样编写程序，以避免数据突变。相反，每当我们需要改变数据时，我们就创建一组新的数据。这有助于转换数据集的函数将始终返回相同的值，因为原始数据集永远不会发生变化。因此，这个函数很容易进行单元测试。</p><h2 id="d8b6" class="mf jy hu bd jz mg mh mi kd mj mk ml kh jc mm mn kl jg mo mp kp jk mq mr kt ms dt translated">命令式方法和功能式方法的区别</h2><p id="5bb5" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">好吧，我知道，我知道，你想要一个例子。假设你有一个通用的东西叫做图形。正方形、圆形、三角形都是图形。现在你有一个包含3个方块的盒子。你需要通过一些操作将它们全部转换成圆形。解决这个问题的必要方法是遍历列表，将每个项目从正方形转换成三角形，然后再一个一个地转换成圆形。</p><figure class="mu mv mw mx fq my fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff mt"><img src="../Images/8c0ba3407df21e51ecf3fb72080f622a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cfi2TTwXDSfUYErw0GkVAg.jpeg"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">Imperative approach to problem: Given a data set( list) of 3 squares convert it to data set of circles using operators.</figcaption></figure><p id="f297" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，功能方法的不同之处在于，我们将3个项目放在一个流中。然后我们把这一串正方形转换成一串三角形，再把这一串转换成一串圆形。</p><figure class="mu mv mw mx fq my fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff mt"><img src="../Images/9859d0c749a3e880fbbdc1fe1beadd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ky7P2Dt44CFioLE563TT6Q.jpeg"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">Functional approach to problem: Given a data set( list) of 3 squares convert it to data set of circles using operators.</figcaption></figure><p id="18b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两种范式都取得了相同的结果，只是如何实现的问题。对于异步和其他一些操作，命令式方法有很多问题，这就是为什么我们要切换到函数式方法。</p><h2 id="b6a6" class="mf jy hu bd jz mg mh mi kd mj mk ml kh jc mm mn kl jg mo mp kp jk mq mr kt ms dt translated">纯函数</h2><p id="09fa" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated"><em class="jp">函数式编程</em>引入了一个非常酷的概念<strong class="it hv"> <em class="jp">纯函数。</em> </strong>这篇博客<a class="ae la" href="http://blog.jenkster.com/2015/12/what-is-functional-programming.html" rel="noopener ugc nofollow" target="_blank">帖子</a>很好地解释了这一点。这是不使用RxJava的FRP的实现，非常强大。帖子的总结是这样的；<br/>考虑功能:</p><pre class="mu mv mw mx fq nj nk nl nm aw nn dt"><span id="be1a" class="mf jy hu nk b fv no np l nq nr">function a()<br/>{<br/>    item = queue.getItem();<br/>    process(item);<br/>    print(item.name);<br/>}</span></pre><p id="ff2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该函数有一个隐藏输入:“queue.getItem()”。之所以称之为隐藏，是因为只看函数签名无法确定函数是否需要它。这就是所谓的<em class="jp"/><strong class="it hv"><em class="jp">侧因</em> </strong> <em class="jp">。</em>同样，它打印的是商品名称。这也不能通过签名来预测，因此是一个被称为<strong class="it hv">副作用的隐藏输出。</strong></p><p id="4d2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所想象的，副作用和副作用会导致大量的问题和错误，因为它们是隐藏的，所以不容易被跟踪。它们还会导致测试问题。</p><p id="73f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任何没有隐藏输入或输出的函数都称为纯函数。对于纯函数，查看函数签名，我们可以确定它的输入和输出是什么。示例:</p><pre class="mu mv mw mx fq nj nk nl nm aw nn dt"><span id="90b7" class="mf jy hu nk b fv no np l nq nr">function int add ( Integer a, Integer b) <br/>{<br/>    c = a+b;<br/>    return c;<br/>}</span></pre><p id="630e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jp">函数式编程</em> </strong>是尽可能使用纯函数并去除副作用的编程。函数式语言是鼓励并提供简单方法来进行函数式编程的语言。</p><h2 id="82ce" class="mf jy hu bd jz mg mh mi kd mj mk ml kh jc mm mn kl jg mo mp kp jk mq mr kt ms dt translated">何时使用功能方法？</h2><p id="1f75" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我认为函数式编程更适合处理人的数据，而OOPS更适合处理人的数据。在MVP模式中，模型类应该使用OOP范例，而这些类中的函数应该使用函数方法。转换或管理类(像MVP中的presenter或views)也应该使用纯函数来操作具有纯函数的模型对象。两全其美的好处！使用功能方法，我们可以获得上面列出的优势。</p><h2 id="929b" class="mf jy hu bd jz mg mh mi kd mj mk ml kh jc mm mn kl jg mo mp kp jk mq mr kt ms dt translated">什么是反应式编程？</h2><p id="00c4" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated"><strong class="it hv"> <em class="jp">反应式编程</em> </strong>是一种范式，它认为我们的代码应该对变化做出反应。在之后的<a class="ae la" href="https://edgecoders.com/how-to-explain-reactive-programming-to-a-5-year-old-e802c5385aee#.iqzs91ibd" rel="noopener ugc nofollow" target="_blank">中给出了对反应式编程的很好的解释。这篇文章的一个很好的例子是:假设你点了一杯咖啡，在等待的时候，你的注意力转移了，你开始阅读一篇中型文章。现在，只要你点的菜上来，叫到你的名字，你就会对这种变化做出反应，你的注意力就会从文章转移到咖啡上。这是反应式编程。</a></p><h2 id="b74c" class="mf jy hu bd jz mg mh mi kd mj mk ml kh jc mm mn kl jg mo mp kp jk mq mr kt ms dt translated">什么是函数式反应式编程？</h2><p id="efa3" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">函数式和反应式编程的混合称为<strong class="it hv"> <em class="jp">函数式反应式编程。</em> </strong>在这种情况下，我们对项目进行编码，这样我们就可以使用功能范例对变化做出反应。理解FRP的一个很好的资源是Andre Stalz的《T4要点》。为了理解FRP，让我们用一个例子来看看函数式编程和反应式编程的混合:</p><figure class="mu mv mw mx fq my fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff ns"><img src="../Images/2ed7d7bbbb9da435e88ff9b191811727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RwiqAB-9LUAlEDGrZYOVg.jpeg"/></div></div><figcaption class="nf ng fg fe ff nh ni bd b be z ek">Button click stream example for FRP</figcaption></figure><p id="f7be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们必须在一个按钮上听两次或更多次点击。我们可以在marble图中看到，首先是用户点击按钮的事件流。这个事件流是一个函数式编程数据集。首先，我们使用RxJava的操作符buffer来限制点击流。该运算符将合并/累加给定参数时间(250毫秒)内的所有事件，并将它们作为一个事件相加。为了在<em class="jp"> FRP </em>方面非常清楚，我们使用了来自<em class="jp"> RxJava </em>的纯函数来获得一个新的数据集，该数据集与原始数据集有所不同。接下来，我们将这些点击事件作为点击次数映射到数据集。我们又有了一个新的变异数据集，它是使用<em class="jp"> RxJava </em>的函数方法创建的。然后，我们过滤数据集，找出大于或等于2的项目。现在，我们使用反应范式对这些点击数据集做出反应。<br/>为了总结这个例子，我们使用了<em class="jp"> RxJava </em>的纯函数操作符来变异我们的按钮点击流(从点击流到累积流到点击流的数量，然后过滤它),然后我们对变异的按钮点击流做出反应。这个范例就是<em class="jp"> FRP </em>，因为我们使用函数方法来做反应式编程。</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><h1 id="4551" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="17fd" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">我希望我已经说服你尝试在<strong class="it hv"> <em class="jp">函数式反应编程</em> </strong>中编码，并使用<strong class="it hv"> <em class="jp"> RxJava </em> </strong>。在下一篇文章中，我将讨论RxJava的一些基础知识。如果你有任何疑问或者想纠正noob的做法，欢迎在下面评论。</p><p id="0474" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你觉得这篇文章做了它的工作，点击下面的绿色小心脏按钮。</p><div class="mu mv mw mx fq ab cb"><figure class="nt my nu nv nw nx ny paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nt my nu nv nw nx ny paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nt my nu nv nw nx ny paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nz oa ob"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb oc jd je jf od jh ji jj oe jl jm jn jo hn dt translated"><a class="ae la" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae la" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae la" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae la" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb oc jd je jf od jh ji jj oe jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae la" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae la" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mu mv mw mx fq my fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff of"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>