<html>
<head>
<title>How C# beats Scala in async programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#如何在异步编程中击败Scala</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-c-beats-scala-in-async-programming-27d824da02ba?source=collection_archive---------0-----------------------#2015-11-08">https://medium.com/hackernoon/how-c-beats-scala-in-async-programming-27d824da02ba?source=collection_archive---------0-----------------------#2015-11-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="37ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我之前的<a class="ae jp" rel="noopener" href="/@anicolaspp/implicit-conversions-in-scala-for-c-developers-92ea6c7902fa">帖子</a>中，我们解释了Scala编程语言的一些特性是如何与我们在C#编程语言中发现的特性重叠的。但是<em class="jq">隐含</em>和<em class="jq">类型扩展</em>并不是两种语言共享的唯一特征。</p><h2 id="0f25" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">演员模型</h2><p id="af37" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">正如维基百科呈现的那样</p><blockquote class="kr ks kt"><p id="57cc" class="ir is jq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated"><em class="hu">计算机科学中的actor模型是一个并发计算的数学模型，它将“actor”视为并发计算的通用原语:为了响应它接收到的一条消息，一个actor可以做出本地决策，创建更多actor，发送更多消息，并确定如何响应接收到的下一条消息。它既被用作理论上理解计算的框架，又被用作并发系统的几个实际实现的理论基础。</em></p></blockquote><p id="acaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Scala世界中，演员是一个大问题，C#默认情况下确实缺乏这种模式，但是有了Akka.NET来扭转局面。因为Actors只是一种可以在任何语言中实现的模式，所以我们将跳过它，直接跳到每种语言中多线程的核心。</p><h2 id="3e21" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">未来与任务</h2><p id="a141" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">Scala提出了未来的概念，它作为一个占位符，代表将来某个时刻可用的值。期货通常被定义为持有这些价值的通用占位符。让我们看看如何使用它们。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="6773" class="jr js hu lc b fv lg lh l li lj">val aFuture = Future {<br/>    1 to 1000000<br/>}</span></pre><p id="11c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，<strong class="it hv"> aFuture </strong>保存序列的值，一旦它变得可用。它也是强类型的，所以我们可以用不同的语法来定义它，只是为了显示它的定义。它看起来像这样</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="29f8" class="jr js hu lc b fv lg lh l li lj">val aFuture: Future[Seq[Int]] = Future {<br/>    1 to 1000000<br/>}</span></pre><p id="dd74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">未来不会阻止当前线程上的执行，因此它将在不同的线程中异步执行。</p><p id="eb63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们有一个长任务要异步执行，比如从web下载一个文件，我们可以用Futures异步做这个操作。事情是这样的</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="7376" class="jr js hu lc b fv lg lh l li lj">val aFuture = Future {<br/>    val file = downloadFileFromTheWeb()<br/>    file<br/>}</span></pre><p id="2177" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，我们只是开始下载文件，在此期间，我们仍然可以在未来的定义后做一些其他有趣的操作。但是当我们需要异步操作的结果时会发生什么呢？期货提供了一种机制来做到这一点，在我看来这是过去的事情，但让我们回顾一下。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="c478" class="jr js hu lc b fv lg lh l li lj">case class File(content: String)</span><span id="deba" class="jr js hu lc b fv lk lh l li lj">object File{<br/>  def apply(content: String) = new File(content)<br/>}</span><span id="c829" class="jr js hu lc b fv lk lh l li lj">val aFuture = Future {<br/>    val file = downloadFileFromTheWeb()<br/>    file<br/>}</span><span id="bb52" class="jr js hu lc b fv lk lh l li lj">aFuture onSuccess  {<br/>    case File(content) =&gt; println(content)<br/>}</span><span id="204d" class="jr js hu lc b fv lk lh l li lj">aFuture onFailure {<br/>      case error =&gt; println("Error Downloading from the web: " + error.printStackTrace())<br/>    }</span></pre><p id="44c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">定义了<em class="jq"> onSuccess </em>和<em class="jq"> onFailure </em>函数，以便根据长时间计算的结果执行它们，然后我们可以相应地采取行动。然而，如果我们需要等待长时间操作的结果，事情会变得更奇怪。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="5a46" class="jr js hu lc b fv lg lh l li lj">val aFuture = Future {<br/>    val file = downloadFileFromTheWeb()<br/>    file<br/>}</span><span id="229f" class="jr js hu lc b fv lk lh l li lj">val file = Await.result(aFuture, 0 nanos)</span></pre><p id="ba91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们只是等待计算完成，然而，Future对象对这个调用没有控制权，因为它是在执行上下文中调用的，而不是在操作本身中。</p><p id="e922" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C#提供了一个更好的API来解决这些问题，尽管它以与Scala相同的方式对这些想法建模。然而。NET API比较好用。</p><p id="f25d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的问题看起来像这样</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="d219" class="jr js hu lc b fv lg lh l li lj">public class File<br/>{<br/>    public string Content { get; set; }<br/>}</span><span id="6335" class="jr js hu lc b fv lk lh l li lj"> var task = Task&lt;File&gt;.Factory.StartNew(() =&gt;<br/>                {<br/>                    var file = downloadFileFromTheWeb();</span><span id="284d" class="jr js hu lc b fv lk lh l li lj">                    return file;<br/>                });</span></pre><p id="5f6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们想等待这个任务的结果，我们只需要说</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="f382" class="jr js hu lc b fv lg lh l li lj">var file = task.Result;<br/>Console.WriteLine(file.Content)</span></pre><p id="5dd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将一直阻塞，直到任务以与<strong class="it hv"> Await.result </strong>相同的方式结束。然而，控制动作是由任务本身执行的，而不是由需要导入到我们的执行环境中的全局执行器上下文执行的。</p><p id="7bc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C#对<em class="jq">回调</em>也有更好的支持。它们不再被称为<em class="jq">回调</em>，而是<em class="jq">任务继续</em>。让我们使用C#延续实现我们在Scala中所做的。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="b3c1" class="jr js hu lc b fv lg lh l li lj">var taks = Task&lt;File&gt;.Factory.StartNew(() =&gt;<br/>                {<br/>                    var file = downloadFileFromTheWeb();</span><span id="33f3" class="jr js hu lc b fv lk lh l li lj">                    return file;<br/>                })<br/>                .ContinueWith(t =&gt;<br/>                    {<br/>                        Console.WriteLine(t.Result);<br/>                    }, TaskContinuationOptions.OnlyOnRanToCompletion);</span></pre><p id="6b69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将与期货的<em class="jq"> onSuccess </em>相同，但是，<em class="jq"> ContinueWith </em>方法也返回一个任务，因此它可以链接到其他操作。<em class="jq">任务延续选项</em>决定我们在什么情况下执行延续，因此不需要不同的回调。</p><p id="0e92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所看到的，C#任务是执行长时间运行任务的一种更直观的方式，更好地支持解决任务完成后的问题。然而，还有另一个与链接任务相关的问题。</p><h2 id="4c49" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">C#适用模型</h2><p id="c160" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">引入async/await模型是为了解决延续的问题，我真的相信C#在这个领域比其他编程语言要先进得多。</p><p id="6c3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们回顾一下下面的伪代码:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="1efb" class="jr js hu lc b fv lg lh l li lj">var taks = Task&lt;File&gt;.Factory.StartNew(() =&gt;<br/>                {<br/>                    var file = downloadFileFromTheWeb();<br/>                        // &lt;-- here want to do some other async operation such as writing the file content to a database<br/>                        // &lt;-- then here we want to log to a file the db result<br/>                    return file;<br/>                })</span></pre><p id="0fa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以通过这样做来实现这一目标</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="c5b3" class="jr js hu lc b fv lg lh l li lj">var taks = Task&lt;File&gt;.Factory.StartNew(() =&gt;<br/>    {<br/>        var file = downloadFileFromTheWeb();</span><span id="cf80" class="jr js hu lc b fv lk lh l li lj">       return file;<br/>    })<br/>     .ContinueWith(t =&gt;<br/>     {<br/>            Task&lt;string&gt;.Factory.StartNew(() =&gt;<br/>            {<br/>                string fileContent = t.Result.Content;<br/>                 return saveToDb(fileContent);<br/>              }).ContinueWith(x =&gt;<br/>                {<br/>                    logToFile(x.Result);<br/>                 }) ;<br/>      }, TaskContinuationOptions.OnlyOnRanToCompletion);</span></pre><p id="2fa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意延续的链接会变得多么复杂，在Scala中也会发生同样的事情，但是C#有一个特性在这方面杀死了Scala。最后一段代码可以使用C#中的async/await模式以下面的方式重写</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="86dc" class="jr js hu lc b fv lg lh l li lj">void main(...){<br/>    var task = Do();<br/>    <br/>    RefreshUIOrDoSomethingElse();<br/>    <br/>    //if we need to do something with the file we do<br/>    File file = task.Result; // or File file = await task;<br/>}</span><span id="374a" class="jr js hu lc b fv lk lh l li lj"><br/>  private static async Task&lt;File&gt; Do()<br/>        {<br/>            var file = await Task&lt;File&gt;.Factory.StartNew(downloadFileFromTheWeb);</span><span id="36e3" class="jr js hu lc b fv lk lh l li lj">            var messageFromDb = await saveToDbAsync(file.Content);</span><span id="7052" class="jr js hu lc b fv lk lh l li lj">            await logToFileAsync(messageFromDb);</span><span id="be55" class="jr js hu lc b fv lk lh l li lj">            return file;<br/>        }</span><span id="256c" class="jr js hu lc b fv lk lh l li lj">        static Task logToFileAsync(string s)<br/>        {<br/>            return Task.Factory.StartNew(()=&gt;Console.WriteLine(s));   <br/>        }</span><span id="d0c5" class="jr js hu lc b fv lk lh l li lj">        private static List&lt;string&gt; db = new List&lt;string&gt;(); </span><span id="9cf1" class="jr js hu lc b fv lk lh l li lj">        static Task&lt;string&gt; saveToDbAsync(string fileContent)<br/>        {<br/>            return Task&lt;string&gt;.Factory.StartNew(() =&gt;<br/>                {<br/>                    db.Add(fileContent);<br/>                    return fileContent;<br/>                });<br/>        }</span></pre><p id="27a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们正在使用C# async/await API，以便让代码尽可能的干净。让我们分析一下，以确保我们都在同一页上。</p><p id="bf24" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们调用方法<strong class="it hv"> Do() </strong>，它在Scala中基本上返回一个任务或未来，但有趣的部分是它内部发生了什么。最重要的部分是<strong class="it hv"> Do() </strong>不遮挡。</p><p id="7a73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">第二，在里面<strong class="it hv"> Do() </strong>我们正在异步下载文件，但是那是<em class="jq">可获得的</em>所以此刻我们调用</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="0460" class="jr js hu lc b fv lg lh l li lj">var file = await Task&lt;File&gt;.Factory.StartNew(downloadFileFromTheWeb);</span></pre><p id="0f68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">控制流程返回到<strong class="it hv">主</strong>功能。一旦文件下载完毕，系统选择一个可用的线程，并从原来的位置继续执行任务。是啊！所以该任务中下一个要执行的将是</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="0fe4" class="jr js hu lc b fv lg lh l li lj">var messageFromDb = await saveToDbAsync(file.Content);</span></pre><p id="3035" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是那句话也是可接受的，所以控制权再次返回到<strong class="it hv"> main </strong>直到DB完成它的工作。当DB完成时，选择另一个线程(不必是以前的那个线程),任务恢复。同样的事情发生在</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="3925" class="jr js hu lc b fv lg lh l li lj">await logToFileAsync(messageFromDb);</span></pre><p id="b928" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当它完成时，任务再次恢复，然后文件被返回。</p><p id="d555" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，<em class="jq"> await </em>是强类型的，因此它的执行结果将是可唤醒任务的一般类型。举个例子，</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="61e4" class="jr js hu lc b fv lg lh l li lj">static Task&lt;string&gt; saveToDbAsync(string fileContent){...}</span></pre><p id="a2a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">返回一个<strong class="it hv">任务&lt;字符串&gt;T3】所以如果我们<em class="jq">等待</em>这个任务，结果将是一个<em class="jq">字符串</em></strong></p><p id="358c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">公平地说，Scala可以使用<em class="jq"> map </em>实现类似async/await的功能。让我们看一个例子。</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="76e8" class="jr js hu lc b fv lg lh l li lj">aFuture onSuccess  {<br/>      case File(content) =&gt; println(content)<br/>}</span></pre><p id="966a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">前面的代码可以实现如下</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="04b0" class="jr js hu lc b fv lg lh l li lj">aFuture.map(println)</span></pre><p id="4d02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一个我在网上找到的更复杂的例子</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="a426" class="jr js hu lc b fv lg lh l li lj">val firstLove = future {<br/>      Thread.sleep(500)<br/>      "i love you"<br/>    }</span><span id="8efc" class="jr js hu lc b fv lk lh l li lj">    val thenBetray = firstLove map {<br/>      case loveLetter =&gt; {<br/>        Console.println(loveLetter)<br/>        Thread.sleep(500)<br/>        "not really"<br/>      }<br/>    }</span><span id="c9e2" class="jr js hu lc b fv lk lh l li lj">    thenBetray onSuccess {<br/>      case partingWords =&gt; Console.println(partingWords)<br/>    }</span></pre><p id="0184" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以看到<em class="jq"> map </em>如何帮助链接未来，但是代码仍然会变得相当混乱。还有其他的Scala构造可以和map<em class="jq">一起工作，但是它们不能和C#解决这个问题的方式相提并论。</em></p><h2 id="a573" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">结局</h2><p id="89d4" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我们看到了Scala如何在不阻塞调用线程的情况下实现长时间运行的操作。我们还看到了如何通过使用class <strong class="it hv"> Task </strong>在C#中实现同样的功能。我们了解了如何在Scala中使用回调实现continuationss，以及如何在C#中通过链接<strong class="it hv">任务</strong>来实现continuation。最终，我们看到了C#如何通过使用async/await模式解决链接问题，以及它对开发人员来说是多么自然。</p><p id="5e9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当谈到异步编程时，我希望这种比较有助于同步两个世界的开发人员。当有人谈论<strong class="it hv">未来</strong>时，你可以<em class="jq">将</em>映射到<strong class="it hv">任务</strong>或者反过来。</p><p id="74f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">玩得开心，两种语言都很棒，我都喜欢。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="5aa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">接下来阅读:</em></p><p id="5e8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" rel="noopener" href="/@anicolaspp/implicit-conversions-in-scala-for-c-developers-92ea6c7902fa#.qyjnst1d5"> <em class="jq">面向C#开发者的Scala中的隐式转换</em> </a></p><blockquote class="kr ks kt"><p id="07d4" class="ir is jq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">赞/在脸书上给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jq it b iu iv iw ix iy iz ja jb ku jd je jf kv jh ji jj kw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>