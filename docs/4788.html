<html>
<head>
<title>One SQL Cheat Code For Blazing Fast JSON Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个快速JSON查询的SQL欺骗代码</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/one-sql-cheat-code-for-blazing-fast-json-queries-d0cb6160d380?source=collection_archive---------4-----------------------#2017-06-22">https://medium.com/hackernoon/one-sql-cheat-code-for-blazing-fast-json-queries-d0cb6160d380?source=collection_archive---------4-----------------------#2017-06-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="28ef" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">非持久化计算列索引如何提高JSON查询的性能</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/9fc141063c55cd5c7dfcb97c219a86be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4JkgNafzFQ1oDGZMZnI9Q.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="aa59" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">最近在<a class="ae kt" href="https://blog.bertwagner.com/video-json-usage-and-performance-in-sql-server-2016-524edcc5a610" rel="noopener ugc nofollow" target="_blank">SQL</a>T3】服务器T5】2016<a class="ae kt" href="https://blog.bertwagner.com/when-is-it-appropriate-to-store-json-in-sql-server-8ed1eed1520d" rel="noopener ugc nofollow" target="_blank">a</a><a class="ae kt" href="https://blog.bertwagner.com/who-stuck-these-letters-in-my-datetimes-b42cbd6e987d" rel="noopener ugc nofollow" target="_blank">lot</a>做JSON。</p><p id="c897" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">许多人对在<a class="ae kt" href="https://hackernoon.com/tagged/sql-server" rel="noopener ugc nofollow" target="_blank"> SQL Server </a>中使用<a class="ae kt" href="https://hackernoon.com/tagged/json" rel="noopener ugc nofollow" target="_blank"> JSON </a>感到犹豫的一个原因是，他们认为查询它一定很慢——SQL应该擅长关系数据，而不是字符串解析，对吗？</p><p id="cece" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">事实证明，独立的SQL Server JSON函数的性能非常好。更好的是，通过在JSON解析的计算列上使用索引，可以使针对JSON数据的查询以可笑的速度运行。在这篇文章中，我想看看SQL是如何以如此高的性能解析*的。</p><p id="8a2d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><em class="ku">*“Parse”在这里其实是一个谎言——它在幕后做别的事情。你会明白我的意思的，继续读！</em></p><h1 id="f327" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">SQL Server中的计算列</h1><p id="0139" class="pw-post-body-paragraph jx jy hu jz b ka ln iv kc kd lo iy kf kg lp ki kj kk lq km kn ko lr kq kr ks hn dt translated">让JSON索引在SQL server上工作的唯一方法是使用一个<a class="ae kt" href="https://technet.microsoft.com/en-us/library/ms191250(v=sql.105).aspx" rel="noopener ugc nofollow" target="_blank">计算列</a>。计算列基本上是执行函数来计算其值的列。</p><p id="0afa" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">例如，假设我们有一个包含一些汽车JSON数据的表:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="43eb" class="lx kw hu lt b fv ly lz l ma mb">DROP TABLE IF EXISTS dbo.DealerInventory;<br/>CREATE TABLE dbo.DealerInventory<br/>(<br/>  Id int IDENTITY(1,1) PRIMARY KEY,<br/>  Year int,<br/>  JsonData nvarchar(300)<br/>);</span><span id="d773" class="lx kw hu lt b fv mc lz l ma mb">INSERT INTO dbo.DealerInventory (Year, JsonData) VALUES (2017, '{ "Make" : "Volkswagen", "Model" : "Golf" }');</span><span id="9646" class="lx kw hu lt b fv mc lz l ma mb">INSERT INTO dbo.DealerInventory (Year, JsonData) VALUES (2017, '{ "Make" : "Honda", "Model" : "Civic" }');</span><span id="53b9" class="lx kw hu lt b fv mc lz l ma mb">INSERT INTO dbo.DealerInventory (Year, JsonData) VALUES (2017, '{ "Make" : "Subaru", "Model" : "Impreza" }');</span><span id="bb91" class="lx kw hu lt b fv mc lz l ma mb">SELECT * FROM dbo.DealerInventory;</span><span id="d89b" class="lx kw hu lt b fv mc lz l ma mb">/* Output:<br/>Id    Year     JsonData<br/>----- -------- ---------------------------------------------<br/>1     2017     { "Make" : "Volkswagen", "Model" : "Golf" }<br/>2     2017     { "Make" : "Honda", "Model" : "Civic" }<br/>3     2017     { "Make" : "Subaru", "Model" : "Impreza" }<br/>*/</span></pre><p id="5ab0" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们可以向表中添加一个新的计算列“Make ”,它从每一行的JSON字符串中解析并提取Make属性:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="497d" class="lx kw hu lt b fv ly lz l ma mb">ALTER TABLE dbo.DealerInventory<br/>ADD Make AS JSON_VALUE(JsonData, '$.Make');</span><span id="1b7a" class="lx kw hu lt b fv mc lz l ma mb">SELECT * FROM dbo.DealerInventory;</span><span id="fee0" class="lx kw hu lt b fv mc lz l ma mb">/* Output:<br/>Id Year  JsonData                                    Make<br/>-- ----- ------------------------------------------- ----------<br/>1  2017  { "Make" : "Volkswagen", "Model" : "Golf" } Volkswagen<br/>2  2017  { "Make" : "Honda", "Model" : "Civic" }     Honda<br/>3  2017  { "Make" : "Subaru", "Model" : "Impreza" }  Subaru<br/>*/</span></pre><p id="6f46" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">默认情况下，上面的Make computed列是非持久化的，这意味着它的值永远不会存储到数据库中(也可以创建持久化的计算列，但这是另一个时间的主题)。相反，每次对我们的<code class="eh md me mf lt b">dbo.DealerInventory</code>表运行查询时，SQL Server都会计算每一行的值。</p><p id="3600" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这样做的性能不是很好——它本质上是一个标量函数，针对我们输出的每一行运行:(。但是，当您将计算列与索引结合使用时，会发生一些有趣的事情。</p><h1 id="78d5" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">是时候深入了解DBCC·佩奇了</h1><p id="9133" class="pw-post-body-paragraph jx jy hu jz b ka ln iv kc kd lo iy kf kg lp ki kj kk lq km kn ko lr kq kr ks hn dt translated"><code class="eh md me mf lt b">DBCC Page</code>是一个未记录的SQL Server函数，显示了存储在SQL页面文件中的原始数据的样子。页面文件是SQL Server存储数据的方式。</p><p id="f7e4" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">在本文的其余部分，我们将研究数据页(存储SQL中实际表数据的地方)和索引页(存储我们的索引数据的地方)如何受到非持久化计算列的影响——以及它们如何使JSON查询超快。</p><p id="183e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">首先，让我们看看我们现有的数据。我们首先打开跟踪标志3604，并使用<code class="eh md me mf lt b">DBCC IND</code>来获取数据的页面id。关于<code class="eh md me mf lt b">DBCC IND</code>和<code class="eh md me mf lt b">DBCC PAGE</code>中列定义的更多细节可以在<a class="ae kt" href="https://www.sqlskills.com/blogs/paul/inside-the-storage-engine-using-dbcc-page-and-dbcc-ind-to-find-out-if-page-splits-ever-roll-back/" rel="noopener ugc nofollow" target="_blank"> Paul Randal关于主题</a>的博客文章中找到。</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="522b" class="lx kw hu lt b fv ly lz l ma mb">DBCC TRACEON(3604);</span><span id="466c" class="lx kw hu lt b fv mc lz l ma mb">-- "Sandbox" is the name of my database<br/>DBCC IND('Sandbox','dbo.DealerInventory',-1);</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mg"><img src="../Images/a8b8c736678c5aff21ff738933578826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCzUX6Z_US9fZAceHAMhpA.png"/></div></div></figure><p id="65e8" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">如果您查看上面的结果，第2行包含我们的数据页面(由PageType = 1表示),该页面的PagePID是305088(如果您在家玩，您的PagePID很可能是别的什么)。如果我们使用<code class="eh md me mf lt b">DBCC PAGE</code>来查找PagePID，我们会得到这样的结果:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="e36e" class="lx kw hu lt b fv ly lz l ma mb">DBCC PAGE('Sandbox',1,305088,3) WITH TABLERESULTS</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mh"><img src="../Images/1daf43f24e9f4918a216a4912c59d925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaA-flG1Di52Y3t2GoHyXg.png"/></div></div></figure><p id="c6a7" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">你可以看到我们用红色突出显示的三行数据。这里需要注意的重要一点是，我们解析的“Make”值的计算列是真正非持久化的，并且在哪里都找不到，这意味着它必须在查询执行期间为每一行生成。</p><p id="822e" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">现在，如果我们向非持久化计算列添加一个索引，然后再次运行<code class="eh md me mf lt b">DBCC IND</code>会怎么样:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="aef1" class="lx kw hu lt b fv ly lz l ma mb">CREATE NONCLUSTERED INDEX IX_ParsedMake ON dbo.DealerInventory (Make)</span><span id="1833" class="lx kw hu lt b fv mc lz l ma mb">DBCC IND('Sandbox','dbo.DealerInventory',-1);</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mi"><img src="../Images/5e4899680d08a03fcbca2ab895fcf9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfYZcBlExGRYtsQU5MIOmg.png"/></div></div></figure><p id="4836" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">您现在会注意到，除了数据页305088 (PageType = 1)，我们还有一个索引页305096 (PageType = 2)。如果我们同时检查数据页和索引页，我们会发现一些有趣的事情:</p><pre class="jk jl jm jn fq ls lt lu lv aw lw dt"><span id="8d52" class="lx kw hu lt b fv ly lz l ma mb">DBCC PAGE('Sandbox',1,305088,3) WITH TABLERESULTS</span><span id="f8e3" class="lx kw hu lt b fv mc lz l ma mb">DBCC PAGE('Sandbox',1,305096,3) WITH TABLERESULTS</span></pre><p id="1ad3" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">我们的数据页面没有任何变化:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mj"><img src="../Images/b6c3735bfa652adec1e64ed3f8f5266a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktTY-u5w4ihA9EmrWYS9Zw.png"/></div></div></figure><p id="b47f" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但是我们的索引页面包含“Make”列的解析值:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/fa9a55cd383b1112768936e1f4cdda58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*6Ysi1X2IlwDo7J3tkWOwlw.png"/></div></figure><h1 id="84a9" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">这是什么意思？我以为非持久化的计算列不会保存到磁盘上！</h1><p id="98ab" class="pw-post-body-paragraph jx jy hu jz b ka ln iv kc kd lo iy kf kg lp ki kj kk lq km kn ko lr kq kr ks hn dt translated">完全正确:我们的非持久化计算列“Make”没有保存到磁盘上的数据页。然而，如果我们在非持久化的计算列上创建索引，计算值<em class="ku">将在索引页面上持久化</em>！</p><p id="bcc2" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这基本上是一个为计算列建立索引的欺骗代码。</p><p id="38ee" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">SQL将仅在向表中插入或更新行时(或在初始索引创建期间)计算“Make”值—我们计算列的所有未来检索都将来自预先计算的索引页。</p><p id="504a" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">这就是SQL能够如此快速地解析索引JSON属性的原因；SQL Server可以在索引中查找预先解析的值，并以惊人的速度返回正确的数据，而不需要扫描表并解析表中每行的JSON数据。</p><p id="4ca1" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">就个人而言，我认为这使得JSON在SQL Server 2016中更容易(和实用)使用。即使我们在数据库中存储了大量的JSON字符串，我们仍然可以索引单个属性并以惊人的速度返回结果。</p><p id="4d43" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">喜欢这篇文章吗？请推荐给它一颗绿色的心💚<em class="ku">下文。</em></p><p id="4916" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><em class="ku">你对你的表使用计算列索引吗？在下面的评论中告诉我他们的情况吧！</em></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ml jw l"/></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="jv jw l"/></div></figure><div class="jk jl jm jn fq ab cb"><figure class="mm jo mn mo mp mq mr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mm jo mn mo mp mq mr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mm jo mn mo mp mq mr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ms mt mu"><p id="f922" class="jx jy ku jz b ka kb iv kc kd ke iy kf mv kh ki kj mw kl km kn mx kp kq kr ks hn dt translated"><a class="ae kt" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kt" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kt" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kt" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jx jy ku jz b ka kb iv kc kd ke iy kf mv kh ki kj mw kl km kn mx kp kq kr ks hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kt" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kt" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff my"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ml jw l"/></div></figure></div></div>    
</body>
</html>