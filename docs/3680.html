<html>
<head>
<title>react-frontload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反作用-前负荷</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-frontload-3ff68988cca?source=collection_archive---------5-----------------------#2017-04-17">https://medium.com/hackernoon/react-frontload-3ff68988cca?source=collection_archive---------5-----------------------#2017-04-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="55a5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">将来自API的数据请求绑定到React组件</h2></div><blockquote class="jj jk jl"><p id="902a" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jp hv">Tl；博士</strong></p><p id="abb1" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">在React应用程序中，一个常见的需求是在服务器和客户端呈现从API动态加载到组件中的数据。</p><p id="919e" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jp hv"> react-frontload </strong>是一个库，它允许你声明性地将定制的数据加载逻辑绑定到你的组件，然后当组件在服务器和客户端上呈现时，自动触发数据加载。</p><p id="b027" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">它很容易集成到您现有的React堆栈中，并且<strong class="jp hv">不需要对您现有的数据API </strong>进行任何更改。</p></blockquote><p id="8d88" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv">github</strong>:<a class="ae km" href="https://github.com/davnicwil/react-frontload" rel="noopener ugc nofollow" target="_blank">https://github.com/davnicwil/react-frontload</a></p><p id="4ad9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> npm包</strong> : <a class="ae km" href="https://www.npmjs.com/package/react-frontload" rel="noopener ugc nofollow" target="_blank">反应-前负荷</a></p><p id="cf2b" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">请继续阅读，探索这个问题，<strong class="jp hv"> react-frontload </strong>如何解决它，并查看一些代码示例。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h2 id="7e5f" class="ku kv hu bd kw kx ky kz la lb lc ld le kj lf lg lh kk li lj lk kl ll lm ln lo dt translated">典型的使用案例</h2><p id="d3c0" class="pw-post-body-paragraph jm jn hu jp b jq lp iv js jt lq iy jv kj lr jy jz kk ls kc kd kl lt kg kh ki hn dt translated">在最简单的用例中，您有一个视图组件，它显示一些URL的动态数据，其中包含从API加载数据所需的参数。</p><p id="9c2d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">例题</em> </strong></p><blockquote class="jj jk jl"><p id="de14" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><code class="eh lu lv lw lx b">www.myreactapp.co/profiles/<strong class="jp hv">davnicwil</strong></code> <em class="hu">显示用户</em><strong class="jp hv"><em class="hu">davnicwil</em></strong>的个人资料视图</p><p id="225a" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><em class="hu">加载</em> <strong class="jp hv"> <em class="hu"> davnicwil的</em> </strong> <em class="hu">配置文件数据，向</em> <code class="eh lu lv lw lx b">api.myreactapp.co/users/<strong class="jp hv">davnicwil</strong></code>发出GET请求</p></blockquote><p id="ed6a" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">直到组件的初始呈现(包括初始呈现)的一切都是同步的。然而，数据请求是异步的。根据设计，<a class="ae km" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>组件渲染生命周期是同步的。一旦组件呈现开始，就无法等到数据请求解决后再继续。异步数据请求和组件呈现必须分离。</p><p id="6d0c" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这种分离可以通过一种简单的方式实现，即通过props将所需的数据传递给视图组件，如果这些props为空，则呈现一个加载器。</p><p id="f233" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">例</em> </strong></p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="6fb6" class="ku kv hu lx b fv mg mh l mi mj">const ProfileView = (props) =&gt; (<br/>  props.profile<br/>    ? &lt;div&gt;{props.profile.fullName}'s profile&lt;/div&gt;<br/>    : &lt;div&gt;loading..&lt;/div&gt;<br/>)</span></pre></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h2 id="96c6" class="ku kv hu bd kw kx ky kz la lb lc ld le kj lf lg lh kk li lj lk kl ll lm ln lo dt translated">问题是</h2><p id="27cf" class="pw-post-body-paragraph jm jn hu jp b jq lp iv js jt lq iy jv kj lr jy jz kk ls kc kd kl lt kg kh ki hn dt translated">重要的问题是:数据请求何时被激发？</p><p id="77d9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv">在客户端</strong>上，数据请求什么时候触发并不重要。它可以在组件的初始渲染之前或之后发生。重要的是，当请求被解析时，结果被输入到组件的props中。React将重新渲染组件，这样就完成了。在客户端，组件可以被认为是长期存在的状态机，只要它们的属性被更新，就会无限期地等待重新渲染。</p><p id="2e0f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">例子</em> </strong></p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="7c93" class="ku kv hu lx b fv mg mh l mi mj">class ProfileContainer extends React.Component {</span><span id="7263" class="ku kv hu lx b fv mk mh l mi mj">  componentDidMount () {<br/>    // asynchronously load the profile <br/>    // into this.props.boundProfile<br/>    // via your state management solution of choice,   <br/>    getProfileAsync(this.props.username)<br/>  }</span><span id="157a" class="ku kv hu lx b fv mk mh l mi mj">  render () {<br/>    // this.props.boundProfile will at some point<br/>    // contain the loaded profile. For the initial<br/>    // render it will be undefined<br/>    return (<br/>      &lt;ProfileView profile={this.props.boundProfile} /&gt;<br/>    )<br/>  }</span><span id="1135" class="ku kv hu lx b fv mk mh l mi mj">}</span></pre><p id="7af2" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">在服务器上，顺序很重要。这是因为对于每个单独的页面请求，我们会创建相同的视图组件，使用您提供的任何初始属性呈现一次，然后丢弃。任何通过props传递的数据都必须在这个渲染发生之前加载。在服务器上，组件最好被认为是一个纯函数，而不是一个长期存在的状态机。</p><p id="15bc" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> <em class="jo">举例</em> </strong></p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="dee3" class="ku kv hu lx b fv mg mh l mi mj">const handleServerPageRequest = async (req, res) =&gt; { <br/>  // data request must happen first.<br/>  // wait until it's done before continuing<br/>  const profile = await getProfileAync(req.body.username)</span><span id="82c8" class="ku kv hu lx b fv mk mh l mi mj">  // render component passing loaded data via props<br/>  // note that this is a plain synchronous function call<br/>  const markup = ReactDOM.renderToString(<br/>    &lt;ProfileContainer profile={profile} /&gt;<br/>  )</span><span id="d8f8" class="ku kv hu lx b fv mk mh l mi mj">  // send the rendered markup in the response<br/>  res.send(markup)<br/>}</span></pre><p id="0922" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">客户机和服务器的两种模式都很简单，但是需要不同的连接来获得请求和随后的组件(重新)呈现。</p><p id="df96" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这两种情况的高级意图是相同的:指定一些数据依赖项将被加载到props中，以便组件进行呈现——在服务器上同步，在客户机上异步。</p><p id="0961" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">还有另一个重要的特性，上面的模式没有考虑到。当用数据在服务器上呈现一个组件时，我们可能不希望组件一在客户机上呈现就重新加载数据。我们需要组件知道它已经被服务器呈现了，然后只在更新用于数据请求的参数时重新加载数据。例如，如果URL中的用户名在应用内导航中发生变化，并且组件需要加载和呈现不同的用户配置文件，则用户名属性会更新。当然，我们可以在上面的模式之上实现这个特性，但是它涉及到很多容易出错的小细节，即使有状态管理解决方案的帮助。</p><p id="ba5d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">在为我的组件一次又一次地实现这些模式的连接代码之后，我最终发现自己真的需要一个抽象。连接代码本身并不复杂，但是有很多细节，所以通常的规则适用——一旦您需要为多个组件重复它，它就不再是可管理的了。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h2 id="6154" class="ku kv hu bd kw kx ky kz la lb lc ld le kj lf lg lh kk li lj lk kl ll lm ln lo dt translated">一个解决方案</h2><p id="a779" class="pw-post-body-paragraph jm jn hu jp b jq lp iv js jt lq iy jv kj lr jy jz kk ls kc kd kl lt kg kh ki hn dt translated">在使用各种模式编写一个库的几次尝试之后，我最终发现了我想要的特性集:</p><ul class=""><li id="b566" class="ml mm hu jp b jq jr jt ju kj mn kk mo kl mp ki mq mr ms mt dt translated"><strong class="jp hv">声明性的、协同定位的、普通的JS数据加载逻辑:</strong>一个组件的数据加载逻辑应该只是一个常规的JS函数，为async返回一个承诺。该功能应与组件位于同一位置。</li><li id="22cf" class="ml mm hu jp b jq mu jt mv kj mw kk mx kl my ki mq mr ms mt dt translated"><strong class="jp hv">习惯用法React: </strong>数据加载功能应该只通过组件props与应用程序的其余部分进行交互，这样它就可以很好地与堆栈其余部分中的任意库进行交互，而不需要React本身之外的任何隐式依赖或集成。</li><li id="a2a9" class="ml mm hu jp b jq mu jt mv kj mw kk mx kl my ki mq mr ms mt dt translated"><strong class="jp hv">组件封装&amp;独立性</strong>:不管组件放在应用程序组件树的哪个位置，组件的数据加载功能都应该是一样的。</li><li id="62d7" class="ml mm hu jp b jq mu jt mv kj mw kk mx kl my ki mq mr ms mt dt translated"><strong class="jp hv">可配置组件数据加载行为</strong>:当数据加载功能运行时，应该可以进行微调，以便处理特殊情况。默认设置应该为最常见的用例设置组件。</li></ul><p id="3382" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我将这些特性实现到一个库中:<strong class="jp hv"> react-frontload。</strong>下面是使用react-frontload的结果，和之前的例子一样。</p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="d301" class="ku kv hu lx b fv mg mh l mi mj">import { <strong class="lx hv">frontloadConnect </strong>} from 'react-frontload'</span><span id="4112" class="ku kv hu lx b fv mk mh l mi mj">// assuming here that getProfileAsync returns a Promise that<br/>// resolves when the profile is loaded into props.boundProfile<br/>const frontload = (props) =&gt; (<br/>  getProfileAsync(props.username)<br/>)</span><span id="0c5b" class="ku kv hu lx b fv mk mh l mi mj">// all available options, set to the default values<br/>const options = {<br/>  noServerRender: false,<br/>  onMount: true,<br/>  onUpdate: true<br/>}</span><span id="9702" class="ku kv hu lx b fv mk mh l mi mj">// just decorate the same underlying component from earlier<br/>const ProfileView =<br/>  <strong class="lx hv">frontloadConnect</strong>(frontload, options)((props) =&gt; (<br/>    props.profile<br/>      ? &lt;div&gt;{props.profile.fullName}'s profile&lt;/div&gt;<br/>      : &lt;div&gt;loading..&lt;/div&gt;<br/>  ))</span></pre><p id="5f5e" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">只需这几行代码，就可以在客户机和服务器上加载和呈现配置文件数据，我们还将获得前面讨论过的好特性，即在服务器呈现之后，请求不会在第一次客户机呈现时被不必要地重新触发。</p><p id="b8d8" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">剩下的就是两个微小的改变，让你的应用程序能够感知前端负载。</p><p id="eaa5" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">1.用<strong class="jp hv"> Frontload </strong> provider包装您的应用程序</p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="9fea" class="ku kv hu lx b fv mg mh l mi mj">// before<br/>const Application = () =&gt; (<br/>  &lt;div&gt;<br/>    {/* application content here */}<br/>  &lt;/div&gt;<br/>)</span><span id="a501" class="ku kv hu lx b fv mk mh l mi mj">// after: react-frontload aware<br/>const Application = () =&gt; (<br/>  &lt;Frontload&gt;<br/>    &lt;div&gt;<br/>      {/* application content here */}<br/>    &lt;/div&gt;<br/>  &lt;/Frontload&gt;<br/>)</span></pre><p id="1b87" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">2.在服务器上使用特殊的react-front load<strong class="jp hv">server render</strong>函数</p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="4fe0" class="ku kv hu lx b fv mg mh l mi mj">// before<br/>const store = initStore(req)<br/>const markup = ReactDOM.renderToString(<br/>  &lt;Application store={store} /&gt;<br/>)<br/>res.send(markup)</span><span id="f07f" class="ku kv hu lx b fv mk mh l mi mj">// after: react-frontload aware<br/>import { <strong class="lx hv">serverRender </strong>} from 'react-frontload'</span><span id="b383" class="ku kv hu lx b fv mk mh l mi mj">...</span><span id="b3d2" class="ku kv hu lx b fv mk mh l mi mj">const store = initStore(req)<br/>// encapsulate exactly the same render code as above in a<br/>// function and pass it <strong class="lx hv">serverRender</strong><br/>const markup = serverRender(() =&gt; ( <br/>  ReactDOM.renderToString(&lt;Application store={store} /&gt;)<br/>))<br/>res.send(markup)</span></pre><p id="f9f7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这就是我们所需要的。已经可以用了。</p><p id="e246" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">只是为了对示例中缺少的代码进行评论——即，将异步加载的概要文件绑定到props.boundProfile，将URL中的用户名绑定到props——我特意省略了这些细节，因为已经建立了库和模式，react-frontload对您使用哪一个没有意见。</p><p id="d6bd" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这是因为组件的frontload函数只通过props与组件交互。这是设计目标之一，希望它清楚地表明在任何现有的堆栈中使用react-frontload是多么简单。您可以像往常一样将这些绑定绑定到组件属性，然后可以在组件的frontload函数中访问它们。您不需要做任何额外的事情来让绑定工作。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h2 id="2b75" class="ku kv hu bd kw kx ky kz la lb lc ld le kj lf lg lh kk li lj lk kl ll lm ln lo dt translated">react-frontload API</h2><p id="0bdc" class="pw-post-body-paragraph jm jn hu jp b jq lp iv js jt lq iy jv kj lr jy jz kk ls kc kd kl lt kg kh ki hn dt translated"><code class="eh lu lv lw lx b"><strong class="jp hv">frontloadConnect(frontload, [options])(Component)</strong></code></p><p id="b66a" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> frontloadConnect </strong>是库和你要加载数据的组件之间的桥梁。</p><p id="442f" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">让我们来看一下frontload和options参数。</p><p id="4f4d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><code class="eh lu lv lw lx b"><strong class="jp hv">frontload(props)</strong></code></p><p id="0f07" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">用组件<strong class="jp hv">调用的函数</strong> props，并返回一个承诺，当所有要求的数据加载完成时，该承诺必须解决。</p><p id="914c" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">因此，Promise API的全部功能和灵活性可用于将数据加载行为的异步性封装到单个返回的Promise中——这意味着单个请求很好，但同样地，如果需要多个请求，它们可以与<code class="eh lu lv lw lx b">.then</code>链接(如果顺序重要)或与<code class="eh lu lv lw lx b">Promise.all</code>并行(如果它们是独立的)。</p><p id="b6d3" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><code class="eh lu lv lw lx b"><strong class="jp hv">[options]</strong></code></p><p id="4b10" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jp hv"> options </strong>对象提供了三种配置，它们指定了<strong class="jp hv"> frontload </strong>函数应该在客户端和服务器端触发的确切时间。如果任何特定的配置未定义，则采用其默认值。同样，如果整个<strong class="jp hv">选项</strong>对象未定义，所有三个配置都采用默认值。</p><p id="6dc7" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">1 <code class="eh lu lv lw lx b"><strong class="jp hv">noServerRender </strong>(boolean) [default false]</code></p><p id="94f0" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">当<code class="eh lu lv lw lx b">false</code>时，<strong class="jp hv">组件</strong>的<strong class="jp hv"> frontload </strong>函数将在每一个服务器渲染上运行。在这个例子中，这确保了组件服务器使用预期的概要文件呈现，而不是“加载”..占位符。</p><p id="767b" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">当<code class="eh lu lv lw lx b">true</code>时，<strong class="jp hv">组件</strong>的<strong class="jp hv">前端加载</strong>功能将不会在服务器渲染上运行。在本例中，组件将由服务器使用“加载”呈现..占位符，因为没有加载配置文件。</p><p id="854d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">重要的是，当这是<code class="eh lu lv lw lx b">true</code>的时候，它也关闭了阻止组件在服务器渲染之后装载数据的特性。假设设置了在挂载时加载数据的选项(如下所述)，frontload函数将在服务器渲染后的第一次挂载时触发，因为react-frontload知道数据没有在服务器上加载，并且“正在加载”占位符必须替换为载入的配置文件。</p><p id="a15c" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><em class="jo">注意</em>:如果您需要关闭整个应用程序的服务器渲染，而不是在每个单独的组件上设置此配置为真，那么<strong class="jp hv"> noServerRender </strong>可以改为在应用程序的<strong class="jp hv"> Frontload </strong> provider上设置为道具，如下所示:</p><pre class="ly lz ma mb fq mc lx md me aw mf dt"><span id="460f" class="ku kv hu lx b fv mg mh l mi mj">&lt;Frontload <strong class="lx hv">noServerRender</strong>&gt; <br/>  &lt;div&gt;<br/>    {/* app code */}<br/>  &lt;/div&gt;<br/>&lt;/Frontload&gt; </span></pre><p id="5011" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">2 <code class="eh lu lv lw lx b"><strong class="jp hv">onMount </strong>(boolean) [default true]</code></p><p id="ef1a" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">该选项切换当<strong class="jp hv">组件</strong>安装到客户端时<strong class="jp hv"> frontload </strong>功能是否触发。同样，这只在<strong class="jp hv">组件</strong>被服务器渲染之前跳过——更多细节见上文。</p><p id="351c" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">缺省值是<code class="eh lu lv lw lx b">true</code>，99%的情况下都应该是这样。毕竟，在几乎所有情况下，您都希望在第一次显示<strong class="jp hv">组件</strong>时加载并呈现数据。但是，它是作为一个选项提供的，以适应边缘情况。</p><p id="0363" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">3 <code class="eh lu lv lw lx b"><strong class="jp hv">onUpdate </strong>(boolean) [default true]</code></p><p id="c36d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">与<code class="eh lu lv lw lx b">onMount</code>非常相似，这个选项切换当<strong class="jp hv">组件</strong>的道具在客户端更新时<strong class="jp hv"> frontload </strong>功能是否应该触发。</p><p id="e667" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">缺省值是<code class="eh lu lv lw lx b">true</code>，同样，对于一个设计良好的应用组件树来说，当属性不变时，适当限制不必要的更新(通过<code class="eh lu lv lw lx b">shouldComponentUpdate</code>)很可能没问题。</p><p id="d098" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">对于边缘情况，或者为了消除在不可行的情况下改变触发虚假更新的组件树的需要，可以将其设置为<code class="eh lu lv lw lx b">false</code>。</p><p id="c31e" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">注意，有一种常见的情况，一些但不是所有的道具应该触发<strong class="jp hv">前端加载</strong>功能。在我们的例子中，我们总是希望在<code class="eh lu lv lw lx b">username</code>更新时启动它，但是如果有另一个道具<code class="eh lu lv lw lx b">textColor</code>也可以更新，但是不需要重新加载概要文件，那该怎么办呢？</p><p id="52fd" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我考虑过通过另一个<strong class="jp hv">选项</strong>字段进行配置，例如，通过提供属性名称，当它们更新时触发<strong class="jp hv"> frontload </strong>函数。但是我意识到这误入了DSL的领域，带来了所有的功耗和可维护性问题，事实上已经有了一种机制来处理JS的全部功能——回想一下<strong class="jp hv"> frontload </strong>函数本身接收<strong class="jp hv">组件</strong> props。因此，我们可以在<strong class="jp hv"> frontload </strong>函数本身中做出任意复杂的决定，决定是否在<strong class="jp hv">组件</strong>更新上实际触发任何昂贵的请求。</p><p id="72ca" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt">—</p><p id="73f9" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><code class="eh lu lv lw lx b"><strong class="jp hv">frontloadServerRender</strong>(renderFunction)</code></p><p id="76d1" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">可以将<strong class="jp hv"> frontloadServerRender </strong>函数视为对现有React服务器渲染逻辑的修饰，您必须将它封装在一个输出服务器渲染的React标记的<code class="eh lu lv lw lx b">renderFunction</code>中。通常，<code class="eh lu lv lw lx b">renderFunction</code>将是一个简单的<code class="eh lu lv lw lx b">ReactDOM.renderToString</code>调用的包装器。</p><p id="bb67" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">frontloadServerRender的输出与renderFunction产生的标记相同，可以以通常的方式在对客户端的响应中返回。它只不过是此功能的代理，其存在只是为了在最终渲染之前“注入”同步加载应用程序中所有frontload功能所需的管道代码。</p></div><div class="ab cl kn ko hc kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hn ho hp hq hr"><h2 id="b6c7" class="ku kv hu bd kw kx ky kz la lb lc ld le kj lf lg lh kk li lj lk kl ll lm ln lo dt translated">它是如何工作的？(即将推出)</h2><p id="97fd" class="pw-post-body-paragraph jm jn hu jp b jq lp iv js jt lq iy jv kj lr jy jz kk ls kc kd kl lt kg kh ki hn dt translated">在未来的一篇文章中，我会解释<strong class="jp hv">是如何实现的。现在，如果你好奇的话，请阅读源代码，我已经尽可能清晰地写了出来，它本身还附有一些实现注释。</strong></p><p id="03ed" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我希望你觉得这篇文章很有趣。我开发了<strong class="jp hv"> react-frontload </strong>来整理和改进我自己的应用程序中的代码，也是在思考这个问题一段时间并多次尝试和失败后想出一个解决它的好方法的一次学习经历。</p><p id="7121" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我把源代码和npm包放在那里，以防这个解决方案对React社区中的其他人有用。它有不错的测试覆盖率，我已经在我的副业项目<a class="ae km" href="https://postbelt.com" rel="noopener ugc nofollow" target="_blank">https://postbelt.com</a>的生产中使用了一段时间，在那里它没有出现任何问题。</p><p id="6cf1" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">然而，它很大程度上是为我的特定用例而编写的，很可能存在我没有发现的bug/edge用例，只是因为我还不需要使用它们。如果是这样的话，我非常乐意回答任何问题，并审查github回购上的PRs！</p><p id="dc1d" class="pw-post-body-paragraph jm jn hu jp b jq jr iv js jt ju iy jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">感谢你花时间阅读这篇文章。</p><blockquote class="jj jk jl"><p id="a9d8" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><a class="ae km" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae km" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae km" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae km" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">要了解更多信息，请<a class="ae km" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae km" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae km" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="jm jn jo jp b jq jr iv js jt ju iy jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae km" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae km" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ly lz ma mb fq mz"><div class="bz el l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>