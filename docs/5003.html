<html>
<head>
<title>Graphing it Out!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">画出来！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphing-it-out-2e99f8948602?source=collection_archive---------12-----------------------#2017-07-04">https://medium.com/hackernoon/graphing-it-out-2e99f8948602?source=collection_archive---------12-----------------------#2017-07-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f72a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jp" href="https://mmhaskell.com/blog/2017/6/19/profiling-in-haskell" rel="noopener ugc nofollow" target="_blank">的最后两篇文章</a>中，我们处理了一些算法问题。我们只能通过改进代码中的数据结构来解决这些问题。首先，我们使用Haskell的内置数组类型进行快速索引。当我们需要一棵细分树时，我们决定从头开始做。但是我们不能对遇到的每个问题都滚动自己的数据结构。因此，拥有一些我们可以用于更多这些高级主题的系统是件好事。</p><p id="3479" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">算法需要的最重要的一类数据结构是图。在表示复杂问题时，图表非常有用。它们对于表达数据点之间的关系非常有用。在本文中，我们将看到两种类型的图问题。我们将了解一个叫做<a class="ae jp" href="https://hackage.haskell.org/package/fgl" rel="noopener ugc nofollow" target="_blank">功能图形库</a> (FGL)的库，它在Hackage上可供我们使用。然后，我们将尝试使用这个库来构建图形。最后，我们会看到，一旦我们做出了图形，使用这个库来解决这些算法是多么简单。</p><p id="f7f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要获得我们将在本文中使用的完整代码集，请查看<a class="ae jp" href="https://www.github.com/jhb563/HaskellGraphs" rel="noopener ugc nofollow" target="_blank">Github库</a>。它将向您展示如何使用Stack将函数图形库引入您的代码。</p><p id="cfa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未使用过<a class="ae jp" href="https://docs.haskellstack.org/en/stable/README/" rel="noopener ugc nofollow" target="_blank"> Stack </a>，它是在Haskell中创建程序不可或缺的工具。您应该尝试一下我们的<a class="ae jp" href="https://academy.mondaymorninghaskell.com/" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>，了解更多相关信息。</p><h1 id="72ba" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">图表101</h1><p id="7467" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">对于那些不熟悉图形和图形算法的人，我将在这里解释一些基础知识。如果你已经非常熟悉这些，你可以跳过这一节。图形包含一系列对象，并对这些对象之间的各种关系进行编码。对于集合中的每个对象，我们都有一个“节点”。这些就像数据点。然后，为了表示每个关系，我们在两个不同的节点之间创建一条“边”。我们经常给这条边赋予某种值，作为关于关系的一条信息。在本文中，我们将把节点想象成地图上的地点，边代表地点之间的合法路线。每条边的标签就是距离。</p><p id="8ce2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">边可以是“有向的”也可以是“无向的”。有向边描述了节点之间的单向关系。无向边描述了一种双向关系。下面是一个有向边的图形示例:</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/db84c882626733701e68a0bd893b1d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7y-0p9UyctvSg0s3h2MZ1A.png"/></div></figure><h1 id="c0ba" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">用FGL制作图表</h1><p id="2bc0" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所以每当我们用FGL做图表时，我们会用两个步骤。首先，我们将创建图表的“节点”。然后我们会对边缘进行编码。假设我们正在读取一个输入流。该流将首先给出我们图中的节点数，然后是边数。然后我们将逐行读取一组三元组。前两个数字指的是“从”节点和“到”节点。第三个数字将代表距离。上图中的这条河流可能是这样的:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="08b4" class="lg jr hu lc b fv lh li l lj lk">6<br/>9<br/>1 2 3<br/>1 3 4<br/>2 3 5<br/>2 4 2<br/>2 5 6<br/>3 5 5<br/>4 6 9<br/>5 4 1<br/>5 6 10</span></pre><p id="2b47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将这样阅读这个输入流:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="5e0c" class="lg jr hu lc b fv lh li l lj lk">import Control.Monad (replicateM)<br/>import System.IO (Handle, hGetLine)</span><span id="8e94" class="lg jr hu lc b fv ll li l lj lk">data EdgeSpec = EdgeSpec<br/>  { fromNode :: Int<br/>  , toNode :: Int<br/>  , distance :: Int<br/>  }</span><span id="563e" class="lg jr hu lc b fv ll li l lj lk">readInputs :: Handle -&gt; IO (Int, [EdgeSpec])<br/>readInputs handle = do<br/>  numNodes &lt;- read &lt;$&gt; hGetLine handle<br/>  numEdges &lt;- (read &lt;$&gt; hGetLine handle)<br/>  edges &lt;- replicateM numEdges (readEdge handle)<br/>  return (numNodes, edges)</span><span id="522c" class="lg jr hu lc b fv ll li l lj lk">readEdge :: Handle -&gt; IO EdgeSpec<br/>readEdge handle = do<br/>  input &lt;- hGetLine handle<br/>  let [f_s, t_s, d_s] = words input<br/>  return $ EdgeSpec (read f_s) (read t_s) (read d_s)</span></pre><p id="6d1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的目标是以FGL的格式来编码这个图表。在这个库中，每个节点都有一个整数标识符。节点既可以是“已标记的”，也可以是“未标记的”。这个标签，如果存在的话，是和整数标识符分开的。我们将使用的函数要求我们的节点有标签，但是我们不需要这些额外的信息。所以我们将使用newtype包装同一个整数标识符。</p><p id="7148" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们知道了节点的数量，创建所有节点实际上是非常容易的。我们将从1到长度的每个数字做标签。然后我们用索引和标签的元组来表示每个节点。让我们启动一个函数来创建我们的图表:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="071e" class="lg jr hu lc b fv lh li l lj lk">import Data.Graph.Inductive.Graph (mkGraph)<br/>import Data.Graph.Inductive.PatriciaTree (Gr)</span><span id="bc64" class="lg jr hu lc b fv ll li l lj lk">…</span><span id="962b" class="lg jr hu lc b fv ll li l lj lk">newtype NodeLabel = NodeLabel Int <br/>type Distance = Int</span><span id="a596" class="lg jr hu lc b fv ll li l lj lk">genGraph :: (Int, [EdgeSpec]) -&gt; Gr NodeLabel Distance<br/>genGraph (numNodes, edgeSpecs) = mkGraph nodes edges<br/>  where<br/>    nodes = (\i -&gt; (i, NodeLabel i)) <br/>      &lt;$&gt; [1..numNodes]<br/>    edges = ...</span></pre><p id="007b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们制作的图表使用了“帕特里夏树”编码。关于这一点我们就不细说了。我们将只调用由库公开的一个简单的<code class="eh lm ln lo lc b">mkGraph</code>函数。我们将使返回值成为由节点标签类型和边标签类型参数化的图类型<code class="eh lm ln lo lc b">Gr</code>。正如我们所见，我们将使用整数的类型同义词<code class="eh lm ln lo lc b">Distance</code>来标记我们的边。</p><p id="f80e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们开始创造我们的优势。我们用<code class="eh lm ln lo lc b">EdgeSpec</code>指定的格式证明我们不需要做很多工作。正如带标签的节点类型是元组的同义词一样，带标签的边是三元组。它包含“从”节点、“到”节点的索引，然后是距离标签。在这种情况下，我们将使用有向边。我们对每个边缘规格都这样做，然后就完成了！</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="6f26" class="lg jr hu lc b fv lh li l lj lk">genGraph :: (Int, [EdgeSpec]) -&gt; Gr NodeLabel Distance<br/>genGraph (numNodes, edgeSpecs) = mkGraph nodes edges<br/>  where<br/>    nodes = (\i -&gt; (i, NodeLabel i)) <br/>      &lt;$&gt; [1..numNodes]<br/>    edges = (\es -&gt; (fromNode es, toNode es, distance es))<br/>      &lt;$&gt; edgeSpecs</span></pre><h1 id="ac3e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用图形算法</h1><p id="1122" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在假设我们想解决一个特定的图形问题。首先我们要解决最短路径问题。如果我们还记得上面的内容，我们图上从节点1到节点6的最短路径实际上是沿着顶部，从1到2到4到6。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/b09072911deb5f1e4b96db305a2f72f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*avhqDTVmTm1AUzjZoKjqlw.png"/></div></figure><p id="8f0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们如何从Haskell解决这个问题？我们将首先使用上面的函数来读取图形。然后，我们将想象为开始和结束节点读入两个以上的数字。</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="2a9c" class="lg jr hu lc b fv lh li l lj lk">solveSP :: Handle -&gt; IO ()<br/>solveSP handle = do<br/>  inputs &lt;- readInputs handle<br/>  start &lt;- read &lt;$&gt; hGetLine handle<br/>  end &lt;- read &lt;$&gt; hGetLine handle<br/>  let gr = genGraph inputs</span></pre><p id="37a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在有了FGL，我们可以简单地进行几次库调用，就可以得到结果了！我们将使用<code class="eh lm ln lo lc b">Query.SP</code>模块，该模块公开了查找最短路径及其长度的函数:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="fc68" class="lg jr hu lc b fv lh li l lj lk">import Data.Graph.Inductive.Query.SP (sp, spLength)</span><span id="b4c8" class="lg jr hu lc b fv ll li l lj lk">solveSP :: Handle -&gt; IO ()<br/>solveSP handle = do<br/>  inputs &lt;- readInputs handle<br/>  start &lt;- read &lt;$&gt; hGetLine handle<br/>  end &lt;- read &lt;$&gt; hGetLine handle<br/>  let gr = genGraph inputs<br/>  print $ sp start end gr<br/>  print $ spLength start end gr</span></pre><p id="77af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将得到输出，其中包含路径和距离的表示。假设“input.txt”包含我们上面的示例输入，除了多两行用于开始和结束节点“1”和“6”:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="e3c0" class="lg jr hu lc b fv lh li l lj lk">&gt;&gt; find-shortest-path &lt; input.txt<br/>[1,2,4,6]<br/>14</span></pre><p id="906f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以将文件从3改为6，然后我们会得到:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="8a45" class="lg jr hu lc b fv lh li l lj lk">&gt;&gt; find-shortest-path &lt; input2.txt<br/>[3,5,4,6]<br/>15</span></pre><p id="dc48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">酷！</p><h1 id="55a9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">最小生成树</h1><p id="d54b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们想象一个不同的问题。假设我们的节点是互联网枢纽。我们只想确定它们之间有某种联系。我们将选择边的子集来创建一棵“生成树”，连接我们所有的节点。当然，我们想以最便宜的方式做到这一点，通过使用到边的最小总“距离”。这将是我们的“最小生成树”。首先，让我们去掉所有箭头上的指示。我们可以通过查看这张图片来想象这个解决方案，我们会看到我们可以以19英镑的总成本连接我们的节点。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/27a204a1251beedf6ef880731f7878ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8zXPZlvhEdTbTPSchSmmdw.png"/></div></figure><p id="732c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好消息是编写这些代码并不需要太多的工作！首先，我们将稍微调整一下我们的图形结构。为了在这个场景中得到一个“无向图”,我们可以将箭头做成双向的，如下所示:</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="1b73" class="lg jr hu lc b fv lh li l lj lk">genUndirectedGraph :: (Int, [EdgeSpec]) -&gt; Gr NodeLabel Distance<br/>genUndirectedGraph (numNodes, edgeSpecs) = mkGraph nodes edges<br/>  where<br/>    nodes = (\i -&gt; (i, NodeLabel i)) <br/>      &lt;$&gt; [1..numNodes]<br/>    edges = concatMap (\es -&gt; <br/>      [(fromNode es, toNode es, distance es), (toNode es, fromNode es, distance es)])<br/>      edgeSpecs</span></pre><p id="25b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除此之外，我们现在要做的就是使用<code class="eh lm ln lo lc b">MST</code>模块中的<code class="eh lm ln lo lc b">msTree</code>函数！然后我们会得到我们的结果！</p><pre class="ku kv kw kx fq lb lc ld le aw lf dt"><span id="3148" class="lg jr hu lc b fv lh li l lj lk">import Data.Graph.Inductive.Query.MST (msTree)</span><span id="3bb0" class="lg jr hu lc b fv ll li l lj lk">...</span><span id="8cba" class="lg jr hu lc b fv ll li l lj lk">solveMST :: Handle -&gt; IO ()<br/>solveMST handle = do<br/>  inputs &lt;- readInputs handle<br/>  let gr = genUndirectedGraph inputs<br/>  print $ msTree gr</span><span id="fad0" class="lg jr hu lc b fv ll li l lj lk">{- GHC Output<br/>&gt;&gt; find-mst &lt; “input1.txt”<br/>[[(1,0)],[(2,3),(1,0)],[(4,2),(2,3),(1,0)],[(5,1),(4,2),(2,3),(1,0)],[(3,4),(1,0)],[(6,9),(4,2),(2,3),(1,0)]]<br/>-}</span></pre><p id="49bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个输出有点难以理解，但是它和我们上面看到的树是一样的。我们的输出是一个列表列表。每个子列表包含从一个节点到第一个节点的路径。路径列表有一系列元组，每个元组对应一条边。元组的第一个元素是起始节点，第二个元素是距离。</p><p id="1ac6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，第一个元素，<code class="eh lm ln lo lc b">[(1,0)]</code>指的是节点1如何通过从1开始的距离为0的单条“边”连接到自身。如果我们查看最后一个条目，我们会看到节点6通过经过节点4和2的路径连接到节点1，总距离为9、2和3。</p><h1 id="e140" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="0164" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">图形问题在编程中无处不在，但是要解决它们可能有点棘手。从头开始编写自己的图形数据结构肯定会很痛苦。写出一个完整的算法可能更难，即使是像Dijkstra算法这样众所周知的算法。在Haskell中，您可以使用函数图形库来简化这个过程。它有一个内置的格式来表示图形本身。建立这种结构可能有点乏味。但是一旦你有了它，解决许多不同的常见问题实际上是非常容易的。</p><p id="202e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下周，我们将和FGL一起做更多的工作。我们将探索一个不像我们在这里看到的那样一成不变的问题。首先，我们将采取一个更抽象的问题，并确定我们想为它做什么图。然后我们用FGL来解决这个图形问题。所以下周回来看看哈斯克尔的博客！。</p><p id="3512" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将FGL引入Haskell代码的最简单方法是使用<code class="eh lm ln lo lc b">Stack</code>工具。如果您对此不熟悉，您应该参加我们免费的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>。您将了解如何在代码中引入依赖关系的重要步骤。您还将看到堆栈程序中的不同组件，以及可以运行来操作它们的命令。</p><p id="e8af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未用Haskell编程，你应该试试！下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>。它会指引你在早期Haskell教育中找到一些有价值的资源。</p><div class="ku kv kw kx fq ab cb"><figure class="lp ky lq lr ls lt lu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lp ky lq lr ls lt lu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lp ky lq lr ls lt lu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lv lw lx"><p id="f922" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客们下午的开始。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ly it b iu iv iw ix iy iz ja jb lz jd je jf ma jh ji jj mb jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>