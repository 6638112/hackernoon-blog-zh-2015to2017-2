<html>
<head>
<title>AV1 Bitstream Analyzer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AV1比特流分析器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/av1-bitstream-analyzer-d25f1c27072b?source=collection_archive---------2-----------------------#2017-02-10">https://medium.com/hackernoon/av1-bitstream-analyzer-d25f1c27072b?source=collection_archive---------2-----------------------#2017-02-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/6e6f0f900ab92220edea91d04e4d1e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfPX5N_zqHWDsrX2e6a4Wg.png"/></div></div></figure><p id="5bbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Mozilla，我们一直在努力开发新的<a class="ae ka" href="https://en.wikipedia.org/wiki/AOMedia_Video_1" rel="noopener ugc nofollow" target="_blank"> AV1 </a>视频编解码器。AV1旨在比HEVC (h.265)和VP9提高25%的编码效率，由开放媒体联盟开发，Mozilla是其中的一员。</p><p id="80dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AV1是VP9的衍生版本，现在包括大量从<a class="ae ka" href="https://xiph.org/daala/" rel="noopener ugc nofollow" target="_blank">达拉</a>、<a class="ae ka" href="https://github.com/cisco/thor/commits/master" rel="noopener ugc nofollow" target="_blank">托尔</a>和VP10导入的附加编码工具和实验。这些实验以错综复杂和意想不到的方式相互作用，必须在各种各样的内容上仔细测试。这可能需要很长时间才能完成。单个视频帧有时可能需要一个多小时来编码，作为我们例行测试的一部分，我们编码了30个片段，每个片段包含60帧。编码过程是大规模并行的，并且在大量AWS实例上运行，但是即使有所有这些硬件，运行一个测试任务也可能需要几个小时甚至几天。</p><p id="c7fd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种计算成本使得开发者在本地编码和分析视频变得不方便。但这也揭示了一个有趣的问题。如果我们所有的测试和构建基础设施都在云中运行，为什么不也在云中运行我们所有的分析工具呢？</p><p id="32a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们在这方面的第一次尝试是比特流分析器。分析器解码AV1比特流，并显示关于比特流的各种细节。这些信息可以帮助编解码器工程师更容易地识别和修复错误。分析器的输入通常很小(一个编码的比特流)，但是输出非常大。例如，单个1080p视频帧会产生4MB的原始图像数据和大量的分析器元数据。如果分析器在本地运行，这通常不是问题，但是如果分析器在服务器上远程运行，那么带宽和延迟就成了大问题。</p><p id="8f3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理想的解决方案是直接在浏览器中运行分析器，这样就不需要下载分析器的输出。要做到这一点，我们需要将分析器和编解码器移植到<a class="ae ka" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>(幸运的是，我们有一个工具可以做到这一点，多亏了<a class="kb kc gr" href="https://medium.com/u/649eac8108d2?source=post_page-----d25f1c27072b--------------------------------" rel="noopener" target="_blank"> Alon Zakai </a>和许多其他工具，我们有了<a class="ae ka" href="http://kripken.github.io/emscripten-site/" rel="noopener ugc nofollow" target="_blank"> Emscripten </a>，并在浏览器中运行它。</p><p id="581e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">分析器由两个组件组成:<em class="kd"> decoder.js </em>它是编解码器的Emscripten编译版本和一个基于HTML的UI前端<em class="kd">。</em></p><p id="ed3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要分析一个视频，我们需要做的就是指定一个视频文件(在<em class="kd"> *中)。试管婴儿</em>格式。)和一个合适的<em class="kd"> decoder.js </em>文件对其进行解码。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="3fd5" class="kn ko hu kj b fv kp kq l kr ks">analyzer.html?decoder=decoder.js&amp;file=a.ivf&amp;file=b.ivf</span></pre><p id="d047" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的链接中，<em class="kd">analyzer.html</em>加载解码器，用它解码2个比特流<em class="kd"> a.ivf </em>和<em class="kd"> b.ivf </em>。或者，可以使用多个解码器来分析视频:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="9002" class="kn ko hu kj b fv kp kq l kr ks">analyzer.html?decoder=aDec.js&amp;file=a.ivf&amp;decoder=bDec.js&amp;file=b.ivf</span></pre><p id="04bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法的美妙之处在于，你可以轻松地分享解码视频的链接，所有这些都在浏览器中运行，不需要维护任何服务器基础设施。为提交给<a class="ae ka" href="https://arewecompressedyet.com/" rel="noopener ugc nofollow" target="_blank">AreWeCompressedYet.com</a>(AWCY)的编解码器的每个修订版自动生成解码器JavaScript文件，因此它们是可公开访问的。</p><h1 id="c08d" class="kt ko hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">瞧，点击我！</h1><p id="82f9" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">或者，你当然可以:</p><ol class=""><li id="df12" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated">按照这里的指示:<a class="ae ka" href="http://aomedia.org/contributor-guide/" rel="noopener ugc nofollow" target="_blank">http://aomedia.org/contributor-guide/</a>(如果你想帮忙，我推荐你这么做。)</li><li id="2b8a" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">检查与您想要分析的编码视频兼容的特定编解码器版本。</li><li id="b642" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">构建并运行假设的本地分析器。</li><li id="2f27" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated">如果您想分享一些分析结果，请截图并分享，或请同事重复步骤1至3。当然，他们不太可能这么做，因为这不仅仅是一次点击。</li></ol><blockquote class="mj"><p id="c2b5" class="mk ml hu bd mm mn mo mp mq mr ms jz ek translated">我在一家浏览器公司工作，所以我可能有偏见，但我认为这是网络最美好的一面。</p></blockquote><p id="2b99" class="pw-post-body-paragraph jc jd hu je b jf mt jh ji jj mu jl jm jn mv jp jq jr mw jt ju jv mx jx jy jz hn dt translated">Emscripten通常用于将游戏或C/C++库移植到web，这确实没有什么不同，但这是一个稍微不同的用例，我以前没有见过。我们使用Emscripten来使我们的持续集成构建工件可运行和可共享，这多酷啊？打那个方便，土著！</p><h1 id="f8ce" class="kt ko hu bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">摆弄分析器</h1><p id="6b45" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">所以让我们把比特流分析器拿出来转一转。下面，我们将比较两个比特流:<em class="kd"> crosswalk_10.ivf </em>和<em class="kd"> crosswalk_60.ivf. </em>这两个视频使用相同的编码器版本进行编码，但采用两种不同的质量级别，分别为10和60 QP(数字越低，质量越高)。分析器将块细节可视化为一组相互堆叠的层。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/247af3f2b4ee41a13ead5df05d61be01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_Wtsa-F-F-eui7MqM5rnQ.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Crosswalk, Frame 1 @ 10 QP</figcaption></figure><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/d9e4e4dcd480b9464de00230779ac1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4X9PDze8RbMccDdvkcqMRA.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Crosswalk, Frame 1 @ 60 QP</figcaption></figure><h2 id="b420" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">块分离层</h2><p id="de09" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">AV1中的最大块大小为64x64，最小块大小为4x4。(有实验扩大这个范围。)编码器使用大量因素来决定如何递归划分64×64块。但一般来说，我们可以从下面的图片中看到，细节较多的区域块大小较小，而细节较少的区域块大小较大。在较低质量的设置中，平均块大小较大，但同样的一般规则适用。块的大小很重要，因为这是编码器信号跳过信息、运动向量、预测模式、变换类型和其他类型信息的级别。块越小，编码器可以发送的细节就越多，但这也意味着编码器花费更多的比特来发送这些细节。下图显示了第一帧在两种质量水平下的块分割决策。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/eea2c759abee8c3148aa586cb2d8dbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hFoqef4iufBvk_TCPe7iw.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Block Split Decisions — Crosswalk, Frame 1 @ 10 QP</figcaption></figure><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nq"><img src="../Images/6443b40788f5b647529a615a3a2a18db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIV7hN69wGjMFA0kSXdCQg.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Block Split Decisions — Crosswalk, Frame 1 @ 60 QP</figcaption></figure><p id="ea53" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">视频的第一帧是一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Intra-frame_coding" rel="noopener ugc nofollow" target="_blank">帧内帧</a>，这意味着每个块都是从其周围的块(顶部和左侧)进行空间预测的。视频的第二帧是一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Inter_frame" rel="noopener ugc nofollow" target="_blank">帧间帧</a>，这意味着它是从它之前(或之后)的帧预测的。第二帧(下图)的块分割决策很有趣，它们只反映了两帧之间发生变化的图像区域。前景中两个人的头部向右平移，因此变化的区域在头部轮廓周围。虽然脸部向右移动，但它不需要细粒度的块，因为它可以从先前的帧中粗略预测，而头部周围的区域则不能。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/92b0582c166422b7cab9acb7e9c60864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0s54myieRG8YoNC8fQ3buw.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Block Split Decisions — Crosswalk, Frame 2 @ 60 QP</figcaption></figure><p id="a942" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">分析器可以将每个块大小覆盖的区域绘制成堆叠条形图。第一帧是这个视频序列是唯一的，因为它是一个帧内帧。它使用大致相等数量的16×16、32×32、64×64块。剩余的帧都是帧间帧，并且大部分使用64×64块。有趣的是，这里有一个重复出现的模式。在帧8、16、24等中似乎没有32×32块。我想知道为什么？这些都是分析器想要揭示的问题。这可能是编解码器的正常操作行为，也可能是一个错误。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nr"><img src="../Images/f59e14de8bac5bb7a7d12f49b8addbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsChMToefp38Gv25b8MvGQ.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Block Split Decisions — Crosswalk, 32 Frames @ 60 QP</figcaption></figure><p id="72f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在QP 10号，这看起来不同，但很相似。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nr"><img src="../Images/38c0f05cdbde0868481cf651697256fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPsqJZUEzxsm5_MyzWd9NQ.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Block Split Decisions — Crosswalk, 32 Frames @ 10 QP</figcaption></figure><h2 id="310e" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">预测模式层</h2><p id="b1e3" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">每个块都有一个预测模式。对于帧内帧，这些包括方向预测模式，它们在每个块内被绘制为细线。彩色块使用DC _预解码(粉红色)和TM _预解码(蓝色)。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/6eccf0108f8e7140ad66f41492a8f40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvtcwFtFyHmbKrpQ1E57Vg.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Intra Prediction Modes — Crosswalk, Frame 1 @ 60 QP</figcaption></figure><p id="f1f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们通过点击放大中心女士的眼睛，我们可以清楚地看到预测模式和最终由这些编码决策产生的编码伪像。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ns"><img src="../Images/ae33ea079b1dd0a175fffbad9eff7731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yk3RszN_-G-YxxpIwZzHXg.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Intra Prediction Modes — Crosswalk, Frame 1 @ 60 QP</figcaption></figure><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nt"><img src="../Images/38c3dfe17114c74e238cfafc22301303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywzSwtXKkOszDulfcSjRkA.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Intra Prediction Modes Artifacts— Crosswalk, Frame 1 @ 60 QP</figcaption></figure><p id="ad1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">帧间没有方向预测模式:白色(NEWMV)、蓝色(NEARMV)、酒红色(NEARESTMV)和紫色(ZEROMV)。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nu"><img src="../Images/67cf57957b3237bcc1b3919d182b8463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2lEd9qci2ioiEfb9Xt0oQ.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Inter Prediction Modes — Crosswalk, Frame 2 @ 60 QP</figcaption></figure><h2 id="852d" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">阻止信息详细信息</h2><p id="ed1a" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">您可以通过单击某个块来获得该块的附加信息。例如，单击上面左上方的块(0x0)会显示以下块的详细信息。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="352f" class="kn ko hu kj b fv kp kq l kr ks">Block:           0x0<br/>Block Size:      BLOCK_64X64<br/>Transform Size:  TX_32X32<br/>Transform Type:  DCT_DCT<br/>Mode:            ZEROMV<br/>Skip:            NO SKIP<br/>Motion Vectors:  0,0 | 0,0<br/>Reference Frame: ALTREF_FRAME, N/A</span></pre><p id="246a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是判断颜色含义的简便方法。</p><h2 id="f3b4" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">运动矢量层</h2><p id="3703" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">可以从其他帧预测帧间的块。每个块可以有2个运动矢量，这里显示为红线和蓝线的组合。颜色的强度代表矢量的大小。每个向量都是一个偏移量，从该偏移量可以预测块的内容。向量越长，运动越多。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/b2b1a2a7d3c1d767547e2345708f54a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wsWtAAh763fA_p4P-tzOA.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Motion Vectors — Crosswalk, Frame 2 @ 60 QP</figcaption></figure><h2 id="4a9c" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">比特会计层</h2><p id="e07c" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">在AV1中，每当从比特流中读取符号时，解码器都会跟踪用于表示该符号的比特数。位核算信息具有块级上下文，这意味着分析器可以准确计算出每种符号类型在一个块中花费了多少位。在下表中，该比特计数信息是在整个帧上汇总的:读取了458个<em class="kd"> read_mv_component </em>符号，总共537个比特，即花费在编码该帧上的所有比特的28.5%。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="98c7" class="kn ko hu kj b fv kp kq l kr ks">Symbol                    Bits     %  Samples<br/>read_mv_component          537  28.5      458<br/>decode_coefs               393  20.8      431<br/>read_inter_mode            315  16.7      538<br/>read_partition             177   9.4      269<br/>read_mv                    126   6.7       77<br/>read_ref_frames            115   6.1      261<br/>read_drl_idx                72   3.8       73<br/>read_block_reference_mode   67   3.6      230<br/>read_is_inter_block         40   2.1      236<br/>read_mb_interp_filter       28   1.5      230<br/>read_tx_type                 7   0.4        7<br/>read_intra_mode              6   0.3       12</span></pre><p id="766e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">分析器还可以显示几帧的总比特信息。这在比较两个不同的比特流时很有用。这些图表是特意布置的，以便在视频之间切换时不会移动，从而更容易发现差异。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff fg"><img src="../Images/7739415393552a0fe117cf9e2bb0ddda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy6gdRVZqb_kRfDgMEcTXA.png"/></div></div></figure><p id="1bf8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">位核算信息也可以显示为一个层。突出显示的紫色区域表示帧内的位分布。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nv"><img src="../Images/6ca90a2f11736a1f7a67d738cd27b86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2aTg1L1blDRpfeAxVnqbWQ.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Bits Layer — Crosswalk, Frame 1 @ 60 QP</figcaption></figure><p id="0ce6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">禁用图像会使bit accounting图层更加清晰可见。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/bc835e1a7087f7d47275acf76b485df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVHBVjC3LJcILWNqaYJ8wA.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Bits Layer — Crosswalk, Frame 1 @ 60 QP</figcaption></figure><p id="072e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们看第二帧，我们会看到更亮的颜色区域。默认情况下，色阶和强度是根据相对于帧中最大比特/像素数的比特/像素数计算的。<em class="kd">位刻度</em>可调；</p><ul class=""><li id="2c39" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz nx mb mc md dt translated">帧相对:默认情况下，这在分析单个帧内的位分布时很有用。</li><li id="55ac" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz nx mb mc md dt translated">视频相关:计算视频序列中所有帧的最大比特/像素数。这在分析整个序列中的位分布时非常有用。</li><li id="6ee6" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz nx mb mc md dt translated">视频相对(全部):与视频相对相同，但所有当前加载的视频序列都用于计算比例。这在比较两个序列之间的帧时很有用。</li></ul><p id="e232" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们看第二帧，我们看到它有更亮的颜色区域。这并不意味着它使用了更多的位，只是意味着帧中的大部分位花费在图像的较小区域中。</p><p id="7e77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还可以调整颜色比例，默认情况下，分析仪使用带透明度的热图比例。蓝色多为半透明，红色区域为不透明。</p><ul class=""><li id="3e25" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz nx mb mc md dt translated">单色:带透明度的单色。</li></ul><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ny"><img src="../Images/4cc3acf12ac9140e95c70f695427e992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztFrqfJFYHB_oG71y1mDzQ.png"/></div></div></figure><ul class=""><li id="9eb1" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz nx mb mc md dt translated">热点图:默认，带透明度的热点图色阶。</li></ul><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nz"><img src="../Images/24fd44de7901bb1bb8ea8e0564e8b55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85hU_S_HghobAGVT-madYA.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Bits Layer — Crosswalk, Frame 2 @ 60 QP</figcaption></figure><ul class=""><li id="542a" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz nx mb mc md dt translated">热点图(不透明):没有透明度的热点图色标。</li></ul><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nv"><img src="../Images/52c14ea87f66ee58d0170dd37025cc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ih5g5fiSdGr2LojryBzccw.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Bits Layer — Heat Map Opaque — Crosswalk, Frame 2 @ 60 QP</figcaption></figure><p id="61b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">位核算层还允许您基于符号类型进行过滤。这有助于深入了解特定符号的位分布。例如，下面我们可以看到“read_mv”(读取运动矢量)符号的位分布。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nw"><img src="../Images/08f794364576ca5d11b4b35de38af382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LOPlrB4zNjM59Df6CY2qw.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Bits Layer — Heat Map Opaque — Filtered by “read_mv” — Crosswalk, Frame 2 @ 60 QP</figcaption></figure><h2 id="ca2b" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">跳过标志层</h2><p id="8700" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">跳过标志用于指示一个块没有系数。跳过的块被绘制为蓝色，从下图中可以明显看出，跳过的块出现在图像中大多数为空的区域。如果我们还覆盖了位核算层，我们可以看到大多数位都用在了非跳过区域，这是意料之中的。</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oa"><img src="../Images/9e27108c75bcc846611102bb20d429b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VNoWqb0RioeH7Y6OUGaepA.gif"/></div></div></figure><h2 id="cf7d" class="kn ko hu bd ku nd ne nf ky ng nh ni lc jn nj nk lg jr nl nm lk jv nn no lo np dt translated">下一步是什么？</h2><p id="2016" class="pw-post-body-paragraph jc jd hu je b jf lq jh ji jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz hn dt translated">Emscripten解码器足够快，可以使用，当然它还可以更快。在高位深度模式下，编解码器使用需要在asm.js中模拟的64位数学，因为它缺少64位整数数学。这目前会影响10%到20%的性能。WebAssembly支持64位数学，一旦准备就绪，我们将切换到WebAssembly。</p><p id="ffc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以想象，AV1有大量的SIMD码路径。目前，我们禁用了分析器版本中的所有SIMD。</p><p id="3ec3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不想在你的浏览器中测量raw解码性能，你可以试试这个<a class="ae ka" href="https://beta.arewecompressedyet.com/analyzer.html?decoder=https://beta.arewecompressedyet.com/runs/av1_ref_off_intra_trellis_15f@2017-02-09T02:25:04.372Z/js/decoder.js&amp;file=https://beta.arewecompressedyet.com/runs/av1_ref_off_intra_trellis_15f@2017-02-09T02:25:04.372Z/objective-1-fast/Netflix_Crosswalk_1920x1080_60fps_8bit_420_60f.y4m-63.ivf&amp;benchmark=1" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">基准链接</strong> </a>。在我的机器上，火狐解码15帧需要512毫秒，Chrome 719和Safari 1044。</p><p id="bac5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个性能问题是YUV2RGB转换。这段代码使用浮点数学，需要优化。</p><p id="67c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想了解开放媒体联盟的进展，请看这个:</p><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="ob oc l"/></div></figure><div class="ke kf kg kh fq ab cb"><figure class="od iv oe of og oh oi paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="od iv oe of og oh oi paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="od iv oe of og oh oi paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oj ok ol"><p id="f922" class="jc jd kd je b jf jg jh ji jj jk jl jm om jo jp jq on js jt ju oo jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd kd je b jf jg jh ji jj jk jl jm om jo jp jq on js jt ju oo jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff op"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="oq oc l"/></div></figure></div></div>    
</body>
</html>