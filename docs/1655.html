<html>
<head>
<title>Yet another sbt-docker introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">又一个sbt-docker介绍</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/yet-another-sbt-docker-introduction-2d9fb99fe367?source=collection_archive---------0-----------------------#2016-11-26">https://medium.com/hackernoon/yet-another-sbt-docker-introduction-2d9fb99fe367?source=collection_archive---------0-----------------------#2016-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="c980" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，该团队一直在寻求以自动方式创建在我们的Docker环境中使用的Docker图像。</p><p id="71f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些图像目前是通过定义Dockerfile手动创建的，但这个过程与我们的构建过程完全分离，每次图像本身的内容发生变化时，它都会使我们陷入非常糟糕的境地。我们每次都需要手动更新这些文件。</p><p id="b1e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了克服这种<em class="jp">小</em>的不便，我们开始寻找替代品。当然，sbt-native-packager看起来是这项工作的合适工具，因为我们将它用于其他打包格式，所以我们开始对它进行测试。</p><p id="3800" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多关于如何使用sbt-native-packager创建Docker映像的文档，我不打算赘述。然而，在更复杂的构建中使用插件几乎没有什么发现，特别是如果我们在模块之间有依赖关系或者想要为我们项目的选定模块创建映像。</p><p id="f697" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了展示我们的需求，让我们来看一个我们可以使用的项目布局的例子。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="ce4e" class="jz ka hu jv b fv kb kc l kd ke">├── README.md<br/>├── build.sbt<br/>├── core<br/>├── json-processor<br/>├── json-sub<br/>├── project<br/>├── src<br/>├── target<br/>└── version.sbt</span></pre><p id="11d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们有一个多项目构建，包含3个项目或子模块，<strong class="it hv"><em class="jp"/></strong>，<strong class="it hv"> <em class="jp"> json处理器，json-sub </em> </strong>。内核内部是我们的主要抽象，由其他两个模块共享。核心模块没有自己运行的能力。这是另外两个项目的责任。</p><p id="9df1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看位于根文件夹中的<strong class="it hv"> <em class="jp"> build.sbt </em> </strong>文件，以便更好地了解我们的构建是如何工作的。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="e4d9" class="jz ka hu jv b fv kb kc l kd ke">name := "sample-app"<br/>version := "1.0"<br/>scalaVersion := "2.11.7"<br/><br/>lazy val root = project.in(file("."))<br/>  .aggregate(core, jsonProcessor, jsonSub)<br/>  .dependsOn(core, jsonProcessor, jsonSub)<br/>  <br/>  lazy val core = project.in(file("core"))<br/>  .settings(<br/>    name := "core"<br/>  )<br/>  <br/>  lazy val jsonProcessor = project.in(file("json-processor"))<br/>  .aggregate(core)<br/>  .dependsOn(core)<br/>  <br/><br/>lazy val jsonSub = project.in(file("json-sub"))<br/>  .aggregate(core)<br/>  .dependsOn(core)</span></pre><p id="6dcc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所看到的，没有什么新的东西，我们之前提到的相同模块正在被定义，包括对模块核心的依赖。</p><h2 id="d951" class="jz ka hu bd kf kg kh ki kj kk kl km kn jc ko kp kq jg kr ks kt jk ku kv kw kx dt translated">Sbt-Docker</h2><p id="bd39" class="pw-post-body-paragraph ir is hu it b iu ky iw ix iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo hn dt translated">以同样的方式，其他教程添加这个插件，我们只是把它和sbt-native-packager一起添加到我们的plugins.sbt文件。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="20dd" class="jz ka hu jv b fv kb kc l kd ke">addSbtPlugin("com.typesafe.sbt" % "sbt-native-packager" % "1.1.1")<br/>addSbtPlugin("se.marcuslonnberg" % "sbt-docker" % "1.4.0")</span></pre><p id="693a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们需要激活我们想要用来创建Docker图像的模块中的插件。正如您所想象的，在根项目上这样做没有什么意思，因为它只是项目组织的一个人工集合，别无其他。核心模块也是如此，它不能自己运行，所以我们不需要插件。另一方面，另外两个模块是我们感兴趣的。</p><p id="18fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">需要注意的是，在我们找到的每一篇教程/帖子/文章中，下面的键和定义都是在根项目中定义的，但是我们将把注意力集中在实际执行项目的两个模块上，以避免这种情况。</em></p><p id="f134" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了增加构建docker文件和图像的能力，我们需要在相关模块上激活sbt-docker插件。这是一个非常简单的任务。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="23d3" class="jz ka hu jv b fv kb kc l kd ke">lazy val jsonProcessor = project.in(file("json-processor"))<br/>  .aggregate(core)<br/>  .dependsOn(core)<br/>  .enablePlugins(sbtdocker.DockerPlugin, JavaServerAppPackaging)<br/><br/><br/>lazy val jsonSub = project.in(file("json-sub"))<br/>  .aggregate(core)<br/>  .dependsOn(core)<br/>  .enablePlugins(sbtdocker.DockerPlugin, JavaServerAppPackaging)</span></pre><p id="3027" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意每个模块上的<strong class="it hv"><em class="jp">enable plugins</em></strong>部分。</p><p id="76c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们应该能够为这两个模块创建Docker映像，该任务通过运行以下命令来实现:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="818e" class="jz ka hu jv b fv kb kc l kd ke">sbt "jsonProcessor/docker"</span></pre><p id="0a62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="cb22" class="jz ka hu jv b fv kb kc l kd ke">sbt "jsonSub/docker"</span></pre><p id="2f43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些命令中的任何一个都应该创建一个Docker文件，然后将映像发布到本地Docker注册表。然而，如果我们尝试运行任何最近创建的映像，我们将很快注意到模块核心上的类将找不到。</p><p id="13b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决方案很简单，但是我们花了很少的时间就想出来了。</p><p id="7d88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们需要确保核心模块包含在由<strong class="it hv"> <em class="jp"> jsonProcessor </em> </strong>和<strong class="it hv"> <em class="jp"> jsonSub </em> </strong>创建的映像上。我们需要在构建过程中定义一个依赖关系，表明我们需要核心模块包含在我们自己的(每个模块)映像中。</p><p id="8122" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个有趣的不太复杂的方法是使用<strong class="it hv"> <em class="jp"> sbt-assembly </em> </strong>插件。它将负责bundle core及其依赖项，因此我们可以在创建Docker映像之前将输出jar文件(fat jar)添加到我们自己的(模块)打包过程中。</p><p id="8ff6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这一点上，我们还需要指定一个定制的Docker映像，以便它符合我们包含核心的要求。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="dfd7" class="jz ka hu jv b fv kb kc l kd ke">lazy val dockerSettings = Seq(<br/>  docker &lt;&lt;= (docker dependsOn (AssemblyKeys.assembly in core)),<br/><br/>  dockerfile in docker := {<br/>    val artifact: File = (AssemblyKeys.assemblyOutputPath in AssemblyKeys.assembly in core).value<br/>    val artifactTargetPath = s"/app/${artifact.name}"<br/>    new Dockerfile {<br/>      from("java")<br/>      add(artifact, artifactTargetPath)<br/>      entryPoint("java", "-jar", artifactTargetPath)<br/>    }<br/>  }<br/>)</span></pre><p id="2867" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们解释一下dockerSettings是如何定义的:</p><p id="809a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们使docker任务依赖于核心模块的组装任务。这意味着在继续执行docker任务之前，需要将core组装到一个单独的jar文件中。</p><p id="137a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其次，我们已经定义了docker文件的外观。基于这个文件，docker将继续创建相应的Docker映像。</p><p id="623d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">变量工件定义了由core上的<strong class="it hv"> <em class="jp"> assembly </em> </strong>任务创建的fat jar，我们继续使用Docker add命令将这个fat jar (core)添加到我们正在构建的映像中。</p><p id="295e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该任务的结果将是一个Docker映像，其中包含核心的fat jar以及任何其他库依赖项。</p><p id="1a41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要指出我们想要图像的两个模块将使用设置(dockerSettings)。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="6262" class="jz ka hu jv b fv kb kc l kd ke">lazy val jsonProcessor = project.in(file("json-processor"))<br/>  .aggregate(core)<br/>  .dependsOn(core)<br/>  .enablePlugins(sbtdocker.DockerPlugin, JavaServerAppPackaging)<br/>  .settings(dockerSettings)<br/><br/><br/>lazy val jsonSub = project.in(file("json-sub"))<br/>  .aggregate(core)<br/>  .dependsOn(core)<br/>  .enablePlugins(sbtdocker.DockerPlugin, JavaServerAppPackaging)<br/>  .settings(dockerSettings)</span></pre><p id="82aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们已经为每个模块添加了<strong class="it hv"><em class="jp">docker settings</em></strong>。</p><p id="1794" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这之后，我们应该可以运行:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="80c9" class="jz ka hu jv b fv kb kc l kd ke">sbt "jsonProcessor/docker"</span></pre><p id="58c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="7f91" class="jz ka hu jv b fv kb kc l kd ke">sbt "jsonSub/docker"</span></pre><p id="684e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并且创建的图像应该可以使用了。</p><p id="7d8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们正在使用sbt-docker插件，但是请记住，根项目并没有激活插件，这意味着在运行docker任务时，我们总是需要指定项目名称。为了避免这种情况，我们还添加了一个sbt命令别名来简化这个过程。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="2a46" class="jz ka hu jv b fv kb kc l kd ke">addCommandAlias("dockerize", ";jsonProcessor/docker;jsonSub/docker")</span></pre><p id="c25d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加这个别名后，我们应该能够执行:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="2cc0" class="jz ka hu jv b fv kb kc l kd ke">sbt dockerize</span></pre><p id="ddad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的根项目和sbt将确切地知道该做什么。</p><p id="016b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能还想使用其他有趣的sbt-docker选项，但它们完全是可选的。我们希望为每个模块创建两个图像。一个图像的名称是模块的名称，并标记模块的版本，另一个图像具有相同的名称，但标记为<strong class="it hv"> <em class="jp"> latest。</em> </strong>如果我们计划使用<em class="jp"> docker-compose </em>这是非常有用的，因为我们不需要在每次项目版本改变时改变<em class="jp"> compose </em>文件上的标签。我们可以简单地一直使用<strong class="it hv"><em class="jp"/></strong>，并将带有版本号的图像作为我们曾经创建的所有图像的历史。</p><p id="1960" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，我们将<strong class="it hv"><em class="jp">docker settings</em></strong>更改如下:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="8585" class="jz ka hu jv b fv kb kc l kd ke">lazy val dockerSettings = Seq(<br/>  docker &lt;&lt;= (docker dependsOn (AssemblyKeys.assembly in core)),<br/><br/>  dockerfile in docker := {<br/>    val artifact: File = (AssemblyKeys.assemblyOutputPath in AssemblyKeys.assembly in core).value<br/>    <br/>    val artifactTargetPath = s"/app/${artifact.name}"<br/>    <br/>    new Dockerfile {<br/>      from("java")<br/>      add(artifact, artifactTargetPath)<br/>      entryPoint("java", "-jar", artifactTargetPath)<br/>    }<br/>  },<br/><br/>  imageNames in docker := Seq(<br/>    // Sets the latest tag<br/>    ImageName(s"${organization.value}/${name.value}:latest"),<br/><br/>    // Sets a name with a tag that contains the project version<br/>    ImageName(<br/>      repository = name.value,<br/>      tag = Some("v" + version.value)<br/>    )<br/>  )<br/>)</span></pre><p id="6cf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本上，我们只是添加了<strong class="it hv"> <em class="jp"> imageNames </em> </strong>部分的设置。同样，这将为每个项目创建两个图像，正如我们上面解释的那样。</p><p id="f04e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，如果我们的项目出了问题，我们不想构建这些图像。我们希望确保这些图像具有经过验证的工作代码。为此，我们扩展了sbt命令别名。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="7439" class="jz ka hu jv b fv kb kc l kd ke">addCommandAlias("dockerize", ";clean;compile;test;jsonProcessor/docker;jsonSub/docker")</span></pre><p id="fcea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，它将在创建图像之前进行所有必要的验证。</p><p id="b5e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过自动化这一过程，我们消除了产品化的繁琐的手动步骤。使用一个简单的命令，我们就有了完整的管道，所以我们的代码可以很容易地部署到我们的Docker环境中。我们还展示了如何创建sbt任务依赖关系，以及如何访问我们需要的每个必要部分。</p><p id="b66d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，我们正在使用sbt-docker插件以及sbt-native-packager和sbt-assembly。sbt-native-packager仍然缺少sbt-docker插件的一些功能，并且没有最新版本灵活。</p><p id="b80e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们强烈建议看一看关于这个主题的其他教程，因为它们提供了关于您可能需要的其他部件和过程的扩展信息。然而，构建依赖于项目子模块的映像是我们在其他地方没有发现的。</p><p id="717d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们希望这个小指南能帮助你走向码头工人的世界。</p><blockquote class="ld le lf"><p id="7a8a" class="ir is jp it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">黑客中午是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae lj" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lj" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jp it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">要了解更多信息，<a class="ae lj" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a> , <a class="ae lj" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书给我们发消息</a>，或者简单地，<a class="ae lj" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank">发推文/DM @HackerNoon。</a></p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lj" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lj" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>