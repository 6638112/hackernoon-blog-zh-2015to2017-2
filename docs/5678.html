<html>
<head>
<title>Converting a Buffer to JSON and Utf8 Strings in Nodejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Nodejs中将缓冲区转换为JSON和Utf8字符串</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/https-medium-com-amanhimself-converting-a-buffer-to-json-and-utf8-strings-in-nodejs-2150b1e3de57?source=collection_archive---------0-----------------------#2017-08-10">https://medium.com/hackernoon/https-medium-com-amanhimself-converting-a-buffer-to-json-and-utf8-strings-in-nodejs-2150b1e3de57?source=collection_archive---------0-----------------------#2017-08-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/291816e0eae1823940cf5dd8014035f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1878GmSC5EtcjSNHONPO3Q.jpeg"/></div></div></figure><p id="e536" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Nodejs和基于浏览器的JavaScript不同，因为Node甚至在ES6草案推出<code class="eh ka kb kc kd b">ArrayBuffer</code>之前就有处理二进制数据的方法。在节点中，<code class="eh ka kb kc kd b">Buffer</code>类是大多数I/O操作使用的主要数据结构。它是在V8堆外分配的原始二进制数据，一旦分配，就不能调整大小。</p><p id="d030" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Nodejs v6.0之前，要创建一个新的缓冲区，你可以用<code class="eh ka kb kc kd b">new</code>关键字调用构造函数:</p><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="8444" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在Node的最新和当前稳定版本中创建新的缓冲区实例，请执行以下操作:</p><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="b255" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">new Buffer()</code>构造函数已经被弃用，并被单独的<code class="eh ka kb kc kd b">Buffer.from()</code>、<code class="eh ka kb kc kd b">Buffer.alloc()</code>和<code class="eh ka kb kc kd b">Buffer.allocUnsafe()</code>方法所取代。</p><p id="cc16" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更多信息可以通过<a class="ae kk" href="https://nodejs.org/api/buffer.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">官方文档</strong> </a>阅读。</p><h1 id="5709" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将缓冲区转换为JSON</h1><p id="a1b5" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">缓冲区可以转换成JSON。</p><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="a5d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JSON指定被转换的对象类型是一个<code class="eh ka kb kc kd b">Buffer</code>，以及它的数据。</p><h1 id="b9fc" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将JSON转换为缓冲区</h1><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="ki kj l"/></div></figure><h1 id="c5aa" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将缓冲区转换为Utf-8字符串</h1><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="ki kj l"/></div></figure><p id="fc9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ka kb kc kd b">.toString()</code>不是将缓冲区转换成字符串的唯一方法。此外，默认情况下，它会转换为utf-8格式的字符串。</p><p id="c7db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将缓冲区转换为字符串的另一种方法是使用Nodejs API中的<code class="eh ka kb kc kd b">StringDecoder</code>核心模块。</p></div><div class="ab cl lo lp hc lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hn ho hp hq hr"><p id="9132" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想要收到更多像这样的文章吗？订阅我 <a class="ae kk" href="https://patreon.us17.list-manage.com/subscribe?u=ad4c168a6d5bb975f2f282d54&amp;id=39e959cecd" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">这里</strong> </a> <strong class="je hv">。有时，我会向我的订户发送“从未见过”的内容。</strong></p><p id="2c12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在Twitter上找到我:</strong></p><div class="lv lw fm fo lx ly"><a href="https://twitter.com/amanhimself" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab ej"><div class="ma ab mb cl cj mc"><h2 class="bd hv fv z el md eo ep me er et ht dt translated">阿曼·米塔尔·🖖(@阿曼本人)|推特</h2><div class="mf l"><h3 class="bd b fv z el md eo ep me er et ek translated">阿曼·米塔尔·🖖的最新推特(@阿曼本人)。# book blogger @ https://t.co/UQvyNf1OTC |开发者| #Nodejs |…</h3></div><div class="mg l"><p class="bd b gc z el md eo ep me er et ek translated">twitter.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ja ly"/></div></div></a></div><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="mn kj l"/></div></figure></div></div>    
</body>
</html>