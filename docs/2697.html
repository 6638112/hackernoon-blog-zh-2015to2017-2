<html>
<head>
<title>Observer Pattern on Swift with Signals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有信号的Swift上的观测器模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/observer-pattern-on-swift-with-signals-4699168e57ec?source=collection_archive---------5-----------------------#2017-02-12">https://medium.com/hackernoon/observer-pattern-on-swift-with-signals-4699168e57ec?source=collection_archive---------5-----------------------#2017-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7728" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">一个为你的iOS项目设计的附加和遗忘库</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/a87ad0eb1fc7deb0f5cdb7988b99258e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebBDG6xilDgwAv2tuS_O3Q.jpeg"/></div></div></figure><h1 id="853b" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">观察者模式</h1><p id="7827" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">观察者模式(有时也称为通知、广播-监听器或发布-订阅模式)是OOP语言中常见的一种通信方式，很像委托(在父子关系中很有用)和块(在并发/异步任务中很有用)。其概念是使对象能够“倾听”或“观察”来自相对不相关来源的数据。</p><p id="3442" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">思考:无线电广播。模拟信号源只是在广播中播放，不管是否有任何东西在听。接收器只是倾听，不管信号是否真的在发送。在选择这种数据通信模式时，也要考虑同样的关系。</p><h1 id="cf00" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">信号库</h1><p id="5256" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我在寻找实现观察者模式的替代方法时偶然发现了这个令人敬畏的<a class="ae lo" href="https://github.com/artman/Signals" rel="noopener ugc nofollow" target="_blank">库</a>。我特别喜欢这个，因为它实现简单。基本上是这样的:</p><ul class=""><li id="227c" class="lp lq hu kp b kq lj kt lk kw lr la ls le lt li lu lv lw lx dt translated">创建<strong class="kp hv">信号对象</strong>。</li><li id="4082" class="lp lq hu kp b kq ly kt lz kw ma la mb le mc li lu lv lw lx dt translated"><strong class="kp hv">发出物体信号的火</strong>。</li><li id="54d7" class="lp lq hu kp b kq ly kt lz kw ma la mb le mc li lu lv lw lx dt translated"><strong class="kp hv">在项目中的任何地方订阅</strong>该信号对象。</li></ul><h2 id="37d9" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated"><strong class="ak">创建信号对象</strong></h2><p id="64a1" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">初始化一个信号对象，并将广播“消息”的数据类型作为其参数</p><pre class="jk jl jm jn fq mr ms mt mu aw mv dt"><span id="b6e3" class="md jw hu ms b fv mw mx l my mz">let onData = Signal&lt;(data:NSData, error:NSError)&gt;()<br/>let onProgress = Signal&lt;Float&gt;()</span></pre><h2 id="c6da" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated"><strong class="ak">发出物体信号的<em class="na">火</em> </strong></h2><p id="8e7d" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">只需在信号对象上调用<strong class="kp hv"><em class="nb">fire(_ data:T)</em></strong>方法，它就会将您的数据广播给它的所有订户。</p><pre class="jk jl jm jn fq mr ms mt mu aw mv dt"><span id="9a30" class="md jw hu ms b fv mw mx l my mz">func receivedData(receivedData:NSData, receivedError:NSError) {<br/>    // Whenever appropriate, fire off any of the signals<br/>    self.onProgress.fire(1.0)<br/>    self.onData.fire((data:receivedData, error:receivedError))<br/>}</span></pre><h2 id="a454" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated"><strong class="ak"> <em class="na">订阅</em> </strong>该信号对象</h2><p id="74cb" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">订阅信号以数据作为参数结束。每当数据被激发时都会调用它。</p><pre class="jk jl jm jn fq mr ms mt mu aw mv dt"><span id="59ef" class="md jw hu ms b fv mw mx l my mz">onProgress.subscribe(on: self) { (progress) in<br/>    print("Loading progress: \(progress*100)%")<br/>}</span><span id="043e" class="md jw hu ms b fv nc mx l my mz">onData.subscribe(on: self) { (data, error) in<br/>    // Do something with the data<br/>}</span></pre><p id="ea3e" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">“附加并遗忘”的用法也很酷，因为它消除了观察对象生命周期的麻烦——避免了由于未绑定的侦听器绑定而导致的内存泄漏。如果您想了解更多关于信号库的信息，请点击此<a class="ae lo" href="https://github.com/artman/Signals" rel="noopener ugc nofollow" target="_blank"> github链接</a>获取其官方文档。</p></div><div class="ab cl nd ne hc nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hn ho hp hq hr"><h1 id="c3ff" class="jv jw hu bd jx jy nk ka kb kc nl ke kf ja nm jb kh jd nn je kj jg no jh kl km dt translated">练习:模拟下载器应用程序</h1><p id="8d0e" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在这个简短的教程中，让我用一个虚拟的“文件下载器”应用程序来演示这个库和<a class="ae lo" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>模式的使用。这个应用程序应该像下载管理器一样运行。核心数据和异步<a class="ae lo" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>任务本身就是巨大的话题，所以我们将跳过它们，实现一个虚拟的下载任务。我们会让他们向任何你需要的听众广播他们正在进行的任务。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff np"><img src="../Images/f541cc7ed5c75dd5c654740be89681df.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*2226NQTIsr261Onx5B6gPQ.png"/></div><figcaption class="nq nr fg fe ff ns nt bd b be z ek">Our target is literally this simple.</figcaption></figure><p id="46e8" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">为了省去创建表格视图、单元格和数据源的麻烦，我创建了一个启动项目，你可以从这里下载<a class="ae lo" href="https://github.com/raymundcat/SignalsTutorialInitial" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="6adb" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">1.项目概述</h2><p id="250f" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">好了，这是我们模板项目的一个快速概述。我们将实现一个轻量级的MVP-MVVM设计，所以期待常见的疑点(视图、模型、演示者、交互者等)。这里我们有一个简单的<strong class="kp hv"> DownloadViewController </strong>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="9205" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">简单明了。它包含我们的tableView(通过interface builder插入)及其datasource和delegate方法。</p><p id="de7b" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">它包含一组两个模型，一个<strong class="kp hv">可下载项目</strong>的数组和一个<strong class="kp hv">可下载任务</strong>的字典。这两个会自动插入到我们的tableViewCells中，以显示我们的下载对象的名称和下载状态(如果当前正在下载的话)。</p><p id="c037" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">ViewController还遵循一个<strong class="kp hv"> PresenterDelegate </strong>协议，该协议允许我们从我们的演示者那里接收数据。</p><p id="21ee" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我们的<strong class="kp hv">展示者</strong>在这里保存了视图之外的所有逻辑，实际上成为了我们的屏幕/场景/页面的逻辑标识。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="fed4" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">Presenter有三个对象来履行其职责，分别是<strong class="kp hv">可以获取的对象</strong>、<strong class="kp hv">可以下载的对象</strong>和<strong class="kp hv">可以广播的任务</strong>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="72cd" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">当然，对于我们的虚拟应用程序，所有这些都将由虚拟类来实现。</p><p id="23cc" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated"><strong class="kp hv"> CanFetchItems </strong>将由ItemStore保存，item store提供一个静态生成的对象数组。</p><p id="390e" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">CanDownloadItems 将由一个具有伪requestDownload(item:)方法的类来实现。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="e0a5" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">目前这将由我们的<strong class="kp hv"> DownloadManager </strong>持有，它将通过创建一个<strong class="kp hv"> DownloadTask </strong>来模拟下载请求——一个可以持有项目下载进度的对象。</p><p id="4d79" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">CanBroadcastTasks 将由一个持有信号对象的类来完成，特别是一个广播下载任务字典的类。</p><p id="87bc" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在我们的例子中，这将(再次)由我们的DownloadManager持有，因为这个类将是启动下载和管理它们的任务队列的类。</p><p id="7256" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">还跟着？:D现在让我们开始编码。</p><h2 id="c7f7" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">2.启动下载任务</h2><p id="b0c7" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">首先，我们将编辑我们的DownloadManager的requestDownload(item:)方法:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="af46" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我们将从该项创建一个DownloadTask，并给它一个初始进度值。</p><p id="684e" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">为了异步增加下载进度的值，我们将使用一个定时器调度函数，每1/4秒调用一次。这将使用每个增量更新我们当前的任务队列，并在任务完成时删除它。</p><h2 id="9fd2" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">3.广播任务</h2><p id="6afb" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">仍然在我们的DownloadManager中，我们将覆盖init()方法来再次启动一个计时器计划，然后它将连续广播我们的任务队列。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="a537" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">我们将自动播放，这样就不会有太多的电话骚扰我们的听众。每当有更新时，我们的广播将是一致的，而不是自动触发。</p><h2 id="be3c" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">4.听广播</h2><p id="84b3" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">现在我们已经设置好了我们的广播员，让我们回到我们的演讲者那里开始听。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nu nv l"/></div></figure><p id="bb22" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在我们的演示者的viewDidLoad()中，添加subscribe方法，以便我们可以在视图加载后立即开始监听。将回叫返回的<em class="nb">任务</em>传递给你的演示者的<em class="nb">任务</em>。然后它将被传递给你的视图的<em class="nb">任务</em>，并随后呈现给你的用户。一切都以某种被动的方式发生。</p><p id="ab9e" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">现在运行代码，您应该能够得到如下结果:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nw"><img src="../Images/fedcc47f8a90e6b371ca314ed0f63f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/1*byg2BsHk7-cfeJjJx3mRBQ.gif"/></div></figure><p id="c0b1" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">没跑？在这里拿一份最终项目<a class="ae lo" href="https://github.com/raymundcat/SignalsTutorialComplete" rel="noopener ugc nofollow" target="_blank">的拷贝，看看你是否做对了。</a></p><h2 id="0e5a" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">下一步是什么？</h2><p id="027c" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">好吧。现在您已经有了一个工作模式实现，通过添加另一个ViewController和Presenter来尝试拥有更多的观察者。这一次，用一个表格视图，试着只显示所有正在工作的下载任务<strong class="kp hv"/></p><h2 id="20fa" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">玩得开心！</h2></div><div class="ab cl nd ne hc nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hn ho hp hq hr"><h1 id="d407" class="jv jw hu bd jx jy nk ka kb kc nl ke kf ja nm jb kh jd nn je kj jg no jh kl km dt translated">在你变得太舒服之前..</h1><p id="7441" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">关于这个主题的一些评论:观察者模式是一个很好的选择，可以避免很多复杂的关系(比如太多的委托和回调)。还是可以滥用的。这里有一些<strong class="kp hv">不要在广播你的对象时记住的</strong>:</p><h2 id="2ebe" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">1.无意义的过度广播更新</h2><p id="cbad" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">我想我们可以说垃圾邮件是这种模式的一部分。不过，要注意实现的可伸缩性，以及您是在有限的硬件上运行的这一事实。</p><p id="9346" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">在我们的示例中，我将广播调用放在实际的项目更新方法之外，放在一个专用的计时器中。当你有数百个正在进行的下载时，这意味着你将每秒广播数百或数千个下载进度。</p><p id="58c6" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">这可能会由于对视图不必要的更新调用而阻塞主线程，并极大地损害应用程序的可用性。实施该设计时，<strong class="kp hv">尽量保持必要的最小速度</strong>。</p><h2 id="4756" class="md jw hu bd jx me mf mg kb mh mi mj kf kw mk ml kh la mm mn kj le mo mp kl mq dt translated">2.为了方便而破坏你的架构</h2><p id="551e" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">很诱人。你可以直接收听来自你的视图层的广播，通过你的演示者，因为你可以。这样，你就可以在演示者不知情的情况下更新你的视图。</p><p id="0d27" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">但是如果我们这样做，我们将违背MVP的概念。我们的视图开始管理自己的业务模型，我们的演示者开始失去对视图的控制。如果演示者收到更新，它不能确定它的数据是否与视图上显示的一致。</p><p id="b551" class="pw-post-body-paragraph kn ko hu kp b kq lj iv ks kt lk iy kv kw ll ky kz la lm lc ld le ln lg lh li hn dt translated">当集成这种模式时，要注意你的架构标准，不要让便利凌驾于你自己的规则之上。</p></div><div class="ab cl nd ne hc nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hn ho hp hq hr"><h1 id="185d" class="jv jw hu bd jx jy nk ka kb kc nl ke kf ja nm jb kh jd nn je kj jg no jh kl km dt translated">你大老远跑来了！</h1><blockquote class="nx"><p id="804e" class="ny nz hu bd oa ob oc od oe of og li ek translated">我希望当你打开这篇文章的时候，你已经得到了你想要的东西。如果是这样，如果你能把这个推荐给你的朋友^^，我将非常感激</p></blockquote><p id="26c6" class="pw-post-body-paragraph kn ko hu kp b kq oh iv ks kt oi iy kv kw oj ky kz la ok lc ld le ol lg lh li hn dt translated">如果您还有任何问题/反馈，请随时留言！</p><div class="jk jl jm jn fq ab cb"><figure class="om jo on oo op oq or paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="om jo on oo op oq or paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="om jo on oo op oq or paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="os ot ou"><p id="f922" class="kn ko nb kp b kq lj iv ks kt lk iy kv ov ll ky kz ow lm lc ld ox ln lg lh li hn dt translated"><a class="ae lo" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lo" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lo" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lo" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="kn ko nb kp b kq lj iv ks kt lk iy kv ov ll ky kz ow lm lc ld ox ln lg lh li hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lo" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lo" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oy"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="oz nv l"/></div></figure></div></div>    
</body>
</html>