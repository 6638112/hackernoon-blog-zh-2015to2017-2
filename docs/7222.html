<html>
<head>
<title>Optimizing Stack manipulation in Michelson</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Michelson中的堆栈操作</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/optimizing-stack-manipulation-in-michelson-31ba7ff11a3a?source=collection_archive---------16-----------------------#2017-10-20">https://medium.com/hackernoon/optimizing-stack-manipulation-in-michelson-31ba7ff11a3a?source=collection_archive---------16-----------------------#2017-10-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="42aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章描述了一个简单的编译步骤来帮助Michelson中的堆栈操作。这对于发布来说并不重要，所以我们近期不会关注它，但我确信这个问题会让一些人感到厌烦，我也很乐意看到有人接手这个问题。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/a232adfdedcfda65ba6afaf6a07e6131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxxZX8ZnglexgW_HcLd6gA.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Rubik’s cube — photo by keqs</figcaption></figure><p id="ee50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用迈克尔逊(Tezos的智能合同语言)写合同时，栈操作经常会碍事。为了获得一种感觉，看看米洛的<a class="ae jp" href="https://www.michelson-lang.com/" rel="noopener ugc nofollow" target="_blank">合同示例</a>。对程序员来说，拆分对、重组对、重新排序堆栈的元素非常耗时，并且降低了代码的可读性。</p><p id="557f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">幸运的是，有三种解决方法:</p><ol class=""><li id="bda3" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">为Emacs使用迈克尔逊IDE，可以看到它的原型<a class="ae jp" href="https://github.com/tezos/tezos/blob/master/emacs/michelson-mode.el" rel="noopener ugc nofollow" target="_blank">迈克尔逊模式</a>。这种模式为您提供了光标处堆栈状态的符号表示。随着注释的引入，这一点将会得到改善，让您可以用标识符“标记”堆栈上的值。</li><li id="3ad3" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">用编译成迈克尔逊的高级语言编写程序，比如OCamlPro的<a class="ae jp" href="https://github.com/OCamlPro/liquidity" rel="noopener ugc nofollow" target="_blank"> liquidity </a>。</li><li id="b87c" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">只对堆栈操作使用简单的编译步骤</li></ol><h1 id="fd6b" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">混乱宏</h1><p id="7beb" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">我考虑3已经有一段时间了。我称之为“混杂”指令，它是这样工作的。假设您有一个如下形式的堆栈:</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="348f" class="mc kv hu ly b fv md me l mf mg">(a,b):c:(d,(e,f))</span></pre><p id="a096" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想要一叠表格</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="41c5" class="mc kv hu ly b fv md me l mf mg">(a,f):(c,d)</span></pre><p id="678e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以写作</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="6732" class="mc kv hu ly b fv md me l mf mg">CAR; DIP { SWAP; DUP; CAR; SWAP; CDR; CDR;}; PAIR; DIP {SWAP; PAIR; PUSH;}</span></pre><p id="24d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是很明确…或者你可以写</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="0967" class="mc kv hu ly b fv md me l mf mg">JUMBLE (a,b):c:(d,(e,f)) =&gt; (a,f):(c,d)</span></pre><p id="6436" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样就清楚多了！当然，混杂操作需要编译——我们马上会谈到——但是请注意，它也可以很容易地被反编译。</p><p id="9bfc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任何形式的代码序列(DUP | DROP | SWAP | CDR | CAR | DIP | PAIR)*都可以压缩成一条混杂指令。</p><h1 id="ecaf" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">汇编混乱</h1><p id="3df2" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">写下一个正确的JUMBLE实现并不简单，但仍然相对简单。一种简单的方法是首先拉平初始堆栈和目标堆栈中的所有线对。通过重复应用DUP形式的不成对宏来展平初始堆栈对；CDR互换；汽车。然后对展平的初始堆栈进行排序，并复制变量以匹配展平的目标堆栈。然后重组这些对以匹配目标堆栈。</p><p id="37fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这不是一种非常有效的做事方式。一些对可能同时存在于初始堆栈和目标堆栈中，断开它们并重新组合它们可能是低效的。此外，在最坏的情况下，只能够交换附近条目的排序元素必然是二次的。</p><p id="d9ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以从这个正确的过程开始，通过找到共同的模式和避免不必要的堆栈操作，进行一系列的优化。</p><p id="92a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一种方法是直接搜索最优解。我已经实现了一个编译的原型，最近把它放到了Github上:<a class="ae jp" href="https://github.com/tezos/optimal_stack" rel="noopener ugc nofollow" target="_blank">https://github.com/tezos/optimal_stack</a></p><p id="2bad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个<a class="ae jp" href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener ugc nofollow" target="_blank"> A* </a>的实现，用一些启发法来缩小搜索空间。它没有经过任何方式的性能调优，因此对大型堆栈操作没有帮助，但它会发现一些重要的模式。</p><p id="fe30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我推荐在<a class="ae jp" href="https://opam.ocaml.org/blog/about-utop/" rel="noopener ugc nofollow" target="_blank"> utop </a>试试，可以这样做</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="94d6" class="mc kv hu ly b fv md me l mf mg">$ ocamlc -c *.ml *.mli<br/>utop<br/>#require "heap";;<br/>#require "optimal_stack";;<br/>open Optimal_stack;;<br/>example ()</span></pre><p id="12c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">示例优化了以下问题</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="2cbb" class="mc kv hu ly b fv md me l mf mg">JUMBLE (a, b):c =&gt; (c,a):b</span></pre><p id="f716" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以这样编程</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="686e" class="mc kv hu ly b fv md me l mf mg"><strong class="ly hv">let</strong> a <strong class="ly hv">=</strong> <strong class="ly hv">Var</strong> <strong class="ly hv">"a"</strong> <strong class="ly hv">and</strong> b <strong class="ly hv">=</strong> <strong class="ly hv">Var</strong> <strong class="ly hv">"b"</strong> <strong class="ly hv">and</strong> c <strong class="ly hv">=</strong> <strong class="ly hv">Var</strong> <strong class="ly hv">"c"</strong> <strong class="ly hv">in</strong> <br/><strong class="ly hv">let</strong> start  <strong class="ly hv">=</strong> <strong class="ly hv">Stack</strong> <strong class="ly hv">([Pair</strong> <strong class="ly hv">(</strong>a, b<strong class="ly hv">);</strong> c<strong class="ly hv">]</strong>, <strong class="ly hv">[])</strong> <strong class="ly hv">and<br/>    </strong>target <strong class="ly hv">=</strong> <strong class="ly hv">Stack</strong> <strong class="ly hv">([Pair</strong> <strong class="ly hv">(</strong>c,a<strong class="ly hv">);</strong> b<strong class="ly hv">]</strong>, <strong class="ly hv">[])</strong><br/> <strong class="ly hv">in<br/></strong>optimize start target</span></pre><p id="aa4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">给定的解决方案是</p><pre class="jr js jt ju fq lx ly lz ma aw mb dt"><span id="c913" class="mc kv hu ly b fv md me l mf mg">DUP; POP; CAR; SWAP; PAIR; PUSH; CDR; SWAP</span></pre><p id="6be5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会注意到堆栈类型是一对列表。这让我们可以将DIP操作表示为辅助堆栈上的PUSH和POP操作。除非你在一个DIP里面，否则辅助堆栈应该是空的。</p><h1 id="a61a" class="ku kv hu bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">后续步骤</h1><p id="65f9" class="pw-post-body-paragraph ir is hu it b iu ls iw ix iy lt ja jb jc lu je jf jg lv ji jj jk lw jm jn jo hn dt translated">我的重点是启动网络，我们不需要混乱。然而，我认为这很酷，我很乐意看到有人接手前期工作，使其更快，并能够解决更大的优化问题。</p><p id="20f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我对如何进一步发展的建议是:</p><ol class=""><li id="ffad" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">找到更多关于从一个堆栈移动到另一个堆栈的成本的“定理”,这些定理可以用在A*启发式算法中。</li><li id="8b5e" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">使用次优搜索。如果你能保证你的定理的误差范围，你就能保证这个解有多接近最优解。</li><li id="17c5" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">将问题代入传统的约束优化求解器。</li><li id="628f" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">不要盲目地寻找解决方案，从一个已知的解决方案开始(遵循前面概述的方法),并搜索该解决方案的可证明正确的改进。</li><li id="5cc9" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">将问题数学形式化，并通过代数推理推导出计算最优解的有效算法，这与通过群论将魔方数学化没有什么不同。我认为这有10%的机会成功，但如果成功了，那就是很高的回报了。</li></ol></div></div>    
</body>
</html>