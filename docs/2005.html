<html>
<head>
<title>C++ investigation: Arrays vs Vectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++研究:数组与向量</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/c-investigation-arrays-vs-vectors-e9ba864468b6?source=collection_archive---------1-----------------------#2017-01-01">https://medium.com/hackernoon/c-investigation-arrays-vs-vectors-e9ba864468b6?source=collection_archive---------1-----------------------#2017-01-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="0d3e" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">这些职位的目标</h1><p id="3e15" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这些帖子的目的是学习更多关于现代C++的知识，看看我一直认为理所当然的一些传统智慧。我将从构建一个矩阵库开始，并看看它会如何发展。这第一篇文章将是关于挑战一些传统的智慧，并着眼于一个潜在的实现选择。下一篇文章我将介绍如何使用一些现代C++并向库中添加概念。</p><h1 id="53bf" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">想法概述</h1><p id="5505" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">矩阵库需要做的一件事是表示不同大小的矩阵。在这种情况下，最理想的是让matrix对象得到一个动态大小的容器的支持。理想情况下，这个容器具有快速的访问时间，这意味着像链表这样的容器不适合这个场景。在常见的数据结构中，数组和哈希表都符合这个标准，它们的访问时间都是O(1)。因为可以将矩阵中的每一项映射到一个唯一的索引(它的位置)，所以数组类型的数据结构对于底层容器是有意义的。</p><p id="e094" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">编程中的一个常见建议是使用标准库。然而，C++的标准库经常因为过于通用而受到审查，并且由于这种通用性，经常会被手工制作的解决方案击败。让我们看看对于一个基本的矩阵实现，在堆上使用一个指向数组的指针和标准库的vector类型之间是否有任何区别。</p><h1 id="f6fa" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">代码</h1><p id="8ed6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这两个矩阵的代码可以在这里的<a class="ae ks" href="https://raw.githubusercontent.com/DanielJSnyder/ExploringCppMatrices/master/ArrVec/Matrix.hpp" rel="noopener ugc nofollow" target="_blank">和下面的</a>看到</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="fc7b" class="lc is hu ky b fv ld le l lf lg">#ifndef __MATRIX2D_HPP__<br/>#define __MATRIX2D_HPP__</span><span id="49e8" class="lc is hu ky b fv lh le l lf lg">#include &lt;vector&gt;<br/>template &lt;typename T&gt;<br/>class MatrixVec2D<br/>{<br/> std::vector&lt;T&gt; mat;<br/> std::size_t rows;<br/> std::size_t cols;<br/> std::size_t rcToIdx(std::size_t r, std::size_t c) const<br/> {<br/> 	return cols * r + c;<br/> }</span><span id="dd01" class="lc is hu ky b fv lh le l lf lg">public:<br/> MatrixVec2D&lt;T&gt;(std::size_t r, std::size_t c) : <br/>	mat(r*c, 0),<br/>	rows(r),<br/>	cols(c)<br/> {<br/> }</span><span id="5f65" class="lc is hu ky b fv lh le l lf lg">  MatrixVec2D&lt;T&gt;(const MatrixVec2D&lt;T&gt; &amp; m): <br/>	mat(m.mat), <br/>	rows(m.rows), <br/>	cols(m.cols)<br/> {<br/> }</span><span id="0509" class="lc is hu ky b fv lh le l lf lg"> std::size_t getNumRows() const<br/> {<br/> 	return rows;<br/> }<br/> std::size_t getNumCols() const<br/> {<br/> 	return cols;<br/> }</span><span id="00b8" class="lc is hu ky b fv lh le l lf lg"> const T&amp; at(std::size_t row, std::size_t col) const<br/> {<br/> 	return mat[rcToIdx(row, col)];<br/> }</span><span id="167b" class="lc is hu ky b fv lh le l lf lg"> T&amp; at(std::size_t row, std::size_t col)<br/> {<br/> 	return mat[rcToIdx(row, col)];<br/> }<br/>};</span><span id="6585" class="lc is hu ky b fv lh le l lf lg">template &lt;typename T&gt;<br/>class MatrixArr2D<br/>{<br/> T * mat;<br/> std::size_t rows;<br/> std::size_t cols;</span><span id="e24d" class="lc is hu ky b fv lh le l lf lg"> std::size_t rcToIdx(std::size_t r, std::size_t c) const<br/> {<br/> 	return cols * r + c;<br/> }</span><span id="3193" class="lc is hu ky b fv lh le l lf lg">public:<br/> MatrixArr2D&lt;T&gt;(std::size_t r, std::size_t c): <br/>	mat(new T[r*c]), <br/>	rows(r), <br/>	cols(c)<br/> {<br/> 	for(auto i = 0; i &lt; r*c; ++i)<br/> 	{<br/> 		mat[i] = 0;<br/> 	}<br/> }<br/> <br/>MatrixArr2D&lt;T&gt;(const MatrixArr2D&lt;T&gt; &amp; m): <br/>	mat(new T[m.rows * m.cols]), <br/>	rows(m.rows), <br/>	cols(m.cols)<br/> {<br/> 	for(auto i = 0; i &lt; rows*cols; ++i)<br/> 	{<br/> 		mat[i] = m.mat[i];<br/> 	}<br/> }<br/> <br/>~MatrixArr2D()<br/> {<br/> 	delete [] mat;<br/> }<br/> <br/> std::size_t getNumRows() const<br/> {<br/> 	return rows;<br/> }</span><span id="8fd1" class="lc is hu ky b fv lh le l lf lg"> std::size_t getNumCols() const<br/> {<br/> 	return cols;<br/> }</span><span id="e7ea" class="lc is hu ky b fv lh le l lf lg"> const T&amp; at(std::size_t row, std::size_t col) const<br/> {<br/> 	return mat[rcToIdx(row, col)];<br/> }</span><span id="1321" class="lc is hu ky b fv lh le l lf lg"> T&amp; at(std::size_t row, std::size_t col)<br/> {<br/> 	return mat[rcToIdx(row, col)];<br/> }<br/>};<br/>#endif</span></pre><p id="8f09" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这两种实现的主要区别在于底层容器。MatrixVec2D使用标准库中的向量来存储数据，而MatrixArr2D使用动态分配的数组。因为向量通常是用动态分配的数组实现的，所以在执行元素访问时，向量实现应该像另一个间接层一样。通过消除这一间接层并使用动态分配的数组，预计MatrixArr2D应该比MatrixVec2D更快地进行访问。</p><h1 id="9750" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">测试框架</h1><p id="8d44" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当测试这两个实现时，测试应该与底层实现无关。实现这一点的两种方法是通过都从派生的抽象基类或模板化函数。为了不用担心调用虚方法的开销，我们选择了模板函数方法。</p><p id="ad0b" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">为了测试，编写了一个乘法函数，如下所示。这对于方阵使用O(n)次访问，其中n是列长度。使用rand()用随机数填充两个矩阵，然后将两个矩阵相乘。</p><pre class="kt ku kv kw fq kx ky kz la aw lb dt"><span id="896c" class="lc is hu ky b fv ld le l lf lg">template &lt;template &lt;class S&gt; class T, typename S&gt;<br/>T&lt;S&gt; mult(const T&lt;S&gt;&amp; A, const T&lt;S&gt;&amp; B)<br/>{<br/>  assert(A.getNumCols() == B.getNumRows());<br/>  T&lt;S&gt; result(A.getNumRows(), B.getNumCols());<br/>  for(std::size_t r = 0; r &lt; result.getNumRows(); ++r)<br/>  {<br/>    for(std::size_t c = 0; c &lt; result.getNumCols(); ++c)<br/>    {<br/>      S sum = 0;<br/>      for(std::size_t m = 0; m &lt; A.getNumCols(); ++m)<br/>      {<br/>        sum += A.at(r,m) * B.at(m,c);<br/>      }<br/>      result.at(r,c) = sum;<br/>    }<br/>  }<br/>  return result;<br/>}</span></pre><h1 id="d4c2" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结果</h1><p id="d2d4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">结果总结在最后的图表中，可以在下表中看到。</p><figure class="kt ku kv kw fq lj fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff li"><img src="../Images/9b08e039ba8bd20c0133fa67cfcb25ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dQH6LeeG8FWmJnhArndGA.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Table summarizing the results of the programs for n=64</figcaption></figure><p id="570a" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">这些结果是在没有应用优化时预测的，但是在更高的优化级别，两者之间的差异变得可以忽略，并且在除了端点之外的点上，向量实现比数组实现更快。这表明在更高的优化级别(-对于GCC为O1，对于Clang为-O2)，编译器能够以某种方式优化掉向量导致的额外间接级别。</p><p id="37a6" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">另一个值得注意的有趣的事情是，对于整个测试，clang的-Ofast优化级别的性能比-O3优化级别的性能差。这强化了剖析的想法，不要总是相信更多的优化会使代码更快。</p><h1 id="e7cf" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="048e" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">由于在较高的优化级别上，数组支持的矩阵和矢量支持的矩阵之间没有有意义的区别，因此在这种实现中使用原始数组没有什么好处。与原始指针相比，标准库提供的向量不容易出现与内存相关的错误，如泄漏。此外，vector类提供了对许多标准库算法的访问，这些算法可能对扩展matrix类有用。</p><p id="b475" class="pw-post-body-paragraph jp jq hu jr b js kn ju jv jw ko jy jz ka kp kc kd ke kq kg kh ki kr kk kl km hn dt translated">如果您看到任何您不同意或觉得可以改进的地方，请随时给我发消息！</p><h1 id="1dd4" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">附录:测试硬件</h1><p id="a4cf" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">这些测试是在使用linux-windows子系统的微软surface book上进行的。适用于ubuntu 14.04的GCC版本6.2。Clang版本3.8.0。英特尔i5–6300 u @ 2.40 GHz 2.50 GHz，8GB内存</p><h1 id="b0ff" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">附录:结果图表</h1><div class="kt ku kv kw fq ab cb"><figure class="lu lj lv lw lx ly lz paragraph-image"><img src="../Images/57a789884e4949bffeefa921abd11d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*bfsK5e43ETyS0_15gxizug.png"/></figure><figure class="lu lj lv lw lx ly lz paragraph-image"><img src="../Images/91462c662c52592331075ffcd68333cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*5TsiHAXU0UXf_D0ktGrbIA.png"/><figcaption class="lq lr fg fe ff ls lt bd b be z ek ma di mb mc">Resuls for no optimzations and first level of optimizations</figcaption></figure></div><div class="ab cb"><figure class="lu lj lv lw lx ly lz paragraph-image"><img src="../Images/c3047c90de912b4d7a85ada9e9eca698.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*BzIglOAHQCRZ3YyFuZCjpQ.png"/></figure><figure class="lu lj lv lw lx ly lz paragraph-image"><img src="../Images/c68f899e49d1329859d1cca05ac77307.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*S_PHtQxL-gsd2fnyvhd_Jg.png"/><figcaption class="lq lr fg fe ff ls lt bd b be z ek ma di mb mc">Results for higher levels of optimizations</figcaption></figure></div><div class="ab cb"><figure class="lu lj md lw lx ly lz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lu lj md lw lx ly lz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lu lj md lw lx ly lz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="me mf mg"><p id="f922" class="jp jq mh jr b js kn ju jv jw ko jy jz mi kp kc kd mj kq kg kh mk kr kk kl km hn dt translated"><a class="ae ks" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ks" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ks" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ks" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jp jq mh jr b js kn ju jv jw ko jy jz mi kp kc kd mj kq kg kh mk kr kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ks" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ks" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kt ku kv kw fq lj fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff ml"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>