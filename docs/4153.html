<html>
<head>
<title>An edge case for cache busting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存破坏的边缘情况</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/an-edge-case-for-cache-busting-da09a7f2b5f5?source=collection_archive---------23-----------------------#2017-05-15">https://medium.com/hackernoon/an-edge-case-for-cache-busting-da09a7f2b5f5?source=collection_archive---------23-----------------------#2017-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="99de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们正在设计一个高性能的网站。我们从<a class="ae jp" href="https://stevesouders.com/" rel="noopener ugc nofollow" target="_blank"> Steve Sounders的书</a>中了解到，通过关注前端优化，我们可以获得最大的性能提升。</p><p id="cf46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了开始改善<a class="ae jp" href="https://hackernoon.com/tagged/performance" rel="noopener ugc nofollow" target="_blank">性能</a>，我们可以做以下事情:</p><ul class=""><li id="b756" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv">连接和缩小资产。通过将所有的JavaScript和CSS压缩到一个文件中，我们减少了网络流量。下载单个较大的文件也比下载几个较小的文件更快。</strong></li><li id="e4e2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv">从边缘提供内容</strong>。通过从物理上更靠近用户的服务器提供内容，我们提高了性能。我们可以使用内容交付网络(CDN)来做到这一点。</li><li id="a7ba" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv">设置缓存和压缩头</strong>。因为这些资产不会改变，所以通常只希望用户下载一次。我们可以通过将<a class="ae jp" href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" rel="noopener ugc nofollow" target="_blank">到期头</a>设置为遥远的未来(比如一年)来实现。此外，我们可以通过<a class="ae jp" href="https://developers.google.com/speed/docs/insights/EnableCompression" rel="noopener ugc nofollow" target="_blank">压缩它们</a>来减小下载大小。</li></ul><p id="749b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如今，这种架构很容易实现。像<a class="ae jp" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>或<a class="ae jp" href="http://gulpjs.com/" rel="noopener ugc nofollow" target="_blank"> gulp </a>这样的工具和来自<a class="ae jp" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> CloudFlare </a>或<a class="ae jp" href="https://aws.amazon.com/cloudfront/" rel="noopener ugc nofollow" target="_blank">亚马逊CloudFront </a>的服务将会为你处理大部分(如果不是全部)的事情。</p><p id="4fd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这种架构有一个已知的问题。从技术上讲，任何时候实现浏览器缓存都会遇到这个问题。让我们仔细看看这个问题和一个常见的解决方案。</p><h1 id="b591" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">破坏缓存</h1><blockquote class="lc ld le"><p id="fa04" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated"><em class="hu">计算机科学只有两个硬东西:缓存失效和事物命名。</em></p></blockquote><p id="e1bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这是真的，但在这种情况下，使缓存失效并不困难。由于网络的性质，我们有一个集中式缓存，而不是分布式缓存。当用户请求我们的网页时，我们有机会使缓存无效并加载新的资产。</p><p id="a2c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">常见的做法是对文件名进行版本控制或追加查询字符串参数。虽然您可以手动完成这项工作，但您用来连接和缩小文件的工具也可以做到这一点。我建议使用校验和散列，而不是版本号。</p><p id="7c14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，下一次用户请求我们的web页面时，到资产的路径将会不同，导致它们被下载和缓存。</p><h1 id="65bc" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">最大化缓存命中率</h1><blockquote class="lc ld le"><p id="b2d3" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">每个人都有一个计划，直到他们的嘴被打中</p></blockquote><p id="cf0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个架构的主要目标是让用户只下载这些资产一次。然后，在随后的访问中，这些资产将从其本地浏览器缓存中加载，从而大大提高性能。</p><p id="ecfd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个架构实现了这个目标。然而，它只是优化了<em class="lf">悲伤的路径</em>。这是当用户有一个空的或陈旧的缓存。这样做，我们实际上降低了<em class="lf">快乐之路</em>的性能。这是当用户有一个主要的缓存。</p><p id="7207" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">资产不经常变化或没有高流量的网站可能不会注意到这种权衡。因此,<em class="lf">边缘案例</em>的标题有双重含义。尽管如此，我想强调这种权衡，因为类似的文章很少这样做。</p><p id="2199" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们在这个架构下演示一个用户流:</p><ol class=""><li id="ff7e" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lj jw jx jy dt translated">用户第一次访问网站</li><li id="328f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lj jw jx jy dt translated">用户下载资产</li><li id="dac4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lj jw jx jy dt translated">用户再次访问网站</li><li id="a478" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lj jw jx jy dt translated">浏览器从缓存中加载资产</li><li id="a878" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lj jw jx jy dt translated">开发人员发布新资产</li><li id="c3f4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lj jw jx jy dt translated">用户再次访问网站</li><li id="13ee" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lj jw jx jy dt translated">用户下载资产</li></ol><p id="d2ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从表面上看，这似乎不错。用户下载了资产，并在随后的访问中使用了缓存。然后，当我们更新资产时，用户在下一次访问站点时下载了新的资产。</p><p id="74cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题出在最后一步。用户再次下载<em class="lf">所有</em>资产。虽然这些资产确实是新的，但很可能只有一小部分文件发生了变化。因此，让一个用户用一个准备好的缓存再次下载<em class="lf">所有的东西</em>并不是最优的。</p><p id="9733" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们以压缩的JavaScript文件为例。虽然定制JavaScript代码可能会频繁更改，但大多数非定制代码不会。这</p><p id="8a25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们将我们的资产分成两个文件，我们可以进一步优化这个架构，同时不会增加很多额外的请求。因此，对于JavaScript文件，我们将不常更改的代码压缩到一个文件中，将频繁更改的代码压缩到另一个文件中。我们可以对我们的CSS做同样的事情。</p><p id="d65f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果我们播放相同的用户流，最后一步变成了<em class="lf">用户仅下载</em> <strong class="it hv"> <em class="lf">已更改的</em> </strong> <em class="lf">资产</em>。这要优化得多。尤其是高流量网站。如果我们考虑为一个每月有100万次点击的站点分离出jQuery(最小化40KB ),那就是40GB的节省。虽然这在现代互联网时代听起来可能不太像，但这可能是你的CDN计划层之间的差异。</p></div><div class="ab cl lk ll hc lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hn ho hp hq hr"><p id="cb90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lf">最初发表于</em><a class="ae jp" href="https://jason.pureconcepts.net/2017/05/edge-case-cache-busting/" rel="noopener ugc nofollow" target="_blank"><em class="lf">【jason.pureconcepts.net】</em></a><em class="lf">。</em></p><blockquote class="lc ld le"><p id="5794" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is lf it b iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lr ls lt lu fq lv"><div class="bz el l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>