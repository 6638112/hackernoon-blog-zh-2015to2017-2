<html>
<head>
<title>Front End Workflow: Re-envisioned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端工作流程:重新设想</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/front-end-workflow-re-envisioned-43f800bb01bd?source=collection_archive---------5-----------------------#2017-11-11">https://medium.com/hackernoon/front-end-workflow-re-envisioned-43f800bb01bd?source=collection_archive---------5-----------------------#2017-11-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="ef0a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">由于前端开发包含了以组件为中心的设计，因此构建用户界面的方法也应该如此。</p></blockquote><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/efc483579431a3f2c55036fdde3322ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BRRLYEB6vFB8JYe0FGWlCQ.gif"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Developing with Angular Playground</figcaption></figure><p id="fb01" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt km translated">两年前,<a class="ae kv" href="https://reactjs.org/docs/thinking-in-react.html" rel="noopener ugc nofollow" target="_blank">思考改变了我设计用户界面的方式。说得难听点，它使得UI设计对程序员更友好:将UI分成几个部分，将每个部分作为无状态标记单独处理，只有在整个结构完成后才添加逻辑。基于组件的设计的工作流程是如此的直观，以至于我经常忘记我正在使用它。</a></p><p id="a58f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">不幸的是，在现实世界中规划应用程序并不像文章中描述的那么简单。项目经理的需求、愿望和目标永远在变化。设计用户界面结构(首先是逻辑，然后是逻辑)有一个主要的痛点:直到开发结束，代码都没有最低限度的可行产品来演示。这意味着范围或项目方向的变化会极大地影响开发工作。如果应用程序的功能由于不同的方向而发生巨大的变化，那么花时间构建应用程序是没有意义的。</p><p id="80e6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">开发团队如何在保持基于组件的设计优势的同时，提供快速、有意义的产品迭代？解决方案是以与《反应中的思考》中描述的相反的方向进行开发:</p><ol class=""><li id="7360" class="kw kx hu ix b iy iz jc jd kj ky kk kz kl la js lb lc ld le dt translated">从绘制相同的用户界面地图开始，将每个部分划分为各自的组件。</li><li id="37ff" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js lb lc ld le dt translated">与其定义整体结构和开发无状态的重现，不如从最小的部分开始向上移动。选择应用程序中最不复杂的组件，用模拟数据完成它，从而完成结构的一部分。</li><li id="9fec" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js lb lc ld le dt translated">继续在整个用户界面中向上移动，逐渐实现更复杂的组件。这些复杂的组件将使用先前创建的较小组件。</li></ol><p id="678e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">这个工作流程解决了可演示产品的问题。每个组件完成后，开发团队就可以展示一个全功能的应用程序，即使它是用假数据连接起来的。这种方法的问题在于开发过程:如果不定义应用程序结构的其余部分，孤立地开发一个单独的组件通常是不容易的。然而，有一些很棒的工具可以帮助我们解决这个问题，并允许轻松有效地独立开发组件。</p><h1 id="fb70" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">沙盒组件</h1><p id="ac97" class="pw-post-body-paragraph iu iv hu ix b iy mi ja jb jc mj je jf kj mk ji jj kk ml jm jn kl mm jq jr js hn dt translated">当开发一个完整的应用程序时，组件应该被单独地分阶段和迭代。这种技术被称为沙箱，或者为一段数据提供一个完整且隔离的环境。对于现代前端框架，两个开源的沙盒工具是<a class="ae kv" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank">故事书</a>和<a class="ae kv" href="http://www.angularplayground.it/" rel="noopener ugc nofollow" target="_blank">角游乐场</a>。</p><p id="db38" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated"><strong class="ix hv">免责声明:</strong>我是角操场的投稿人。因此，我将把重点放在Playground上，因为它是我最熟悉的工具。</p><p id="1760" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">Playground获取已经写在应用程序代码中的组件，并将它们安装在“场景”中。每个场景都是围绕您的组件构建的轻量级包装，仅包含您在该场景中定义的标记。应用程序的所有其他依赖项都被忽略了。这意味着您可以在没有整个应用程序的情况下迭代和测试组件。这也意味着您可以用您选择的任何数据和依赖项来存放组件，并完全控制它们提供的数据。</p><p id="7aa1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">因为组件是与应用程序本身的场景分开创建的，所以Playground只需获取现有的组件，并将其引导到自己的环境中。这意味着你需要在一个组件上工作的唯一代码是它的依赖列表和它的选择器，例如<code class="eh mn mo mp mq b">&lt;my-component&gt;</code>。代码库中的更改会立即反映在使用该组件的所有场景中。</p><p id="cef2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">这些特性在构造组件时为开发人员提供了很大的力量。</p><h1 id="1132" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">搭建操场</h1><p id="9615" class="pw-post-body-paragraph iu iv hu ix b iy mi ja jb jc mj je jf kj mk ji jj kk ml jm jn kl mm jq jr js hn dt translated">Angular Playground在应用程序现有的Angular环境下工作，所以没有太多样板文件需要设置。由于大多数Angular开发使用<a class="ae kv" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>，我将在假设您的Angular应用程序(CLI <code class="eh mn mo mp mq b">1.2.0+</code>)已经搭建好的情况下开始。为了让Playground与您的应用程序挂钩，只需要添加一些额外的元数据文件。</p><p id="df1c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">如果您想跳过配置，直接进入我的示例项目，<a class="ae kv" href="https://github.com/mgmarlow/playground-demo" rel="noopener ugc nofollow" target="_blank">这里是代码</a>。</p><p id="918b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">由于Playground使用<a class="ae kv" href="https://blogs.msdn.microsoft.com/typescript/2017/06/27/announcing-typescript-2-4/" rel="noopener ugc nofollow" target="_blank">动态导入表达式</a>来确保沙盒组件真正以独立的块加载，所以要确保项目中的TypeScript版本是<code class="eh mn mo mp mq b">2.4.0+</code>。我们还需要更改一个<code class="eh mn mo mp mq b">tsconfig.app.json</code>设置，将模块输出设置为<code class="eh mn mo mp mq b">esnext</code>。</p><pre class="ju jv jw jx fq mr mq ms mt aw mu dt"><span id="b78d" class="mv ll hu mq b fv mw mx l my mz">npm install --save-dev angular-playground typescript@2.4.2</span></pre><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="0382" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">下一步是添加Playground用来引导应用程序组件的代码。在<code class="eh mn mo mp mq b">src/</code>目录下，添加以下文件:<code class="eh mn mo mp mq b">main.playground.ts</code></p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="9207" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">注意，我的Angular apps在这里的名字是<code class="eh mn mo mp mq b">ng-app</code>。</p><p id="aac0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">接下来是Angular CLI将用来编译Playground项目的元数据文件。向<code class="eh mn mo mp mq b">angular-cli.json</code>添加一个额外的<code class="eh mn mo mp mq b">app</code>条目:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="d15c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">现在，对于您的项目根中的特定于操场的配置，<code class="eh mn mo mp mq b">my-app-dir/angular-playground.json</code>。Playground CLI工具将在构建沙箱时使用该文件。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="5535" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">最后，向项目的<code class="eh mn mo mp mq b">package.json</code>添加一个npm脚本，以使用Playground CLI。</p><pre class="ju jv jw jx fq mr mq ms mt aw mu dt"><span id="c6ba" class="mv ll hu mq b fv mw mx l my mz">"scripts": {<br/>  "playground": "angular-playground"<br/>}</span></pre><p id="5d5a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">用<code class="eh mn mo mp mq b">npm run playground</code>运行Angular Playground，导航到localhost:4201。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff nc"><img src="../Images/8bdaabd8aad2fa9bba1a47523a3f195f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rj73Tigcphk9VdqdSKCVg.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Playground running in localhost:4201/</figcaption></figure><h1 id="6ca2" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">创建沙箱</h1><p id="786c" class="pw-post-body-paragraph iu iv hu ix b iy mi ja jb jc mj je jf kj mk ji jj kk ml jm jn kl mm jq jr js hn dt translated">随着操场的建立和运行，我们准备为我们的组件创建沙箱。下面是一个简单的组件，我们将为其构建场景:</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="60f3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">如果用户是可编辑的，该组件允许用户编辑与简档相关联的特定字段。注意，这个组件接受一个输入(<code class="eh mn mo mp mq b">@Input() user</code>)并在其模板中包含一个单独的组件，<code class="eh mn mo mp mq b">&lt;app-details-form&gt; </code> ( <a class="ae kv" href="https://github.com/mgmarlow/playground-demo/blob/master/src/app/user-profile/details-form/details-form.component.ts" rel="noopener ugc nofollow" target="_blank">源</a>)。</p><p id="b872" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">我们用操场API函数<code class="eh mn mo mp mq b">sandboxOf()</code>创建沙箱。这个函数的工作方式很像Angular的<code class="eh mn mo mp mq b">NgModule</code>装饰器，因为我们用它来描述特定组件所需的依赖关系。由于<code class="eh mn mo mp mq b">InfoSummaryComponent</code>包含了来自<code class="eh mn mo mp mq b">ReactiveFormsModule</code>的控件，我们需要将该模块作为导入引入。此外，由于<code class="eh mn mo mp mq b">DetailsFormComponent</code>是在<code class="eh mn mo mp mq b">InfoSummaryComponent</code>的模板中使用的，Playground需要知道它，这样它才能正确地呈现整个组件。</p><p id="05b1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">假设我们想要设置这个组件的两种不同状态:一种是默认的可编辑用户，另一种是不可编辑用户。我们可以通过为组件设置两个不同的“场景”来做到这一点，每个场景为<code class="eh mn mo mp mq b">@Input() user</code>变量提供一个不同的用户。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff nd"><img src="../Images/d60f9f31ee25757ccd83a082f3515b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*t9ZYoJDsOUA7j-dqz1sTOA.gif"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">Sandboxing the info-summary component</figcaption></figure><p id="8f7c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">下面是各自的沙箱文件(<code class="eh mn mo mp mq b">info-summary.component.sandbox.ts</code>)，它将组件分为两种场景，“默认”和“不可编辑用户”。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="na nb l"/></div></figure><p id="da9b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">首先，我们用<code class="eh mn mo mp mq b">sandboxOf(InfoSummaryComponent, { /** … **/})</code>实例化组件及其依赖项。然后，我们使用<code class="eh mn mo mp mq b">.add()</code>方法向沙箱中添加不同的场景，设置我们的环境。每个场景都有一个名称和一组选项。</p><p id="47c3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">options对象唯一需要的属性是<code class="eh mn mo mp mq b">template</code>，它接收将在页面上呈现的模板。在这个简单的例子中，我们只是用不同类型的用户数据来存放我们关心的组件。最后，<code class="eh mn mo mp mq b">context </code>是一个可选属性，它向组件的上下文提供数据。这里我们用它来提供两个不同的用户，一个可编辑，一个不可编辑。</p><p id="6a43" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf kj jh ji jj kk jl jm jn kl jp jq jr js hn dt translated">有了这个沙盒结构，我们可以为我们开发的组件准备许多不同的场景，对它们的所有数据需求和使用进行建模。随着组件复杂性的增加，沙箱提供了一个很好的环境来帮助关注重要的细节。</p><h1 id="53f0" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">包扎</h1><p id="3a1b" class="pw-post-body-paragraph iu iv hu ix b iy mi ja jb jc mj je jf kj mk ji jj kk ml jm jn kl mm jq jr js hn dt translated">虽然这是一个简单的例子，但我希望它展示了沙箱组件的强大。Angular Playground支持所有不同类型的组件设置，允许您提供注入的服务，设置场景特定的样式，并轻松地对<code class="eh mn mo mp mq b">@Input()</code>和<code class="eh mn mo mp mq b">@Output()</code>进行建模。还有很多好处可以帮助您的开发团队，这些好处不在本文的讨论范围之内。以下是几个例子:</p><ul class=""><li id="2131" class="kw kx hu ix b iy iz jc jd kj ky kk kz kl la js ne lc ld le dt translated"><strong class="ix hv">测试变化和边缘案例</strong>:通过为一个组件创建许多场景，每个变化都很容易测试和设计。最糟糕的bug是那些很难重现的bug，因为它需要大量的数据和交互来结束损坏的组件状态。沙盒允许开发人员模拟出破坏组件的数据，并立即开始迭代解决方案，从而缓解了这个问题。</li><li id="da0f" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js ne lc ld le dt translated"><strong class="ix hv">单一用途的组件</strong>:通过沙盒工作流的进展鼓励开发人员构建可以在场景中轻松建模的组件。这意味着当组件启动时，它通常会被分解成更小的部分，每一部分都更加独特。当组件完成时，只要遵循预期的工作流，结果通常是简单的、可重用的代码块。</li><li id="e52e" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js ne lc ld le dt translated"><strong class="ix hv">更简单的单元测试</strong>:沙箱被设计成类似于单元测试文件，使得在组件开发之后(或期间)立即过渡到测试变得容易。</li><li id="5d1d" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js ne lc ld le dt translated"><strong class="ix hv">交互式文档</strong>:游乐场场景可以嵌入到文档页面中，允许它们利用交互式组件。因为这些场景是从源代码中提取的，所以当组件发生变化时，它们会立即更新。</li></ul><h1 id="c37b" class="lk ll hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">资源</h1><ul class=""><li id="95c5" class="kw kx hu ix b iy mi jc mj kj nf kk ng kl nh js ne lc ld le dt translated"><a class="ae kv" href="https://reactjs.org/docs/thinking-in-react.html" rel="noopener ugc nofollow" target="_blank">思考中做出反应</a></li><li id="63bb" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js ne lc ld le dt translated"><a class="ae kv" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank">故事书</a> ( <a class="ae kv" href="https://github.com/storybooks/storybook" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="a62d" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js ne lc ld le dt translated"><a class="ae kv" href="http://www.angularplayground.it/" rel="noopener ugc nofollow" target="_blank">角游乐场</a> ( <a class="ae kv" href="https://github.com/SoCreate/angular-playground" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="3e3d" class="kw kx hu ix b iy lf jc lg kj lh kk li kl lj js ne lc ld le dt translated"><a class="ae kv" href="https://github.com/mgmarlow/playground-demo" rel="noopener ugc nofollow" target="_blank">文章源代码</a></li></ul></div></div>    
</body>
</html>