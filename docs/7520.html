<html>
<head>
<title>Join the Club: Type-safe Joins with Esqueleto</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加入俱乐部:类型安全加入Esqueleto</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/join-the-club-type-safe-joins-with-esqueleto-db7ef2ea7b14?source=collection_archive---------29-----------------------#2017-10-30">https://medium.com/hackernoon/join-the-club-type-safe-joins-with-esqueleto-db7ef2ea7b14?source=collection_archive---------29-----------------------#2017-10-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a577" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的四篇左右的文章中，我们对Haskell库进行了一次真正的旋风之旅。我们使用Persistent创建了一个数据库模式，并使用它以类型安全的方式编写基本的SQL查询。我们看到了如何通过带有Servant的API来公开这个数据库。我们还使用Redis为该服务器添加了一些缓存。最后，我们围绕这个API的行为编写了一些基本测试。通过使用Docker，我们使这些测试具有可重复性。</p><p id="b40f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我们将通过向模式中添加另一种类型来回顾整个过程。我们将为一个<code class="eh jp jq jr js b">Article</code>类型编写一些新的端点，并用一个外键将这个类型链接到我们现有的<code class="eh jp jq jr js b">User</code>类型。然后我们再学一个库:<a class="ae jt" href="https://hackage.haskell.org/package/esqueleto" rel="noopener ugc nofollow" target="_blank"> Esqueleto </a>。Esqueleto允许我们编写类型安全的SQL连接，从而改进了Persistent。</p><p id="a127" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与之前的文章一样，本系列的<a class="ae jt" href="https://github.com/jhb563/ProdHaskellSeries" rel="noopener ugc nofollow" target="_blank"> Github库</a>上有一个特定的分支。去那里看一看<a class="ae jt" href="https://github.com/jhb563/ProdHaskellSeries/tree/esqueleto" rel="noopener ugc nofollow" target="_blank"> esqueleto分支</a>以查看本文的完整代码。</p><h1 id="0dbb" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">将文章添加到我们的架构中</h1><p id="aab9" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">所以我们的第一步是用我们的<code class="eh jp jq jr js b">Article</code>类型扩展我们的模式。我们将为每篇文章指定一个标题、一些正文和发布时间的时间戳。我们将看到的一个新特性是，我们将添加一个外键来引用撰写文章的用户。下面是它在我们的模式中的样子:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="1ebf" class="lf jv hu js b fv lg lh l li lj">PTH.share [PTH.mkPersist PTH.sqlSettings, PTH.mkMigrate "migrateAll"] [PTH.persistLowerCase|<br/> User sql=users<br/>   ...</span><span id="dee5" class="lf jv hu js b fv lk lh l li lj"> Article sql=articles<br/>   title Text<br/>   body Text<br/>   publishedTime UTCTime<br/>   authorId UserId<br/>   UniqueTitle title<br/>   deriving Show Read Eq<br/>|]</span></pre><p id="18a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在模式中使用<code class="eh jp jq jr js b">UserId</code>作为类型。当我们在数据库中创建表时，这将创建一个外键列。实际上，当我们在Haskell中使用它时，我们的文章类型将如下所示:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="1bbf" class="lf jv hu js b fv lg lh l li lj">data Article = Article<br/> { articleTitle :: Text<br/> , articleBody :: Text<br/> , articlePublishedTime :: UTCTime<br/> , articleAuthorId :: Key User<br/> }</span></pre><p id="cc6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着它不引用整个用户。相反，它包含该用户的SQL键。因为我们将把文章添加到我们的API中，所以我们也需要添加ToJSON和FromJSON实例。这些也是非常基本的，所以如果你好奇的话，你可以在这里查看它们。如果你对JSON实例感兴趣，看看这篇文章。</p><h1 id="85c9" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">添加端点</h1><p id="4643" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">现在我们将扩展我们的API来公开关于这些文章的某些信息。首先，我们将编写几个基本的端点来创建一篇文章，然后通过它的ID获取它:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="15b3" class="lf jv hu js b fv lg lh l li lj">type FullAPI = <br/>      "users" :&gt; Capture "userid" Int64 :&gt; Get '[JSON] User<br/> :&lt;|&gt; "users" :&gt; ReqBody '[JSON] User :&gt; Post '[JSON] Int64<br/> :&lt;|&gt; "articles" :&gt; Capture "articleid" Int64 :&gt; Get '[JSON] Article<br/> :&lt;|&gt; "articles" :&gt; ReqBody '[JSON] Article :&gt; Post '[JSON] Int64</span></pre><p id="a7cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们将编写几个特殊的端点。第一个将用户ID作为一个键，然后它将提供用户写的所有不同的文章。我们将这个端点称为<code class="eh jp jq jr js b">/articles/author/:authorid</code>。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="5b73" class="lf jv hu js b fv lg lh l li lj">...<br/> :&lt;|&gt; "articles" :&gt; "author" :&gt; Capture "authorid" Int64 :&gt; Get '[JSON] [Entity Article]</span></pre><p id="67cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的最后一个端点将获取最新的文章，最多10篇。这将不带任何参数，并在<code class="eh jp jq jr js b">/articles/recent</code>路线上运行。它将返回用户及其文章的元组，两者都是实体。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="ea0b" class="lf jv hu js b fv lg lh l li lj">…<br/> :&lt;|&gt; "articles" :&gt; "recent" :&gt; Get '[JSON] [(Entity User, Entity Article)]</span></pre><h1 id="f8cf" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">添加查询(使用Esqueleto！)</h1><p id="f7b9" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">在我们实际实现这些端点之前，我们需要为它们编写基本的查询。为了创建一篇文章，我们使用标准的持久化<code class="eh jp jq jr js b">insert</code>函数:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="1f40" class="lf jv hu js b fv lg lh l li lj">createArticlePG :: PGInfo -&gt; Article -&gt; IO Int64<br/>createArticlePG connString article = fromSqlKey &lt;$&gt; runAction connString (insert article)</span></pre><p id="6f73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以对基本的获取端点做同样的事情。但是为了开始学习语法，我们将使用Esqueleto编写这个基本查询。对于Persistent，我们使用列表参数来指定不同的过滤器和SQL操作。相反，Esqueleto使用一个特殊的单子来组成不同类型的查询。esqueleto select调用的一般格式如下所示:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="b552" class="lf jv hu js b fv lg lh l li lj">fetchArticlePG :: PGInfo -&gt; Int64 -&gt; IO (Maybe Article)<br/>fetchArticlePG connString aid = runAction connString selectAction<br/> where<br/>   selectAction :: SqlPersistT (LoggingT IO) (Maybe Article)<br/>   selectAction = select . from $ \articles -&gt; do<br/>     ...</span></pre><p id="6f22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用<code class="eh jp jq jr js b">select . from</code>，然后提供一个接受表变量的函数。我们的第一个查询将只引用单个表，但我们稍后将看到一个连接。为了完成这个函数，我们将提供一元动作，它将合并查询的不同部分。</p><p id="2fe4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以从这个单子中调用的最基本的过滤函数是<code class="eh jp jq jr js b">where_</code>。这允许我们在查询中提供一个条件，就像我们在Persistent中使用过滤器列表一样。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="ab25" class="lf jv hu js b fv lg lh l li lj">selectAction :: SqlPersistT (LoggingT IO) (Maybe Article)<br/>   selectAction = select . from $ \articles -&gt; do<br/>     where_ (articles ^. ArticleId ==. val (toSqlKey aid))</span></pre><p id="a505" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们使用<code class="eh jp jq jr js b">ArticleId</code>透镜来指定我们要过滤的表的值。然后我们指定要比较的值。我们不仅需要将我们的<code class="eh jp jq jr js b">Int64</code>提升到一个<code class="eh jp jq jr js b">SqlKey</code>，而且我们还需要使用<code class="eh jp jq jr js b">val</code>函数提升那个值。</p><p id="aea2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是现在我们已经添加了这个条件，我们需要做的就是返回表变量。现在，<code class="eh jp jq jr js b">select</code>在一个列表中返回我们的结果。但是因为我们是通过ID搜索，所以我们只期望一个结果。我们将使用<code class="eh jp jq jr js b">listToMaybe</code>,所以我们只返回head元素，如果它存在的话。我们还将再次使用<code class="eh jp jq jr js b">entityVal</code>来打开文章的实体。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="b369" class="lf jv hu js b fv lg lh l li lj">selectAction :: SqlPersistT (LoggingT IO) (Maybe Article)<br/>   selectAction = ((fmap entityVal) . listToMaybe) &lt;$&gt; (select . from $ \articles -&gt; do<br/>     where_ (articles ^. ArticleId ==. val (toSqlKey aid))<br/>     return articles)</span></pre><p id="9410" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们应该知道了足够多的信息，可以写出下一个查询。它将获取特定用户写的所有文章。我们仍然会在<code class="eh jp jq jr js b">articles</code>表上进行查询。但是现在我们检查文章ID，我们将确保<code class="eh jp jq jr js b">ArticleAuthorId</code>等于某个值。同样，我们将把我们的<code class="eh jp jq jr js b">Int64</code>用户密钥提升到一个<code class="eh jp jq jr js b">SqlKey</code>中，然后再与<code class="eh jp jq jr js b">val</code>在“SQL-land”中进行比较。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="1a0d" class="lf jv hu js b fv lg lh l li lj">fetchArticleByAuthorPG :: PGInfo -&gt; Int64 -&gt; IO [Entity Article]<br/>fetchArticleByAuthorPG connString uid = runAction connString fetchAction<br/> where<br/>   fetchAction :: SqlPersistT (LoggingT IO) [Entity Article]<br/>   fetchAction = select . from $ \articles -&gt; do<br/>     where_ (articles ^. ArticleAuthorId ==. val (toSqlKey uid))<br/>     return articles</span></pre><p id="343a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是完整的查询！这次我们想要一个实体列表，所以我们去掉了<code class="eh jp jq jr js b">listToMaybe</code>和<code class="eh jp jq jr js b">entityVal</code>。</p><p id="20f7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们编写最后一个查询，在这里我们将找到最近的10篇文章，不管是谁写的。我们将在每篇文章中包含作者。所以我们返回这些不同实体元组的列表。这个查询将涉及我们的第一个连接。我们将使用<code class="eh jp jq jr js b">InnerJoin</code>构造函数将<code class="eh jp jq jr js b">users</code>表和<code class="eh jp jq jr js b">articles</code>表组合起来，而不是使用单个表进行查询。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="32a8" class="lf jv hu js b fv lg lh l li lj">fetchRecentArticlesPG :: PGInfo -&gt; IO [(Entity User, Entity Article)]<br/>fetchRecentArticlesPG connString = runAction connString fetchAction<br/> where<br/>   fetchAction :: SqlPersistT (LoggingT IO) [(Entity User, Entity Article)]<br/>   fetchAction = select . from $ \(users `InnerJoin` articles) -&gt; do</span></pre><p id="cdac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们要将两个表连接在一起，所以我们需要指定要连接的列。为此，我们将使用<code class="eh jp jq jr js b">on</code>函数:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="df73" class="lf jv hu js b fv lg lh l li lj">fetchAction :: SqlPersistT (LoggingT IO) [(Entity User, Entity Article)]<br/>   fetchAction = select . from $ \(users `InnerJoin` articles) -&gt; do<br/>     on (users ^. UserId ==. articles ^. ArticleAuthorId)</span></pre><p id="7c4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们将使用<code class="eh jp jq jr js b">orderBy</code>根据文章的时间戳对文章进行排序。最新的文章应该排在最前面，所以我们将使用降序排列。然后我们用<code class="eh jp jq jr js b">limit</code>函数限制结果的数量。最后，我们将返回用户和文章，我们就完成了！</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="9224" class="lf jv hu js b fv lg lh l li lj">fetchAction :: SqlPersistT (LoggingT IO) [(Entity User, Entity Article)]<br/>   fetchAction = select . from $ \(users `InnerJoin` articles) -&gt; do<br/>     on (users ^. UserId ==. articles ^. ArticleAuthorId)<br/>     orderBy [desc (articles ^. ArticlePublishedTime)]<br/>     limit 10<br/>     return (users, articles)</span></pre><h1 id="4bf4" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">缓存不同类型的项目</h1><p id="e50d" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">我们不会深入研究在Redis中缓存文章的细节，但是有一个潜在的问题我们想观察一下。目前，我们在Redis存储中使用用户的SQL键作为他们的键。例如，字符串“15”可以是这样一个键。如果我们试图天真地在我们的文章中使用同样的想法，我们将会有冲突！试图存储ID为“15”的文章将会覆盖包含该用户的条目！</p><p id="6055" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是解决这个问题的方法很简单。我们要做的是，对于用户的密钥，我们将使字符串类似于<code class="eh jp jq jr js b">users:15</code>。那么对于我们的文章，我们将它的键设为<code class="eh jp jq jr js b">articles:15</code>。只要我们以正确的方式反序列化它，就不会有问题。</p><h1 id="188a" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">填写服务器处理程序</h1><p id="f969" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">既然我们已经编写了数据库查询函数，那么填充服务器处理程序就非常简单了。其中大多数都归结为遵循我们已经为其他两个端点设置的模式:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="4333" class="lf jv hu js b fv lg lh l li lj">fetchArticleHandler :: PGInfo -&gt; Int64 -&gt; Handler Article<br/>fetchArticleHandler pgInfo aid = do<br/> maybeArticle &lt;- liftIO $ fetchArticlePG pgInfo aid<br/> case maybeArticle of<br/>   Just article -&gt; return article<br/>   Nothing -&gt; Handler $ (throwE $ err401 { errBody = "Could not find article with that ID" })</span><span id="1ac1" class="lf jv hu js b fv lk lh l li lj">createArticleHandler :: PGInfo -&gt; Article -&gt; Handler Int64<br/>createArticleHandler pgInfo article = liftIO $ createArticlePG pgInfo article</span><span id="77b7" class="lf jv hu js b fv lk lh l li lj">fetchArticlesByAuthorHandler :: PGInfo -&gt; Int64 -&gt; Handler [Entity Article]<br/>fetchArticlesByAuthorHandler pgInfo uid = liftIO $ fetchArticlesByAuthorPG pgInfo uid</span><span id="0281" class="lf jv hu js b fv lk lh l li lj">fetchRecentArticlesHandler :: PGInfo -&gt; Handler [(Entity User, Entity Article)]<br/>fetchRecentArticlesHandler pgInfo = liftIO $ fetchRecentArticlesPG pgInfo</span></pre><p id="2834" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们将像这样完成我们的<code class="eh jp jq jr js b">Server FullAPI</code>:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="7488" class="lf jv hu js b fv lg lh l li lj">fullAPIServer :: PGInfo -&gt; RedisInfo -&gt; Server FullAPI<br/>fullAPIServer pgInfo redisInfo =<br/> (fetchUsersHandler pgInfo redisInfo) :&lt;|&gt;<br/> (createUserHandler pgInfo) :&lt;|&gt;<br/> (fetchArticleHandler pgInfo) :&lt;|&gt;<br/> (createArticleHandler pgInfo) :&lt;|&gt;<br/> (fetchArticlesByAuthorHandler pgInfo) :&lt;|&gt;<br/> (fetchRecentArticlesHandler pgInfo)</span></pre><p id="16b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以做的一件有趣的事情是，我们可以将我们的API类型组成不同的部分。例如，我们可以将我们的<code class="eh jp jq jr js b">FullAPI</code>分成两部分。首先，我们可以从以前的<code class="eh jp jq jr js b">UsersAPI</code>型，然后我们可以为<code class="eh jp jq jr js b">ArticlesAPI</code>做一个新的类型。我们可以用e-plus操作符将它们粘合在一起，就像我们可以粘合单独的端点一样！</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="411c" class="lf jv hu js b fv lg lh l li lj">type FullAPI = UsersAPI :&lt;|&gt; ArticlesAPI</span><span id="f4d4" class="lf jv hu js b fv lk lh l li lj">type UsersAPI =<br/>      "users" :&gt; Capture "userid" Int64 :&gt; Get '[JSON] User<br/> :&lt;|&gt; "users" :&gt; ReqBody '[JSON] User :&gt; Post '[JSON] Int64</span><span id="ba3b" class="lf jv hu js b fv lk lh l li lj">type ArticlesAPI =<br/> "articles" :&gt; Capture "articleid" Int64 :&gt; Get '[JSON] Article<br/> :&lt;|&gt; "articles" :&gt; ReqBody '[JSON] Article :&gt; Post '[JSON] Int64<br/> :&lt;|&gt; "articles" :&gt; "author" :&gt; Capture "authorid" Int64 :&gt; Get '[JSON] [Entity Article]<br/> :&lt;|&gt; "articles" :&gt; "recent" :&gt; Get '[JSON] [(Entity User, Entity Article)]</span></pre><p id="df5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们这样做，我们将不得不在结合端点的其他区域进行类似的调整。例如，我们需要更新服务器处理程序连接和客户端功能。</p><h1 id="dfb9" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">写作测试</h1><p id="7939" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">因为我们已经有了一些用户测试，所以在API的文章部分进行一些测试也是不错的。我们将围绕创建一篇文章并获取它添加一个简单的测试。然后，我们将为“按作者分类的文章”和“最近的文章”端点各添加一个测试。</p><p id="6b44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以填充这个部分的一个棘手的部分是我们需要制作test <code class="eh jp jq jr js b">Article</code>对象。但是我们需要它们是用户ID上的函数。这是因为当我们将用户插入数据库时，我们无法先验地知道我们将得到什么SQL IDs。但是我们可以填写所有其他字段，包括发布时间。这里有一个例子，但是我们总共有18篇不同的“测试”文章。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="3ec5" class="lf jv hu js b fv lg lh l li lj">testArticle1 :: Int64 -&gt; Article<br/>testArticle1 uid = Article<br/> { articleTitle = "First post"<br/> , articleBody = "A great description of our first blog post body."<br/> , articlePublishedTime = posixSecondsToUTCTime 1498914000<br/> , articleAuthorId = toSqlKey uid<br/> }</span><span id="cb10" class="lf jv hu js b fv lk lh l li lj">-- 17 other articles and some test users as well<br/>…</span></pre><p id="4019" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的before钩子将在数据库中创建所有这些不同的实体。一般来说，我们将直接进入数据库，而不调用API本身。像我们的用户测试一样，我们想要删除我们创建的任何数据库项。让我们编写一个通用的后挂钩，它将获取用户id和文章id，并将它们从数据库中删除:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="7ad0" class="lf jv hu js b fv lg lh l li lj">deleteArtifacts :: PGInfo -&gt; RedisInfo -&gt; [Int64] -&gt; [Int64] -&gt; IO ()<br/>deleteArtifacts pgInfo redisInfo users articles = do<br/> void $ forM articles $ \a -&gt; deleteArticlePG pgInfo a<br/> void $ forM users $ \u -&gt; do<br/>   deleteUserCache redisInfo u<br/>   deleteUserPG pgInfo u</span></pre><p id="4f78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">重要的是，我们首先删除文章！如果我们先删除用户，我们会遇到外键异常！</p><p id="0853" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的基本创建和获取测试看起来很像前面的用户测试。我们测试响应是否成功，新文章是否如我们预期的那样存在于Postgres中。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="a23d" class="lf jv hu js b fv lg lh l li lj">beforeHook4 :: ClientEnv -&gt; PGInfo -&gt; IO (Bool, Bool, Int64, Int64)<br/>beforeHook4 clientEnv pgInfo = do<br/> userKey &lt;- createUserPG pgInfo testUser2<br/> articleKeyEither &lt;- runClientM (createArticleClient (testArticle1 userKey)) clientEnv<br/> case articleKeyEither of<br/>   Left _ -&gt; error "DB call failed on spec 4!"<br/>   Right articleKey -&gt; do<br/>     fetchResult &lt;- runClientM (fetchArticleClient articleKey) clientEnv<br/>     let callSucceeds = isRight fetchResult<br/>     articleInPG &lt;- isJust &lt;$&gt; fetchArticlePG pgInfo articleKey<br/>     return (callSucceeds, articleInPG, userKey, articleKey)</span><span id="c82b" class="lf jv hu js b fv lk lh l li lj">spec4 :: SpecWith (Bool, Bool, Int64, Int64)<br/>spec4 = describe "After creating and fetching an article" $ do<br/> it "The fetch call should return a result" $ \(succeeds, _, _, _) -&gt; succeeds `shouldBe` True<br/> it "The article should be in Postgres" $ \(_, inPG, _, _) -&gt; inPG `shouldBe` True</span><span id="d579" class="lf jv hu js b fv lk lh l li lj">afterHook4 :: PGInfo -&gt; RedisInfo -&gt; (Bool, Bool, Int64, Int64) -&gt; IO ()<br/>afterHook4 pgInfo redisInfo (_, _, uid, aid) = deleteArtifacts pgInfo redisInfo [uid] [aid]</span></pre><p id="b9a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的下一个测试将创建两个不同的用户和几篇不同的文章。我们将首先插入用户并获取他们的密钥。然后我们可以使用这些密钥来创建文章。我们在这个测试中创建了五篇文章。我们将三个分配给第一个用户，两个分配给第二个用户:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="a2f3" class="lf jv hu js b fv lg lh l li lj">beforeHook5 :: ClientEnv -&gt; PGInfo -&gt; IO ([Article], [Article], Int64, Int64, [Int64])<br/>beforeHook5 clientEnv pgInfo = do<br/> uid1 &lt;- createUserPG pgInfo testUser3<br/> uid2 &lt;- createUserPG pgInfo testUser4<br/> articleIds &lt;- mapM (createArticlePG pgInfo)<br/>   [ testArticle2 uid1, testArticle3 uid1, testArticle4 uid1<br/>   , testArticle5 uid2, testArticle6 uid2 ]<br/> ...</span></pre><p id="4edf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们想测试一下，当我们调用按用户排序的文章端点时，我们只得到正确的文章。我们将返回每组文章、用户id和文章id列表:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="defa" class="lf jv hu js b fv lg lh l li lj">beforeHook5 :: ClientEnv -&gt; PGInfo -&gt; IO ([Article], [Article], Int64, Int64, [Int64])<br/>beforeHook5 clientEnv pgInfo = do<br/> uid1 &lt;- createUserPG pgInfo testUser3<br/> uid2 &lt;- createUserPG pgInfo testUser4<br/> articleIds &lt;- mapM (createArticlePG pgInfo)<br/>   [ testArticle2 uid1, testArticle3 uid1, testArticle4 uid1<br/>   , testArticle5 uid2, testArticle6 uid2 ]<br/> firstArticles &lt;- runClientM (fetchArticlesByAuthorClient uid1) clientEnv<br/> secondArticles &lt;- runClientM (fetchArticlesByAuthorClient uid2) clientEnv<br/> case (firstArticles, secondArticles) of<br/>   (Right as1, Right as2) -&gt; return (entityVal &lt;$&gt; as1, entityVal &lt;$&gt; as2, uid1, uid2, articleIds)<br/>   _ -&gt; error "Spec 5 failed!"</span></pre><p id="94ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以编写断言本身，测试返回的文章是否是我们所期望的。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="f3d0" class="lf jv hu js b fv lg lh l li lj">spec5 :: SpecWith ([Article], [Article], Int64, Int64, [Int64])<br/>spec5 = describe "When fetching articles by author ID" $ do<br/> it "Fetching by the first author should return 3 articles" $ \(firstArticles, _, uid1, _, _) -&gt;<br/>   firstArticles `shouldBe` [testArticle2 uid1, testArticle3 uid1, testArticle4 uid1]<br/> it "Fetching by the second author should return 2 articles" $ \(_, secondArticles, _, uid2, _) -&gt;<br/>   secondArticles `shouldBe` [testArticle5 uid2, testArticle6 uid2]</span></pre><p id="066f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们会用一个类似的after钩子跟踪它。</p><p id="1b68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终测试将遵循类似的模式。只是这一次，我们将检查用户和文章的组合。我们还将确保包含12篇不同的文章，以测试API将结果限制为10个。</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="d4da" class="lf jv hu js b fv lg lh l li lj">beforeHook6 :: ClientEnv -&gt; PGInfo -&gt; IO ([(User, Article)], Int64, Int64, [Int64])<br/>beforeHook6 clientEnv pgInfo = do<br/> uid1 &lt;- createUserPG pgInfo testUser5<br/> uid2 &lt;- createUserPG pgInfo testUser6<br/> articleIds &lt;- mapM (createArticlePG pgInfo)<br/>   [ testArticle7 uid1, testArticle8 uid1, testArticle9 uid1, testArticle10 uid2<br/>   , testArticle11 uid2, testArticle12 uid1, testArticle13 uid2, testArticle14 uid2<br/>   , testArticle15 uid2, testArticle16 uid1, testArticle17 uid1, testArticle18 uid2<br/>   ]<br/> recentArticles &lt;- runClientM fetchRecentArticlesClient clientEnv<br/> case recentArticles of<br/>   Right as -&gt; return (entityValTuple &lt;$&gt; as, uid1, uid2, articleIds)<br/>   _ -&gt; error "Spec 6 failed!"<br/> where<br/>   entityValTuple (Entity _ u, Entity _ a) = (u, a)</span></pre><p id="0071" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的spec将检查我们得到的10篇文章的列表是否符合我们的期望。然后，像往常一样，我们从数据库中删除实体。</p><p id="0530" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们用其他测试来调用这些测试，用小包装器来调用钩子:</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="8af8" class="lf jv hu js b fv lg lh l li lj">main :: IO ()<br/>main = do<br/> ...<br/> hspec $ before (beforeHook4 clientEnv pgInfo) $ after (afterHook4 pgInfo redisInfo) $ spec4<br/> hspec $ before (beforeHook5 clientEnv pgInfo) $ after (afterHook5 pgInfo redisInfo) $ spec5<br/> hspec $ before (beforeHook6 clientEnv pgInfo) $ after (afterHook6 pgInfo redisInfo) $ spec6</span></pre><p id="be92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们完成了！测试通过了！</p><pre class="kx ky kz la fq lb js lc ld aw le dt"><span id="8a72" class="lf jv hu js b fv lg lh l li lj">…<br/>After creating and fetching an article<br/> The fetch call should return a result<br/> The article should be in Postgres</span><span id="fed7" class="lf jv hu js b fv lk lh l li lj">Finished in 0.1698 seconds<br/>2 examples, 0 failures</span><span id="e11b" class="lf jv hu js b fv lk lh l li lj">When fetching articles by author ID<br/> Fetching by the first author should return 3 articles<br/> Fetching by the second author should return 2 articles</span><span id="cd9c" class="lf jv hu js b fv lk lh l li lj">Finished in 0.4944 seconds<br/>2 examples, 0 failures</span><span id="a6b7" class="lf jv hu js b fv lk lh l li lj">When fetching recent articles<br/> Should fetch exactly the 10 most recent articles</span></pre><h1 id="38ff" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h1><p id="e681" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">这就完成了我们对有用的产品库的概述。在这些文章中，我们从头开始构建了一个小的web API。我们已经看到了一些令人敬畏的抽象，它们让我们只处理项目中最重要的部分。Persistent和Servant都为我们生成了许多额外的样板文件。本文展示了Esqueleto库在允许我们进行类型安全连接方面的强大功能。我们还看到了向我们的API添加新类型和端点的端到端过程。</p><p id="d0bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在接下来的几周里，我们将会处理更多在构建这类系统时可能出现的问题。特别是，我们将看到如何在Servant之上使用可选的单子。这样做可能会提出我们将要探讨的某些问题。我们将通过探索封装效果的不同方法来达到高潮。</p><p id="5a20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一定要看看我们的<a class="ae jt" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Haskell Stack迷你课程！</a>！它将向您展示如何使用Stack，这样您就可以集成本系列中的所有库了！</p><p id="009a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你是Haskell新手，还没有准备好，看看我们的<a class="ae jt" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>并开始行动吧！</p></div></div>    
</body>
</html>