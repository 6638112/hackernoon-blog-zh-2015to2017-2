<html>
<head>
<title>Extending Python 3 in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中扩展Python 3</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/extending-python-3-in-go-78f3a69552ac?source=collection_archive---------2-----------------------#2017-12-30">https://medium.com/hackernoon/extending-python-3-in-go-78f3a69552ac?source=collection_archive---------2-----------------------#2017-12-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4f44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几十年来，扩展Python一直是该平台的核心功能，Python运行时提供了一个“C API”，它是一组头文件和核心类型，用于用C编写扩展并将它们编译成Python模块。</p><p id="8c22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，你<strong class="it hv"> <em class="jp">真的</em> </strong>要用C写Python的扩展吗？为什么我们不能用更现代的方法，比如围棋。</p><h1 id="a11c" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">背景调查——以前没人做过吗？</h1><p id="641c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我发现了一些2015年写的旧文章，要么是为<strong class="it hv"> Python 2 </strong>写的，要么是为Go 1.5写的。自那以后，围棋发生了很大的变化，所以很难找到一些最新的和维护良好的东西。</p><p id="32e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kt" href="https://blog.filippo.io/building-python-modules-with-go-1-5/" rel="noopener ugc nofollow" target="_blank">本文</a>是针对Go 1.5的，混合使用了C宏和Go。另外，<code class="eh ku kv kw kx b">cgo</code>而不是原生Go函数的一个很大的限制是它不支持variadics(即<code class="eh ku kv kw kx b">*args</code>)，这在大多数Python模块中都是一个大问题。</p><p id="5fb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kt" href="https://github.com/go-python/gopy" rel="noopener ugc nofollow" target="_blank"> gopy </a>，一个从Go包自动创建模块的工具。乍看之下，这似乎会导致问题，因为它在编译时需要一个特定的<a class="ae kt" href="https://github.com/go-python/gopy/issues/83" rel="noopener ugc nofollow" target="_blank">标志，而这在生产中是不推荐的。还有，它</a><a class="ae kt" href="https://github.com/go-python/gopy/blob/master/gen.go#L81" rel="noopener ugc nofollow" target="_blank">不支持Python 3 </a>。</p><p id="3cef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kt" href="https://github.com/sbinet/go-python" rel="noopener ugc nofollow" target="_blank"> go-python看起来</a>像是一个不错的候选，但它是为Python 2绑定而写的。</p><p id="2dd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">py 看起来很不完整，只覆盖了一些基本的Python API。</p><p id="3afd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现的其他例子<a class="ae kt" href="https://dustymabe.com/2016/09/13/sharing-a-go-library-to-python-using-cffi/" rel="noopener ugc nofollow" target="_blank">使用了cffi包</a>，所以代码的消耗感觉不像一个模块，它只是一种调用Go编译方法的方式。它也没有本机绑定。</p><h1 id="ce18" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">在Go中构建共享库</h1><p id="af8c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Go SDK中，有一个叫做<code class="eh ku kv kw kx b">cgo</code>的工具集，这是一种导入C头文件和访问外部库中描述的类型和方法的方法。</p><p id="0803" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它还使您能够从Go构建共享库，并从Go lang中的方法自动构建C头文件</p><p id="53d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">拿着这个非常简单的Go包</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="109a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后运行<code class="eh ku kv kw kx b">go build -buildmode=c-shared -o sum.so sum.go</code></p><p id="3558" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会看到3个文件，<code class="eh ku kv kw kx b">sum.go sum.h and sum.so</code>。sum.so文件是编译后的二进制文件，<code class="eh ku kv kw kx b">sum.h</code>是描述二进制文件中定义了哪些方法和类型的文件头。</p><p id="29ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要通过用C编写模块来扩展Python，你需要从导入<code class="eh ku kv kw kx b">Python.h</code>开始，并用C描述一组boiler plate代码。因为我们是在Go中，这变得更加棘手，正如之前的作者所展示的，需要在Go中使用C宏，或者大量的Go代码来包装方法。</p><p id="c532" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是吗？</p><h1 id="634d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">派宾根</h1><p id="bdae" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Filippo原始文章中的许多工作都是关于绑定的。绑定就像使用HTTP REST API一样，您需要知道方法的名称、预期的参数和响应。</p><p id="6af7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kt" href="http://pybindgen.readthedocs.io/en/latest/tutorial/#supported-python-versions." rel="noopener ugc nofollow" target="_blank"> PyBindGen </a>，一个已经存在很久的工具，可以基于C或C++头文件创建2或3的Python模块绑定。您可以将源代码包含在您的包中，甚至可以编译并嵌入到setuptools中。</p><p id="9fc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如前所示，我们已经从Go编译器中构建了头文件。</p><p id="5758" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过编写一个简单的<code class="eh ku kv kw kx b">build.py</code>脚本，导入PyBindGen，我们可以让它加载<code class="eh ku kv kw kx b">sum.h</code>。将其作为导入添加，并在模块中描述一个名为Sum的方法，该方法接受两个整数a和b，并返回一个整数值。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="20f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调用build.py会用C写一个Python模块到屏幕上。一旦这个模块被编译，它将导入Go编译的二进制文件并作为一个本地Python模块提供。通过管道将其传递给<code class="eh ku kv kw kx b">sum.c</code>来创建源代码，将我们的二进制文件包装到Python模块中。先确定你<code class="eh ku kv kw kx b">pip install pybindgen</code>。</p><p id="3059" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ku kv kw kx b">python build.py &gt; sum.c</code></p><h1 id="5374" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">编译模块</h1><p id="5a12" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">海湾合作委员会需要比联合国大门更多的旗帜，所以让我们开始收集吧。我们的Python运行时的路径和选项，在我的例子中是Python 3.6，可以通过运行<code class="eh ku kv kw kx b">python3.6-config --cflags</code>和<code class="eh ku kv kw kx b">python3.6-config --ldflags</code>获取</p><p id="b216" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后调用GCC编译器编译C代码，由PyBindGen生成，它导入sum.h中定义的方法，这些方法又在sum.so二进制中。</p><p id="624c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ku kv kw kx b">gcc sum.c -dynamiclib sum.so -o testsum.so {python-flags}</code></p><h1 id="5061" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">导入和测试模块</h1><p id="513a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们的模块有一个方法，它将两个数相加并返回一个数。简单明了。</p><p id="d7ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ku kv kw kx b">(env) bash-3.2$ python<br/>Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)<br/>[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin<br/>Type “help”, “copyright”, “credits” or “license” for more information.<br/>&gt;&gt;&gt; import testsum<br/>&gt;&gt;&gt; testsum.Sum(1,2)<br/>3</code></p><p id="c5f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有用！还有，<code class="eh ku kv kw kx b">help(testsum.Sum)</code>其实是告诉你参数是什么，是什么类型。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lf"><img src="../Images/35c0a170354c298cac1298a9ffe77080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVwCTSv9iSmHKegx5UL5Eg.png"/></div></div></figure><h1 id="ea53" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">更复杂一点的东西</h1><p id="d9f3" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">所有的在线教程都展示了一个基本的求和或算术函数，这并不是很有用。如果你阅读了C-API文档，你会发现你可以访问常见的Python类型。</p><p id="9872" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ku kv kw kx b">cgo</code>的一个很大的限制是不能从函数中导出像<code class="eh ku kv kw kx b">struct</code>这样的复杂类型，但是谁在乎呢！我们有Python令人敬畏的PyObject类型，它可以做几乎任何事情..</p><p id="cedc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一次我们将编写一个返回Python字典的函数。返回类型仍然是PyObject指针，这是一个总括。这一次我们需要导入类型，以便Go编译器知道它们是什么，这是来自pkg-config(我们前面在Gcc中提到过)。此外，因为<a class="ae kt" href="https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_FromString" rel="noopener ugc nofollow" target="_blank"> PyUnicode_FromString </a>需要一个<code class="eh ku kv kw kx b">char *</code>，所以我们使用一个函数来转换Go字符串。</p><p id="9c40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将创建一个<code class="eh ku kv kw kx b">str</code> Unicode类型的键和值(毕竟这是Python 3)。</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="7563" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们测试一下，我们需要用新方法更新build.py文件并重新构建库</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="1754" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经指定被调用的不拥有返回值(即内存)，但是关于如何处理垃圾收集的更多信息可以在<a class="ae kt" href="http://pybindgen.readthedocs.io/en/latest/tutorial/#memory-management-for-pointer-types" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="f2a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ku kv kw kx b">(env) bash-3.2$ python<br/>Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)<br/>[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin<br/>Type “help”, “copyright”, “credits” or “license” for more information.<br/>&gt;&gt;&gt; import testsum<br/>&gt;&gt;&gt; testsum.NewDictionary()<br/>{‘key’: ‘value’}</code></p><p id="44b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，为什么不看看Go中有哪些API和包可以移植到Python呢？</p><p id="90d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你能用Goroutines实现什么？Python 3.6中的异步API呢？我认为这是可能的</p><h1 id="5d19" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">性能呢？</h1><p id="fa53" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我把这个简单的函数放在一起乘2个矩阵</p><figure class="ky kz la lb fq lc"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="62f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有趣的是，Go/CGo中的<strong class="it hv"> <em class="jp">比纯CPython中的</em> </strong>要慢。</p><figure class="ky kz la lb fq lc fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lm"><img src="../Images/c6c82a2bb87e4d1f170db7429efc3d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sR0rME2Liqv_UtH56RcwaQ.png"/></div></div></figure><p id="864c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我可能犯了一些明显的错误。我也开始了解C-API，所以这段代码需要类型检查和空引用检查，但是这个想法是存在的。</p><h2 id="0f18" class="ln jr hu bd js lo lp lq jw lr ls lt ka jc lu lv ke jg lw lx ki jk ly lz km ma dt translated">还卡在Python 2上？</h2><p id="a870" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><a class="ae kt" href="https://www.pluralsight.com/courses/python-2-to-python-3" rel="noopener ugc nofollow" target="_blank">查看我在Pluralsight上关于从Python 2迁移到3的新课程。</a></p></div></div>    
</body>
</html>