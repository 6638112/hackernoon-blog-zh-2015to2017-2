<html>
<head>
<title>TODO Application using Finch and TwitterServer.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Finch和TwitterServer的TODO应用程序。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/todo-application-using-finch-and-twitterserver-52fa08318c87?source=collection_archive---------17-----------------------#2017-10-19">https://medium.com/hackernoon/todo-application-using-finch-and-twitterserver-52fa08318c87?source=collection_archive---------17-----------------------#2017-10-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/32c15ff90c51ae18a9636ffcb6d62001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sc4_HKbPGBDMlgnccFcsQ@2x.png"/></div></div></figure><p id="96bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上周<em class="ka"> ScalaTimes </em>展示了<a class="ae kb" href="https://scalatimes.us2.list-manage.com/track/click?u=ba834c562d82d9aba5eaf90ba&amp;id=11f7ed2c12&amp;e=c3a14fe549" rel="noopener ugc nofollow" target="_blank"> <em class="ka">使用Akka HTTP和Slick </em> </a> <strong class="je hv">，</strong>创建一个TODO应用程序，这鼓励我在Finch中做同样类型的入门教程。</p><p id="2b56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Finch是一个由主要在Twitter上工作的人编写的项目，它是一个类型级孵化器。我最喜欢Finch的一点是它的简单性，因为它使用了纯函数式编程结构和高效的底层库。</p><p id="95a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就我个人而言，我在各种小型项目中使用过Finch，也曾在非常严肃的项目/环境中使用过一次。我总是发现它非常容易和简单，即使它是一个非常有能力的库。</p><p id="f853" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">雀快，只看<a class="ae kb" href="http://vkostyukov.net/posts/how-fast-is-finch/" rel="noopener ugc nofollow" target="_blank"> <em class="ka">雀有多快？</em> </a> <em class="ka"> </em>你会发现，它是用Scala写的第二快的HTTP库。</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="0a86" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们关注如何使用Finch创建一个简单的Rest API。</p><p id="32ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的<em class="ka"> build.sbt </em>文件如下所示:</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="8c31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们只是为JSON序列化/反序列化添加了Finch库和喀尔刻。</p><p id="e65a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们需要创建我们要服务的第一个端点。</p><p id="4a9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从非常简单的东西开始，然后从那里发展。首先，我们可以定义一个<code class="eh kp kq kr ks b">hello</code>端点。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="5822" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我看来，<code class="eh kp kq kr ks b">Endpoint</code>是Finch中最重要的构造。</p><p id="5390" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kp kq kr ks b">Endpoint</code>背后思想是它代表了如下一系列的转换:</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="3439" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们得到一个<code class="eh kp kq kr ks b">Request</code>，并将其转换成某种类型的<code class="eh kp kq kr ks b">A</code>。然后，我们将一些业务逻辑应用到异步事务的输入中，以完成到期望的<code class="eh kp kq kr ks b">Response</code>的另一个转换。</p><p id="6a1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的例子中，我们的<code class="eh kp kq kr ks b">Endpoint</code>是一个URL为<code class="eh kp kq kr ks b">hello</code>的<code class="eh kp kq kr ks b">get</code>，要应用的业务逻辑只是返回<code class="eh kp kq kr ks b">hello to you!</code>。</p><p id="3c55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们需要运行服务器并公开要使用的<code class="eh kp kq kr ks b">hello</code>。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="9945" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们只创建了一个我们可以执行的应用程序，我们创建了一个<code class="eh kp kq kr ks b">server</code>来连接到<code class="eh kp kq kr ks b">localhost:8080</code>，然后它作为一个欺骗服务来服务于<code class="eh kp kq kr ks b">hello</code> <code class="eh kp kq kr ks b">Endpoint</code>。</p><p id="05ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过执行<code class="eh kp kq kr ks b">sbt run</code>或<code class="eh kp kq kr ks b">java -jar &lt;the application.jar&gt;</code>来运行应用程序。一旦运行，我们可以使用我们的终端发送一个请求到端点:<code class="eh kp kq kr ks b">http localhost:8080/hello</code>，我们将返回:</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h2 id="53d8" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">我们的存储服务</h2><p id="0f26" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">在本例中，我们将使用一个可以通过多种方式实现的存储抽象，特别是我们可以创建一个与内存数据存储区对话的存储抽象。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="9409" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kp kq kr ks b">Item</code>是我们将向API发送和接收的对象类型，存储负责保存/检索它们。</p><p id="268c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的内存实现就是这么简单。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h1 id="f0fc" class="lt ku hu bd kv lu lv lw kz lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj dt translated">定义待办事项端点</h1><h2 id="ef03" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">1.开始行动</h2><p id="4af0" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">我们的第一个端点将是<code class="eh kp kq kr ks b">todos</code>，它检索存储中所有可用的项目。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="5150" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以看到这是多么简单！它只是做一个<code class="eh kp kq kr ks b">storage.getAll </code>调用。该端点将响应我们服务器中的<code class="eh kp kq kr ks b">GET /todos</code> URL。</p><h2 id="d4b6" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">2.待办事项后</h2><p id="f82f" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">现在我们可以定义一个新的端点来添加将在<code class="eh kp kq kr ks b">POST /todo</code>响应的todos</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="25bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个看起来更有趣一点。因为它是一个<code class="eh kp kq kr ks b">POST</code>,我们需要从消息体中提取出<code class="eh kp kq kr ks b">Item</code>。然而，有一个问题，没有<code class="eh kp kq kr ks b">UUID</code>就不能创建<code class="eh kp kq kr ks b">Item</code>，这就是<code class="eh kp kq kr ks b">postTodo</code>函数的作用。换句话说，我们从<code class="eh kp kq kr ks b">POST</code>消息体中提取出<code class="eh kp kq kr ks b">taskName</code>，并用它和一个随机的<code class="eh kp kq kr ks b">UUID</code>创建一个<code class="eh kp kq kr ks b">Item</code>对象。</p><p id="94c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个想法是，如果没有在请求中发送的id，您不需要有不同的<code class="eh kp kq kr ks b">Item</code>模型。</p><p id="0a8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后函数<code class="eh kp kq kr ks b">storage.add(item)</code>并不真正关心id，它只是向存储器中添加一个新的<code class="eh kp kq kr ks b">Item</code>并返回最近创建的那个(它有自己的新id)。</p><p id="d28f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦添加了<code class="eh kp kq kr ks b">Item</code>，我们就返回最近创建的那个。</p><p id="a7b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以从我们的终端测试它，方法是</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="31c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它返回</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><h2 id="c191" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">3.GET -TODO</h2><p id="d062" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">检索特定的<code class="eh kp kq kr ks b">Item</code>是一项简单的任务。我们只需要id，然后我们可以请求<code class="eh kp kq kr ks b">storage</code>为我们获取它。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="be56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过以下方式进行测试:</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="d816" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它返回与我们之前插入的相同的todo。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="3a70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，如果项目不在存储器中，<code class="eh kp kq kr ks b">.fold</code>将向客户端返回<code class="eh kp kq kr ks b">NotFound</code> HTTP消息。</p><h2 id="c166" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">4.删除-待办事项</h2><p id="c628" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">用同样的方法我们可以做<code class="eh kp kq kr ks b">deleteTodo</code></p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="723d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们寻找具有给定id的<code class="eh kp kq kr ks b">Item</code>。如果它存在，我们就删除它。然后我们使用<code class="eh kp kq kr ks b">.fold</code>相应地返回。</p><h2 id="0bc6" class="kt ku hu bd kv kw kx ky kz la lb lc ld jn le lf lg jr lh li lj jv lk ll lm ln dt translated">TodoService</h2><p id="7f15" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">整个<code class="eh kp kq kr ks b">TodoService</code>代码如下所示。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><h1 id="e668" class="lt ku hu bd kv lu lv lw kz lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj dt translated">把所有东西放在一起</h1><p id="0c5a" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">我们需要从我们的应用程序中暴露所有这些<code class="eh kp kq kr ks b">Endpoint</code>。芬奇使用无形状来创作<code class="eh kp kq kr ks b">Endpoint</code> s，仔细观察<code class="eh kp kq kr ks b">TodoService</code>我们可以看到这种创作发生在<code class="eh kp kq kr ks b">TodoService.api</code>中。</p><p id="40b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何重写我们的应用程序来服务于<code class="eh kp kq kr ks b">TodoService</code>。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="ca23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意<code class="eh kp kq kr ks b">.api</code>是每个单个<code class="eh kp kq kr ks b">Endpoint</code>的组合。</p><figure class="kj kk kl km fq iv"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="b4e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个组合是使用<em class="ka"> Shapeless </em>完成的，基本上就是说传入的请求必须匹配其中一个端点。</p><h1 id="6786" class="lt ku hu bd kv lu mk lw kz lx ml lz ld ma mm mc lg md mn mf lj mg mo mi lm mj dt translated">结论</h1><p id="1f9a" class="pw-post-body-paragraph jc jd hu je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz hn dt translated">Finch是一个HTTP库，它提供了一种简单的方法来定义端点并将它们组合成一个更复杂的API。Finch允许我们为网络编写纯粹的功能性代码，能够以高速率响应服务器请求。</p></div></div>    
</body>
</html>