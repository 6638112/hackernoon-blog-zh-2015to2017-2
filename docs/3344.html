<html>
<head>
<title>Introducing Redux Offline: Offline-First Architecture for Progressive Web Applications and React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux Offline简介:渐进式Web应用程序和React Native的离线优先架构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-redux-offline-offline-first-architecture-for-progressive-web-applications-and-react-68c5167ecfe0?source=collection_archive---------0-----------------------#2017-03-28">https://medium.com/hackernoon/introducing-redux-offline-offline-first-architecture-for-progressive-web-applications-and-react-68c5167ecfe0?source=collection_archive---------0-----------------------#2017-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b755" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章是一篇关于构建离线友好的网络和移动应用的长篇旅行报告。如果你想了解离线友好应用的好处和挑战，请继续阅读。</p><p id="5524" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">如果你赶时间，或者只是在Redux Offline library上寻找信息，请前往</em> <a class="ae jq" href="https://github.com/jevakallio/redux-offline" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> Redux Offline GitHub资源库</em> </a> <em class="jp">。</em></p><h1 id="65f2" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">从我的错误中吸取教训</h1><p id="ea24" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">两年前，我用<a class="ae jq" href="https://facebook.github.io/react-native/" rel="noopener ugc nofollow" target="_blank">做了第一个手机app React Native</a>。它看起来像一个真正的应用程序:你可以滑动它，你可以点击它，它甚至可以接收推送通知。它拥有你所期待的移动应用程序的所有功能。作为一名网络开发人员，我非常满意我能够发布一个真正的移动应用程序<em class="jp">就像那个</em>一样。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/67a910348c02bfd72259067edd58aa53.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Dt0eQBeYZ6q0KA3E4ZKejA.gif"/></div></figure><p id="4c6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但后来人们开始使用这款应用，我开始听到用户的反馈。<em class="jp">“这个app烂透了！为什么它告诉我没有连接到网络？”</em> <em class="jp">“我不管网络，我只想看到我的图片！”结果是，我让这个应用看起来像一个真正的应用，但在一个重要的方面，它并不像一个真正的应用:它没有考虑到网络弹性。</em></p><p id="c716" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个愚蠢的新手错误，我很快修复了它，但这个错误一直困扰着我，我沉迷于发现用<a class="ae jq" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>开发离线应用的正确方法。</p><p id="a64f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，正确的方法并不只有一个，但是随着我对一些离线功能的React应用的研究，我发现了一个很好的方法，我想在这里分享一下。</p><h1 id="a683" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">移动目标</h1><p id="b979" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">你们中的许多人将会有和我一样的经历。多亏了ServiceWorker API，所谓的渐进式网络应用程序现在可以离线工作了。</p><p id="c528" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">两年前，我是一名跨越到移动领域的web开发人员。今年，将有更多的web开发人员编写他们的第一个移动应用程序，他们可能会发现，我在React Native中学到的教训同样适用于PWAs。</p><p id="92da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总的来说，我们将开始看到移动和web开发领域之间越来越多的交叉。为了创建成功的移动应用程序，不仅看起来像真正的应用程序，而且行为也像它们一样，web开发人员需要发现新的模式和实践。</p><p id="a7f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在我们讨论这些模式之前，还有一个原因说明为什么离线支持在今天如此重要。</p><h1 id="0179" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">新兴市场</h1><p id="40cb" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">今天，超过10亿人可以使用高速互联网，30亿人可以访问网络，超过50亿人拥有移动电话。每年都会有更多的人接入互联网。他们中的大多数将是移动用户，通过低速、间歇的连接进行连接。</p><p id="2de5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这些人来说，线下支持不是奢侈品，是基本的可及性。阅读布鲁斯·劳森的文章<a class="ae jq" href="https://www.smashingmagazine.com/2017/03/world-wide-web-not-wealthy-western-web-part-1/" rel="noopener ugc nofollow" target="_blank">万维网，而不是财富西方网</a>有更深入的了解。</p><p id="747e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是假设你不关心可访问性。或许你在乎，但付钱给你开发应用的人却不在乎。要求他们投入宝贵的工程资源来声援世界上一半的人是很难的。</p><p id="b646" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但事实是:许多获得互联网接入的用户正在随着收入的增加而步入中产阶级，他们代表着全球化互联网业务的巨大机遇。</p><p id="d690" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，投资离线优先的应用程序将使你的所有用户受益。我住在伦敦，虽然这里的网络和设备要好得多，但仍然有很好的理由让你的应用先离线。即使在3G和4G网络中，延迟仍然很可怕，离线优先的应用程序有更好的感知性能。所有网络仍然偶尔会出现故障或变得遥不可及，离线优先应用程序可以提供更好的用户体验。</p><p id="da45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之，虽然互联网的可访问性和民主化访问是重要的目标，但对于企业来说，没有比利润更强烈的动机了。为新兴市场创造丰富的网络和应用程序体验需要我们应用离线优先的工程实践，这些实践将使您的所有用户受益，而不仅仅是那些网络条件差的用户。</p><h1 id="b5f7" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">我如何下线？</h1><p id="52cb" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">现在，我们已经确定了离线支持是一个好主意，让我们来谈谈如何实现它。</p><h2 id="ff21" class="lc js hu bd jt ld le lf jx lg lh li kb jc lj lk kf jg ll lm kj jk ln lo kn lp dt translated">如果在线，那么…否则…</h2><p id="915f" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">最简单的方法就是检查你是否在线，并相应地扩展你的程序逻辑。当然，你可以看到这种方法非常原始，难以测试，并且会像滚雪球一样迅速失控。</p><p id="168a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法最重要的问题是，在<strong class="it hv">现实世界的移动网络条件下，不可能真正检测到你何时在线</strong>。网络状态不是二进制的真或假。您的移动接收器可能在技术上连接到网络，但无法到达远程服务器。或者连接延迟、故障或挂起非常严重，无论操作系统怎么说，你实际上都处于离线状态。最后，网络访问是易变的和非原子的。如果你检查你现在是否在线，当你发出请求的时候，现实可能已经改变了。因此，唯一真正的方法是努力去做这件事，并对失败有弹性。</p><h2 id="0649" class="lc js hu bd jt ld le lf jx lg lh li kb jc lj lk kf jg ll lm kj jk ln lo kn lp dt translated">直通网络缓存</h2><p id="0e05" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">如果网络是问题所在，也许我们可以在网络层解决问题。如果网络请求成功，则提供新数据并缓存以备后用。如果失败，则从后备存储中提供缓存的数据。乍一看，这似乎与ServiceWorker缓存API配合得很好，但事实证明这种缓存很难管理，而且不太灵活。此外，这种缓存并不自然地支持突变。您只能缓存数据获取，但很难在网络层实现状态的网络弹性更新。</p><h2 id="1483" class="lc js hu bd jt ld le lf jx lg lh li kb jc lj lk kf jg ll lm kj jk ln lo kn lp dt translated">数据库同步</h2><p id="0c42" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">更高级的解决方案是在存储抽象层实现离线支持。难道我们不能把数据保存到数据库中，然后让数据库想办法把数据同步到后端吗？</p><p id="e167" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有很多很好的工具可以做到这一点。<a class="ae jq" href="https://pouchdb.com/" rel="noopener ugc nofollow" target="_blank"> PouchDB </a>同步到服务器端的CouchDB。移动数据库产品公司去年发布的同名端对端同步解决方案<a class="ae jq" href="https://realm.io/products/realm-mobile-platform/" rel="noopener ugc nofollow" target="_blank"> Realm platform </a>，在这方面为本地应用做了出色的工作。Clojure的Datomic 是一个令人眼花缭乱的工程壮举。</p><p id="7e07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现这些解决方案非常棒，令人兴奋——当它们起作用时。数据存储同步开始时容易使用，但是机制不容易推理或修改。</p><p id="e654" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于大多数用例来说，数据存储同步的最后一个问题是，它要求您围绕一个特例数据库产品来设计后端。大多数应用开发者，当然不是像我们这样的顾问，无法证明构建一个完整的系统架构来让你的应用离线工作是正确的。</p><h1 id="e631" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">购物单</h1><p id="5118" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">当我开始研究离线应用如何反应时，我列出了几个要求:</p><p id="36eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想要一个不会强迫我采用全新的数据同步或后端模式的解决方案。</p><p id="767a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望我的团队中的大多数React开发人员已经熟悉并能够可靠地实现的东西，并对机制进行推理。</p><p id="e9f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想要一个能在本地移动应用、移动浏览器和桌面浏览器中通用的解决方案。</p><p id="51de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想要一个在任意需求面前不会崩溃的解决方案:</p><ol class=""><li id="ab21" class="lq lr hu it b iu iv iy iz jc ls jg lt jk lu jo lv lw lx ly dt translated"><strong class="it hv">只读</strong>离线支持是一个好的开始，但更多时候，你需要<strong class="it hv">读写</strong>网络弹性。</li><li id="dd12" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">大多数情况下，你想让你的应用程序支持<strong class="it hv">乐观更新</strong>，但是其他时候你需要<strong class="it hv">悲观UI状态</strong>，甚至是不同步更改的审计日志。</li><li id="1849" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">大多数情况下，对数据进行<strong class="it hv">延迟</strong>和增量缓存就足够了，但有时你需要<strong class="it hv">提前</strong>加载数据。</li><li id="0b93" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated"><strong class="it hv">后台同步</strong>是一个复杂的需求，但通常是必须的需求，所以架构应该足够灵活来支持它。</li><li id="7110" class="lq lr hu it b iu lz iy ma jc mb jg mc jk md jo lv lw lx ly dt translated">离线缓存应该能够经受住应用程序更新，这意味着我们需要一种简单的方式在版本之间迁移我们的数据库模式。</li></ol><p id="b450" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个很长的要求列表。哪种数据库产品可以满足这些要求？它自然会产生什么样的应用架构？</p><p id="000b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，我们已经有了主要的工具。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff me"><img src="../Images/18f54bce05bdea59b447d3e9db35977f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpaqVMW2RjQAg9cFHcX1pw.png"/></div></div></figure><p id="affa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，大多数React开发人员已经使用了Redux，并对使用它构建应用程序感到满意。</p><p id="2542" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在某些圈子里，Redux最近名声不好。“太多样板”、“太多仪式”、“太罗嗦”。至少有十几篇几乎完全相同的博客文章写道，用MobX编写应用程序要简单得多，也不那么冗长。</p><p id="e3e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然MobX是一个很好的工具，但与任何基于代码行度量的论点一样，这些文章中的一些没有抓住要点。</p><p id="3234" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Redux不太适合快速制作简单的东西。它能让非常困难的事情变得简单。</p><p id="87e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单，就像这样:</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff mj"><img src="../Images/1217ef38dc06178d26ec61d21172c5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHXj7A7_ss7tyYt4_prPPg.png"/></div></div></figure><p id="3adf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是我已经在多个应用程序中成功部署的基本机制，并且已经证明足够灵活和简单。不过，还是有一些活动部件。</p><p id="c68a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">基本思想是你的<strong class="it hv"> redux存储就是你的数据库</strong>。当您的存储发生变化时，您可以序列化并持久化它，当您的应用程序启动时，您可以将它读回内存。存储机制其实没多大关系，但是在浏览器中你可以使用localStorage或者IndexedDB，在React Native中你可以使用AsyncStorage，或者roll your own。</p><p id="d267" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你需要离线工作的任何操作都会在你的商店中保持，你的应用程序应该知道如何在重启后继续处理这些操作。这意味着我们不能依赖任何内存中的状态，同步这些动作所需的整个上下文需要与动作一起存储。</p><p id="5e59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个架构中，<strong class="it hv">离线支持的动作用一个离线元字段</strong>来修饰，该字段描述了网络效果应该如何执行，以及当它成功或失败时应该触发什么动作。离线操作然后排队，一旦在线就发送到服务器。发送的方式、地点和时间可能会有所不同。</p><p id="7dc4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种架构并不新颖。我是在研究如何做线下对的时候一块一块发现的，别人之前也发现过类似的模式。这个架构的大约70%可以用现有的中间件完全实现。特别是，<strong class="it hv"> redux-persist </strong>是一个神奇的库，可以满足你所有与持久性相关的需求，<strong class="it hv"> redux-optimist </strong>为乐观的行动提供了全面的支持。</p><p id="1ee9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，一如既往，细节决定成败。不同中间件之间的互操作可能会变得非常复杂，而且仍然有许多功能需要您自己实现。更糟糕的是，使用这些库的成功离线策略的路径没有在任何地方被记录。</p><p id="c316" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这最终让我们…</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/1797c593b1edd5df6e7891c3ee1fb9a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*z3mnx_Ipn3Ei8pYk."/></div></figure><p id="cc5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我很高兴地宣布一个为web和React Native创建离线优先应用程序的新解决方案。</p><p id="3c0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jq" href="https://github.com/jevakallio/redux-offline" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> Redux Offline </strong> </a>是一个小型的模块化库，为离线优先的应用程序提供全面支持。它的目标是易于使用，与任何后端API一起工作，并且可以在不到30分钟的时间内投入使用。</p><p id="aad5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在可以从npm安装的实现是新的和试验性的，但是它是基于一个可靠的和经过实战检验的模式。这是未来许多版本中的第一个，有了你的反馈，我希望它成为创建离线web应用程序的最佳解决方案。</p><p id="df67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我没有说<strong class="it hv">反应</strong>应用。Redux Offline对React没有依赖性。Redux Offline是一个独立的持久状态容器，可以与任何能够基于单一数据源以声明方式呈现自身的web应用程序一起工作，包括React、Angular 2、Vue、Preact和Inferno。</p><h1 id="f559" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">那么，它是做什么的？</h1><p id="7c17" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">Redux Offline旨在为离线优先体验的各个方面提供细粒度的控制。这包括如何编排网络弹性API调用，如何保持状态，如何批处理消息，以及如何处理错误、重试、乐观UI更新、迁移、缓存修剪等等。</p><p id="fd78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果这听起来很复杂，那是因为它可能是。这就是为什么Redux Offline旨在提供一组合理的默认行为，您可以开始使用，并根据需要逐个覆盖，同时继续利用该库的核心编排功能。</p><h1 id="9794" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">怎么用？</h1><p id="5c2e" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">在一个罕见的转变中，Redux Offline在发布前我花了最多时间改进的特性是文档。离线优先应用不是火箭科学，我也不是火箭科学家。从根本上说，Redux Offline解决的问题不是工程问题，而是架构问题。架构可以用代码实现，但是为了被理解、采用和遵循，它们需要被很好地交流。</p><p id="f76f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，与其在这里解释基本机制，不如去<a class="ae jq" href="https://github.com/jevakallio/redux-offline/tree/develop" rel="noopener ugc nofollow" target="_blank"> Redux Offline repository </a>了解API以及如何在您的应用程序中使用Redux Offline。</p><h1 id="11fd" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">最后</h1><p id="2533" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">无论你是否已经制作了第一个支持离线的web或React原生应用，大多数web开发人员在未来都会面临这个问题。</p><p id="eb53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我希望在这里展示的那样，离线能力不需要成为火箭科学。不一定需要数据库产品，也不需要放弃自己熟悉的架构。困难的部分不是编写代码让你的应用程序离线工作，而是应用一个足够强大和灵活的模式来适应不断发展的软件需求</p><p id="942f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望<a class="ae jq" href="https://github.com/jevakallio/redux-offline" rel="noopener ugc nofollow" target="_blank"> Redux Offline </a>能对你有所帮助。去试试吧，告诉我你的想法。</p><div class="kv kw kx ky fq ab cb"><figure class="ml kz mm mn mo mp mq paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ml kz mm mn mo mp mq paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ml kz mm mn mo mp mq paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mr ms mt"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb mu jd je jf mv jh ji jj mw jl jm jn jo hn dt translated"><a class="ae jq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb mu jd je jf mv jh ji jj mw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff mx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>