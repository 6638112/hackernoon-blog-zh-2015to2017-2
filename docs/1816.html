<html>
<head>
<title>Async Await BIBLE: Sequential, Parallel, Nest, Dynamic and Error Handling in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步等待圣经:Javascript中的顺序、并行、嵌套、动态和错误处理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/asycn-await-bible-sequential-parallel-and-nest-4d1db7b8b95c?source=collection_archive---------2-----------------------#2016-12-10">https://medium.com/hackernoon/asycn-await-bible-sequential-parallel-and-nest-4d1db7b8b95c?source=collection_archive---------2-----------------------#2016-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/0888f18994134699ca8d258dfd69cb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*SQylaaGb9juNEj_0KG-CSA.jpeg"/></div></figure><blockquote class="iy"><p id="2891" class="iz ja hu bd jb jc jd je jf jg jh ji ek translated">在ES5之前，JavaScripters开发者生活在回调地狱中。调试是一个疯狂的控制台。在数千个回调函数中登录。然后，拯救JavaScripters开发者的承诺出现了。承诺的魔力把那个地狱变成了一个扁平的结构，它是隧道尽头的光。Async Await是这个承诺的化身。ES7。</p></blockquote><h2 id="a504" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">8个必须知道的例子:</h2><ol class=""><li id="dfbb" class="kh ki hu kj b kk kl km kn ju ko jy kp kc kq ji kr ks kt ku dt translated">异步函数对象</li><li id="8675" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">承诺函数</li><li id="4f90" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">异步功能</li><li id="a3f2" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">依次等待</li><li id="ef1b" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">并行等待</li><li id="1559" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">等待嵌套</li><li id="f7d8" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">动态等待</li><li id="7ed4" class="kh ki hu kj b kk kv km kw ju kx jy ky kc kz ji kr ks kt ku dt translated">错误句柄</li></ol><h2 id="ee24" class="jj jk hu bd jl jm la jo jp jq lb js jt ju lc jw jx jy ld ka kb kc le ke kf kg dt translated">注意</h2><p id="6c0c" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">这个故事只关注异步问题。<br/> —致Nodejs开发者，要运行ES7请阅读: <a class="ae lv" href="https://hackernoon.com/nodejs-bbb-babel-burger-boilerplate-b74107eff049#.5x9fvu8ji" rel="noopener ugc nofollow" target="_blank"> BBB，巴别塔汉堡样板</a> e</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/0a7feb941fb5687e033aef9e8203e04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*ko3KtcVSlzpe3RnTRgJaHw.jpeg"/></div><figcaption class="mb mc fg fe ff md me bd b be z ek">Chronological Picture</figcaption></figure><h1 id="9485" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">1-异步:<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">异步函数</a>的构造函数</h1><p id="b303" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">AsyncFunction构造函数创建一个新的异步函数对象。在JavaScript中，每个异步函数实际上都是一个Async function对象。来自Mozilla :</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="52d9" class="jj jk hu mx b fv nb nc l nd ne">console.log(async function () {});</span></pre><p id="dc18" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">谁知道非功能性和承诺的兄弟姐妹？如果不是，则不允许跳过，因为这是ES6的承诺函数支持await的原因，也是Async await如何应用承诺特性的原因，例如<em class="lu">解析并行</em>和<em class="lu">错误处理</em>:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="467b" class="jj jk hu mx b fv nb nc l nd ne">function(){<br/>  ...<br/>  return new <strong class="mx hv"><em class="lu">Promise</em></strong>(function(resolve, reject) {<br/>    ...<br/>  })<br/>  ...<br/>}</span></pre><h1 id="f07c" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">2-构造承诺函数</h1><p id="2287" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">为什么我们在这里讨论承诺函数？因为人们可能忽略了Async await的基础是承诺，所以我们创建的每一个Async函数和我们等待的每一件事都会自然而然地成为承诺。</p><p id="eb3e" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">示例(感谢<a class="nk nl gr" href="https://medium.com/u/423e5feec011?source=post_page-----4d1db7b8b95c--------------------------------" rel="noopener" target="_blank"> Jyotman Sing </a>的建议):</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="c689" class="jj jk hu mx b fv nb nc l nd ne">(async function() {</span><span id="22c4" class="jj jk hu mx b fv nm nc l nd ne">  var sleep = function(para) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            resolve(para * para)<br/>        }, 1000)<br/>    })<br/>  }</span><span id="5e2f" class="jj jk hu mx b fv nm nc l nd ne">  var result = await sleep(2)<br/>  // result is 4</span><span id="8522" class="jj jk hu mx b fv nm nc l nd ne">})();</span></pre><h1 id="79b8" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">3-构造异步函数</h1><p id="cfc9" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated"><code class="eh nn no np mx b"><strong class="kj hv">async function</strong></code>声明定义了一个<em class="lu">异步函数</em>，它返回一个<code class="eh nn no np mx b"><a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">AsyncFunction</a></code>对象(也是一个承诺)。当异步函数返回值时，将使用返回值解析承诺。当async函数抛出异常或某个值时，promise将被抛出的值拒绝(<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> Mozilla </a>)。</p><p id="8a80" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">示例:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="44b6" class="jj jk hu mx b fv nb nc l nd ne">async function asyncSleep (para){<br/> return await sleep(para)<br/>}</span><span id="b5d8" class="jj jk hu mx b fv nm nc l nd ne">var result = await asyncSleep(2)<br/>//result is 4</span><span id="037f" class="jj jk hu mx b fv nm nc l nd ne">asyncSleep(3).then(function(result2){<br/>//result2 is 9<br/>})</span></pre><h1 id="2e68" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">4-顺序等待</h1><p id="bb9f" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">示例:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="5e31" class="jj jk hu mx b fv nb nc l nd ne">var result1 = await sleep(2);<br/>var result2 = await sleep(result1);<br/>var result3 = await sleep(result2);</span><span id="9e8a" class="jj jk hu mx b fv nm nc l nd ne">//result1 is 4<br/>//result2 is 16<br/>//result3 is 256</span></pre><h1 id="c17b" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">5-并行等待</h1><p id="ea57" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">示例:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="8f71" class="jj jk hu mx b fv nb nc l nd ne">var results = await Promise.all([sleep(1), sleep(2)]);<br/>//results is [1,4]</span></pre><h1 id="0ccc" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">六窝</h1><p id="69ff" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">示例:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="3cff" class="jj jk hu mx b fv nb nc l nd ne">for(var i =0 ; i&lt;3; i++){<br/>    var result = await sleep(i);</span><span id="bf63" class="jj jk hu mx b fv nm nc l nd ne">    for(var j =0 ; j&lt;result; j++){<br/>        console.log('   i:'+i+', j:'+j+': ', await sleep(j));<br/>    }<br/>}</span><span id="060a" class="jj jk hu mx b fv nm nc l nd ne">// i:1, j:0:  0<br/>// i:2, j:0:  0<br/>// i:2, j:1:  1<br/>// i:2, j:2:  4<br/>// i:2, j:3:  9</span></pre><h1 id="935d" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">7-动态异步函数</h1><blockquote class="iy"><p id="366f" class="iz ja hu bd jb jc nq nr ns nt nu ji ek translated">JavaScripters爱好者们，是时候承认了:我们在承诺方面有问题。</p></blockquote><p id="af58" class="pw-post-body-paragraph lf lg hu kj b kk nv lh li km nw lj lk ju nx lm ln jy ny lp lq kc nz ls lt ji hn dt translated">我很赞同<a class="ae lv" href="https://twitter.com/nolanlawson" rel="noopener ugc nofollow" target="_blank"> <em class="lu">诺兰·劳森</em> </a> <em class="lu">的</em>引用<em class="lu">。</em>动力学<em class="lu"> </em>在处理未知过程、动力学问题时需要使用承诺数组。对于这个问题，我的直觉是将所有的Promise函数放入一个数组中，然后依次等待它们。但是当我发现Promise函数在被声明的时候就执行了，这被证明是不正确的。我的结论是，用承诺解决问题，不要相信人的本能。</p><p id="3371" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">这种方法是将参数和承诺分开存储(这里使用的是map对象)</p><p id="77ba" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">示例:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="de7b" class="jj jk hu mx b fv nb nc l nd ne">var sleep = function(para1,para2) {<br/>    var _para1 = para1, _para2 = para2 || para1 ;<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            resolve(_para1 * _para2)<br/>        }, 1000)<br/>    })<br/>}</span><span id="e024" class="jj jk hu mx b fv nm nc l nd ne">var proMap = new Map();<br/>proMap.set([1], sleep);<br/>proMap.set([2, 3], sleep);<br/>proMap.set([3], sleep);</span><span id="8a24" class="jj jk hu mx b fv nm nc l nd ne">for (var [para, fun] of proMap.entries()) {<br/>    var result = await fun.apply(this, para);<br/>    console.log(para, result)<br/>}</span><span id="c95f" class="jj jk hu mx b fv nm nc l nd ne">//[ 1 ] 1<br/>//[ 2, 3 ] 6<br/>//[ 3 ] 9</span></pre><h1 id="932c" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">8-错误句柄</h1><blockquote class="iy"><p id="69c2" class="iz ja hu bd jb jc nq nr ns nt nu ji ek translated"><strong class="ak">错误被<em class="oa">、</em>、</strong>隐没在<code class="eh nn no np mx b">async</code>函数<em class="oa">中——就像正常的承诺(</em>、<a class="ae lv" href="https://ponyfoo.com/articles/understanding-javascript-async-await" rel="noopener ugc nofollow" target="_blank">、<em class="oa">尼古拉斯·贝瓦夸</em>、</a>、<em class="oa">)一样。</em></p></blockquote><p id="3ad1" class="pw-post-body-paragraph lf lg hu kj b kk nv lh li km nw lj lk ju nx lm ln jy ny lp lq kc nz ls lt ji hn dt translated"><strong class="kj hv">异步</strong>和<strong class="kj hv">承诺</strong>中的错误处理来自同一个母体，它们都需要try/catch，以便在异步函数中捕获和处理等待的承诺中的错误。</p><p id="1601" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">示例:</p><pre class="lx ly lz ma fq mw mx my mz aw na dt"><span id="591b" class="jj jk hu mx b fv nb nc l nd ne">var errorSleep = function(para) {<br/>    return new Promise(function(resolve, reject) {<br/>        setTimeout(function() {<br/>            reject(' ErrorSleep')<br/>        }, 1000)<br/>    })<br/>}</span><span id="aeb8" class="jj jk hu mx b fv nm nc l nd ne"><strong class="mx hv"><em class="lu">try {<br/></em></strong>    var result1 = await sleep(1);<br/>    var result2 = await errorSleep(4);<br/>    var result3 = await sleep(1);</span><span id="7306" class="jj jk hu mx b fv nm nc l nd ne">    console.log('result1: ', result1)<br/>    console.log('result2: ', result2)<br/>    console.log('result3: ', result3)<br/><strong class="mx hv"><em class="lu">} catch (err) {<br/></em></strong>    console.log('err: ', err)<br/>    console.log('result1: ', result1)<br/>    console.log('result2: ', result2)<br/>    console.log('result3: ', result3)<br/><strong class="mx hv"><em class="lu">}</em></strong></span><span id="930d" class="jj jk hu mx b fv nm nc l nd ne">//err:   ErrorSleep<br/>//result1:  1<br/>//result2:  undefined<br/>//result3:  undefined</span></pre><h1 id="f7ff" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated"><strong class="ak">总结</strong>:</h1><p id="db50" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt ob translated">对于nodejs和浏览器程序员来说，ood、async/await都是一个很好的语法改进。与承诺相比，这是到达同一个目的地的捷径。它帮助开发人员用JavaScript实现函数式编程，增加代码可读性，使JavaScript更有趣。</p><p id="205c" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt ob translated">ad，如第7和第8部分所述，Promise在动态生成实例和解析实例方面存在问题，并且当发现意外异常时，await应该给Javascripter程序一个更大的提示。</p></div><div class="ab cl ok ol hc om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="hn ho hp hq hr"><p id="c96f" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">喜欢这个故事？对别人有帮助吗？它帮助我知道你是否想看到写更多关于他的主题，并帮助人们看到这个故事，<strong class="kj hv"> <em class="lu">当点击下面的心</em> </strong>。</p><h1 id="6218" class="mf jk hu bd jl mg mh mi jp mj mk ml jt mm mn mo jx mp mq mr kb ms mt mu kf mv dt translated">参考:</h1><p id="39de" class="pw-post-body-paragraph lf lg hu kj b kk kl lh li km kn lj lk ju ll lm ln jy lo lp lq kc lr ls lt ji hn dt translated">来源:<br/><a class="ae lv" rel="noopener" href="/@peterchang_82818/javascript-es7-async-await-bible-tutorial-example-32294f6133ab#.m33vwg1yx">https://medium . com/@ Peter Chang _ 82818/JavaScript-es7-async-await-bible-tutorial-example-32294 f 6133 ab # . m 33 vwg1 yx</a></p><p id="ed30" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">Mozilla:<br/><a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/async function</a></p><p id="aaf1" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated">尼古拉斯·贝瓦夸<br/><a class="ae lv" href="https://ponyfoo.com/articles/understanding-javascript-async-await" rel="noopener ugc nofollow" target="_blank">https://pony foo . com/articles/understanding-JavaScript-async-await</a></p><p id="12ed" class="pw-post-body-paragraph lf lg hu kj b kk nf lh li km ng lj lk ju nh lm ln jy ni lp lq kc nj ls lt ji hn dt translated"><a class="ae lv" href="https://twitter.com/nolanlawson" rel="noopener ugc nofollow" target="_blank">诺兰·劳森</a><br/><a class="ae lv" href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" rel="noopener ugc nofollow" target="_blank">https://pouchdb . com/2015/05/18/we-have-a-problem-with-promises . html</a></p></div></div>    
</body>
</html>