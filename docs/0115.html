<html>
<head>
<title>Higher order functions, what are they?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶函数是什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/higher-order-functions-what-are-they-be74111659e8?source=collection_archive---------0-----------------------#2015-12-11">https://medium.com/hackernoon/higher-order-functions-what-are-they-be74111659e8?source=collection_archive---------0-----------------------#2015-12-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="915d" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">在数学和计算机科学中，高阶函数(也称泛函、函数形式或函子；不要与范畴理论中的函子概念相混淆)是一个至少执行以下操作之一的函数:</em></p><p id="f9ac" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> 1。接受一个或多个函数作为参数，</em></p><p id="903e" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu"> 2。返回一个函数作为结果。</em></p></blockquote><p id="6716" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这是正式的定义，但是它们到底是什么，我们为什么需要它们？</p><p id="7070" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">有时，对数据集的项执行某种操作是很重要的，但是这种特定的操作是在执行时定义的。有时候，除了我们需要在某个特定的点上做些什么之外，没有办法知道我们想要采取什么行动，但这是完全未知的。</p><p id="0c7d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们看一个例子。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="6437" class="kf kg hu kb b fv kh ki l kj kk">let x = [1..100] </span><span id="b35e" class="kf kg hu kb b fv kl ki l kj kk">for each item in x do<br/>    print(item)</span></pre><p id="1d11" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这里，我们通过调用print函数来打印列表x中的每个数字。如果我们需要对每个项目做些别的事情呢？我们需要实现我们认为会用到的所有可能的情况吗？</p><p id="3ee0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们定义一个<strong class="ix hv">函数</strong>，它将被x中的每个数字(项目)调用。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="4c3f" class="kf kg hu kb b fv kh ki l kj kk">let succ (x) -&gt; x + 1</span></pre><p id="0e5e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们已经定义了<strong class="ix hv">后继</strong>函数，它基本上获取一个值并返回它的后继。<strong class="ix hv"> succ </strong>的域是Int数，这可以从<strong class="ix hv"> succ </strong>的主体中推断出来，因为我们在参数中加了1，并且我们说<strong class="ix hv"> succ </strong>具有类型<strong class="ix hv"> Int - &gt; Int。</strong></p><p id="f55d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在，让我们回顾一下前面的例子。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="2658" class="kf kg hu kb b fv kh ki l kj kk">let map (f, list) = <br/>    for each item in list do<br/>        f(item)</span></pre><p id="86e3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这里，<strong class="ix hv"> map </strong>是一个高阶函数，因为它接收了函数<strong class="ix hv"> f </strong>作为参数，该函数将对列表中的每一项执行。在我们定义<strong class="ix hv">映射</strong>的时候，我们不需要知道<strong class="ix hv"> f </strong>的值会是什么，除了知道<strong class="ix hv"> f </strong>为type <strong class="ix hv"> Int - &gt; Some </strong>。没有办法从前面的代码中推断出<strong class="ix hv"> f </strong>的返回值，但是我们知道它必须接收一个<strong class="ix hv"> Int </strong>。</p><p id="1216" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">另一个例子是返回另一个函数的函数。我们来复习一下。</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="ee8f" class="kf kg hu kb b fv kh ki l kj kk">let plus2 (x) =<br/>    let succ (y) = y + 1<br/>    <br/>    succ (succ x)<br/>    <br/>let r = plus2 (1)</span></pre><p id="e6d8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在这种情况下，<strong class="ix hv"> plus2 </strong>是一个类型为<strong class="ix hv"> Int - &gt; Int - &gt; Int </strong>或<strong class="ix hv">Int-&gt;(Int-&gt;Int)</strong>的函数。它基本上接受一个<strong class="ix hv"> Int </strong>并返回一个接受另一个<strong class="ix hv"> Int </strong>并返回一个<strong class="ix hv"> Int </strong>的函数。评估后，r 将等于3。</p><p id="c8de" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在我们已经展示了这些类型的函数，让我们看看现代编程语言是如何定义它们的。</p><p id="8954" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<strong class="ix hv"> Scala </strong>中我们可以定义一个<strong class="ix hv"> (a - &gt; b，List[a]) - &gt; List[b] </strong>类型的<strong class="ix hv">映射</strong>函数如下:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="315b" class="kf kg hu kb b fv kh ki l kj kk">def map[a,b](f: a =&gt; b, v: List[a]): List[b] = {<br/>    for ( i &lt;- v )<br/>      yield f(i)<br/>  }<br/>  <br/>val squares = map( (x: Int) =&gt; x * x, 1.to(100).toList )</span></pre><p id="3ce2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">对于<strong class="ix hv"> v </strong>中的每个<strong class="ix hv"> i </strong>，我们应用函数<strong class="ix hv"> f </strong>并返回其值。变量squares将具有从1到100的数字的平方值。请注意，我们在调用<strong class="ix hv"> map </strong>的时候正在定义<strong class="ix hv">平方</strong>函数，所以<strong class="ix hv"> map </strong>对函数<strong class="ix hv"> f </strong>一无所知。我们可以很容易地说:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="02b0" class="kf kg hu kb b fv kh ki l kj kk">def succ (x: Int): Int = x + 1</span><span id="f00b" class="kf kg hu kb b fv kl ki l kj kk">val successors = map(succ, 1.to(100).toList)</span></pre><p id="5860" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们只是改变了传递给<strong class="ix hv">地图</strong>的函数，我们得到了完全不同的结果。这个抽象层次使得<strong class="ix hv"> map </strong>作为一个高阶函数非常强大。</p><p id="39fd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">即使是非函数式的编程语言，比如c#，也加入了这些抽象，因此它们可以灵活地用于许多用例。</p><p id="3106" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在C# 中，我们需要实现一个<em class="iw">委托</em>来获得相同的功能，但是它给语言带来了相同的价值。因为高阶或函数非常重要。NET框架已经实现了一些<em class="iw">委托</em>，所以让我们使用它们</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="c488" class="kf kg hu kb b fv kh ki l kj kk">List&lt;b&gt; map&lt;a&gt;(Func&lt;a,b&gt; f, List&lt;a&gt; list) <br/>{<br/>    foreach (a x in list) <br/>    {<br/>        yield return f(x);<br/>    }<br/>}</span><span id="5812" class="kf kg hu kb b fv kl ki l kj kk">var successors = map(x =&gt; x + 1, someIntList);</span></pre><p id="afeb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们已经在<strong class="ix hv"> Scala </strong>中实现了<strong class="ix hv">贴图</strong>的相同功能。唯一不同的是<strong class="ix hv"> C# </strong>没有更高阶的函数，它必须使用<em class="iw">委托</em>构造，然而我们得到了相同的功能。注意，在<strong class="ix hv"> C# </strong>中，当我们将<strong class="ix hv"> succ </strong>函数传递给<strong class="ix hv"> map </strong>时，不需要声明该函数的参数类型，由<strong class="ix hv"> C# </strong>来推断！</p><p id="5579" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在<strong class="ix hv"> F# </strong>中，它变得非常有趣，因为语言支持函数式编程(FP)范式。在<strong class="ix hv"> F# </strong>中我们做:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="0065" class="kf kg hu kb b fv kh ki l kj kk">let map f = function<br/>    |[]     -&gt;[]<br/>    |h::t   -&gt; (f h) @ (t |&gt; map f) </span><span id="05c6" class="kf kg hu kb b fv kl ki l kj kk">let successors = [1..100] |&gt; map (fun x -&gt; x + 1)</span></pre><p id="9a7c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">看起来很复杂，但实际上它与我们之前看到的<strong class="ix hv">地图</strong>是一样的。唯一增加的是函数式编程风格和尾部递归，这是函数式编程语言的典型特征。管道<strong class="ix hv"> | &gt; </strong>操作符只是一个语言构造，我们可以说<strong class="ix hv"> map f t </strong>或<strong class="ix hv"> map (fun x - &gt; x + 1) [1..100] </strong>。注意，类型推理系统在<strong class="ix hv"> F# </strong>中工作得相当好。我们没有定义任何类型；然而，<strong class="ix hv">映射</strong>被推断为接收一个函数和一个列表，并返回一个<em class="iw">转换的</em>列表。</p><p id="4963" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> F# </strong>中的<strong class="ix hv">加2 </strong>功能如下:</p><pre class="jw jx jy jz fq ka kb kc kd aw ke dt"><span id="c509" class="kf kg hu kb b fv kh ki l kj kk">let plus2 x = <br/>    let succ y = y + 1  <br/>    succ succ y</span></pre><p id="7a7c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">对于一些人来说，高阶函数在他们的生活中很常见。这些函数内置于许多语言和框架中；尽管如此，我还是看到了他们周围的一些困惑。不支持它们的语言需要找到有时不容易使用和实现的替代方法。<strong class="ix hv"> C </strong>语言使用指向函数的指针，<strong class="ix hv"> C# </strong>使用<em class="iw">委托</em>其他语言使用对象作为替代。另一方面，有些产品支持开箱即用的高阶功能。<strong class="ix hv"> Scala </strong>、<strong class="ix hv"> Python </strong>、<strong class="ix hv"> F# </strong>只是几个例子。</p><p id="bf7d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">即使有时我们使用这些函数时没有考虑太多，我们也应该知道它们是如何实现的，这样我们就可以从中受益更多。那些对我们从<em class="iw">λ</em>演算继承的这种编程结构不熟悉的人应该学习它们并熟悉它们，因为函数式编程的趋势似乎正在赢得一些战斗。高阶函数是FP语言的支柱之一，这似乎是未来的趋势。</p><blockquote class="ir is it"><p id="cf61" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><a class="ae km" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae km" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae km" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="dca4" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae km" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae km" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae km" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae km" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>