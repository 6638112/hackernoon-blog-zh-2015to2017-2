<html>
<head>
<title>Mobile API Security Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动API安全技术</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/mobile-api-security-techniques-682a5da4fe10?source=collection_archive---------0-----------------------#2017-01-25">https://medium.com/hackernoon/mobile-api-security-techniques-682a5da4fe10?source=collection_archive---------0-----------------------#2017-01-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="0cfb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">第1部分—应用程序和用户API密钥</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/df415dd9c5b956cb69aac6a17d050a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*XKnNotdCW8P0GYGi.png"/></div></figure><p id="a1e1" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">移动应用通常使用API与后端服务和信息进行交互。2016年，花在<a class="ae kn" href="https://www.flickr.com/photos/138382953@N08/31415282864/in/dateposted-public/" rel="noopener ugc nofollow" target="_blank">移动应用上的时间同比增长了令人印象深刻的69%</a>，强化了大多数公司的移动优先战略，同时也为网络犯罪分子提供了新的、有吸引力的<a class="ae kn" href="https://www.approov.io/blog/theres-a-fake-app-for-that.html" rel="noopener ugc nofollow" target="_blank">目标</a>。作为API提供商，保护您的企业资产免受信息抓取、恶意活动和拒绝服务攻击，对于维护声誉良好的品牌和实现利润最大化至关重要。</p><p id="3593" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果使用得当，API密钥和令牌在应用程序安全性、效率和使用情况跟踪方面发挥着重要作用。虽然在概念上很简单，但是API键和令牌有很多需要注意的问题。在第1部分中，我们将从一个非常简单的API密钥用法的例子开始，并迭代地增强它的API保护。在<a class="ae kn" href="https://hackernoon.com/mobile-api-security-techniques-fc1f577840ab#.ext32ysbh" rel="noopener ugc nofollow" target="_blank">第2部分</a>中，我们将在几个OAuth2场景中从密钥转移到JWT令牌，在我们的最终实现中，我们将删除存储在客户端中的任何用户凭证和静态机密，即使令牌不知何故遭到破坏，我们也可以最小化对单个API调用的暴露。</p><h1 id="849d" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">从一个简单的应用ID密钥开始</h1><p id="505e" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">最简单的API键只是一个应用程序或开发人员ID字符串。为了使用API，开发人员向API服务注册他的应用程序，并接收一个惟一的ID，以便在发出API请求时使用。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/2fb7ad749ca563e29aeaa28d2610b41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*3URatw4SLPYq48jNVP0SxQ.png"/></div></figure><p id="a4b3" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在序列图中，客户端是一个移动应用程序。资源所有者是应用程序用户，资源服务器是通过API调用与客户机交互的后端服务器。我们将尽可能多地使用<a class="ae kn" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>术语。</p><p id="8065" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对于每个API调用，客户机在HTTP请求中传递API键。通常最好将API密钥作为授权报头的一部分发送，例如:</p><p id="0f34" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">授权:密钥some-客户端id</p><p id="588a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">URL经常被记录，因此如果API键作为查询参数传递，它可能会出现在客户端日志中并很容易被观察到，正如过去的<a class="ae kn" href="http://blog.parse.com/learn/engineering/discovering-a-major-security-hole-in-facebooks-android-sdk/" rel="noopener ugc nofollow" target="_blank">脸书漏洞</a>所示。这种最初的API密钥方法提供了一些基本的保护。如果调用不包含可识别的ID，任何进行API调用的应用程序都将被拒绝。具有不同键的不同应用程序也可以具有与那些键相关联的不同权限范围；例如，一个应用程序可能具有只读访问权限，而另一个应用程序可能被授予对相同后端服务的管理访问权限。</p><p id="f85c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">密钥可用于收集关于API使用的基本统计数据，如呼叫计数或流量来源，可能会拒绝来自非应用程序用户代理的呼叫。重要的是，大多数API服务使用调用统计来强制每个应用的速率限制，以提供不同的服务等级或拒绝可疑的高频率调用模式。这种简单方法的一个明显缺点是API调用和密钥是以明文形式传递的。一个<a class="ae kn" href="https://www.owasp.org/index.php/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人攻击</a>可以成功修改任何API调用或逆向工程API，并使用观察到的API密钥进行自己的恶意API调用。在不破坏现有应用程序实例并要求升级整个安装基础的情况下，不能将受损的API密钥列入黑名单。</p><h1 id="fab1" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">保护通信信道</h1><p id="96a7" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated"><a class="ae kn" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank">传输层安全性</a> (TLS)是一种保护HTTP通道的机密性、完整性和认证的标准方法。通过<a class="ae kn" href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" rel="noopener ugc nofollow" target="_blank">相互TLS </a>，客户端和服务器交换并验证彼此的公钥。使用<a class="ae kn" href="https://www.owasp.org/index.php/Pinning_Cheat_Sheet" rel="noopener ugc nofollow" target="_blank">证书锁定</a>，客户端和服务器知道预期的公钥，因此它们将实际交换的密钥与预期的密钥进行比较，而不是通过证书的层次链来验证客户端和服务器必须保持它们自己的私钥安全。一旦验证了密钥，客户端和服务器就协商共享秘密、消息认证码(MAC)和加密算法。</p><p id="4d2e" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">当运行在未受损的移动设备上时，TLS上的客户端流量相对于中间人攻击是相当安全的。不幸的是，如果攻击者可以在他控制的设备上安装您的客户端应用程序，他可以使用数据包嗅探器来观察公钥交换，并使用该知识来解密通道以观察API密钥，并对您的API进行逆向工程。虽然他可能无法观察其他客户端上的流量，但他现在可以创建自己的恶意应用程序，通过TLS安全通道免费调用您的API。因此，即使在使用TLS时，您也需要额外的安全性来防止API被未授权的应用程序调用。</p><h1 id="ccd2" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">防止API调用篡改</h1><p id="c5d6" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">我们可以做的第一个改进是将API密钥分成一个ID和一个共享秘密。和以前一样，密钥的ID部分与每个HTTP请求一起传递，但是共享秘密用于签名和/或加密传输中的信息。</p><p id="ee0f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了确保消息的完整性，客户端使用共享的秘密和算法(如<a class="ae kn" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code" rel="noopener ugc nofollow" target="_blank">HMAC·SHA-256</a>)为每个请求计算消息认证码(MAC)。使用相同的秘密，服务器计算接收到的消息MAC，并将其与请求中发送的MAC进行比较。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/a58483c0ab9f82062034c0a8765c0e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*3P1Nn9s5pefb_1ou.png"/></div></figure><p id="ff77" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">虽然客户端和服务器都知道这个秘密，但是这个秘密永远不会出现在通信信道中。攻击者可能会以某种方式看到ID，但是如果没有秘密，他就不能正确地签署请求。按照现在的情况，攻击者仍然可以拒绝或重放请求，但是他不能改变它。围绕这个方案构建的例子包括<a class="ae kn" href="https://github.com/hueniverse/hawk" rel="noopener ugc nofollow" target="_blank"> HAWK </a> HTTP认证规范或者<a class="ae kn" href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html" rel="noopener ugc nofollow" target="_blank">亚马逊S3 REST API签名和授权方案</a>。</p><p id="f2ed" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了进一步保护关键信息不被看到，在签名之前，可以使用从共享秘密导出的密钥材料对消息的全部或部分进行加密。</p><h1 id="170d" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">保护秘密</h1><p id="0202" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">我们开始在客户身上积累秘密。我们有共享的API秘密和客户机的私有TLS密钥。</p><p id="7c8b" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在它的基本形式中，秘密将是安装的应用程序包的静态常量，使用开发人员友好的名称，如SHARED_SECRET。一个初级黑客不需要太多时间就能提取出这个常量，一旦他得到了这个常量，你的后端就暴露了。作为第一步，使用<a class="ae kn" href="http://stackoverflow.com/questions/14570989/best-practice-for-storing-private-api-keys-in-android" rel="noopener ugc nofollow" target="_blank">代码混淆器</a>，使其更难定位和提取秘密常数。更进一步，考虑一下<a class="ae kn" href="https://www.approov.io/blog/simple-app-authentication.html" rel="noopener ugc nofollow" target="_blank">以某种计算简单的方式编码一个静态秘密</a>，将编码分割成小段，然后将它们分布在二进制文件中。根据需要在内存中重组和解码秘密；千万不要把它保存在永久存储器里。</p><p id="2fac" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">虽然公钥实际上不是秘密，但是您也想混淆它们。它们的值可以被观察到，因此如果它们没有被混淆，就很容易被发现和更改，从而很容易禁用或欺骗后端流量。</p><p id="682b" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">不管你如何努力，关键不是秘密是否会被窃取，而是窃取秘密的时间和努力是否值得回报。让它变得尽可能困难。如果一个API秘密被窃取，我们会遇到和以前一样的可撤销性问题；所有的应用程序实例都将受到损害，直到我们用新的秘密和新的技术来掩盖它，从而升级整个安装基础。</p><p id="adf3" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们将在第2部分再次回到这个挑战，在那里我们将讨论从应用程序中完全移除秘密的方法。</p><h1 id="b10e" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">处理用户凭据</h1><p id="93de" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">我们已经使用应用程序密钥增强了API安全性，但是我们还没有考虑如何处理用户凭证。</p><p id="4713" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">从简单的开始，客户端请求用户提供用户ID和密码。使用<a class="ae kn" href="https://en.wikipedia.org/wiki/Basic_access_authentication" rel="noopener ugc nofollow" target="_blank">基本访问认证</a>，客户端对凭证进行编码并传递给服务器，服务器对凭证进行验证。如果凭证有效，服务器可以启动用户会话并返回用户会话密钥。使用相同凭据的多个身份验证应该总是返回不同的密钥字符串。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/d43c0b6289ba6de2006d6b0698dc107e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*aTxQhQZor0sHixnI.png"/></div></figure><p id="7a4a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">正如我们看到的应用程序密钥，我们可以使用用户密钥来收集统计数据和设置授权级别，但现在我们可以用用户级粒度来完成。假设我们同时使用应用程序和用户密钥，用户的授权级别将是应用程序和用户的函数；例如，用户可能在一个应用程序上拥有管理授权，而在另一个应用程序上只有读取权限，即使他们正在与同一个后端服务器对话。</p><p id="863c" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">类似于使用<a class="ae kn" href="https://en.wikipedia.org/wiki/HTTP_cookie" rel="noopener ugc nofollow" target="_blank">HTTP cookie</a>时，会话状态通常在服务器上维护。这可能会降低服务器的可伸缩性，如果多个服务器可以处理一个用户请求，则它们之间的会话数据必须同步。我们将在第2部分用用户令牌解决这个问题。</p><p id="2090" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">到目前为止，我们的应用程序密钥是静态的，因此具有无限的生存期。相比之下，用户密钥是在服务器上创建的，它们可以而且应该过期。当用户密钥过期时，用户必须重新进行身份验证才能继续进行API调用，并且会话状态会丢失。用户不喜欢重复登录，因此需要对密钥生存期做出策略决策。生存期越长，用户就越方便，但是如果用户密钥被泄露，它也可能被恶意使用更长时间。</p><p id="8d94" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果一个键可以比一个应用程序实例持续更长时间，那么它必须在应用程序调用之间存储在客户端的持久存储中。这在本质上比密钥只存在于内存中更不安全。使用安全存储，如IOS的<a class="ae kn" href="https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#//apple_ref/doc/uid/TP30000897-CH203-TP1" rel="noopener ugc nofollow" target="_blank">钥匙链服务</a>，考虑Android的<a class="ae kn" href="https://developer.android.com/reference/android/content/SharedPreferences.html" rel="noopener ugc nofollow" target="_blank">共享首选项</a>。</p><p id="4b1e" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">与应用程序密钥不同，用户密钥可以在不破坏已安装的应用程序的情况下被撤销。</p><h1 id="5f39" class="ko kp hu bd kq kr ks kt ku kv kw kx ky ja kz jb la jd lb je lc jg ld jh le lf dt translated">摘要</h1><p id="5869" class="pw-post-body-paragraph jr js hu jt b ju lg iv jw jx lh iy jz ka li kc kd ke lj kg kh ki lk kk kl km hn dt translated">我们从一个非常简单的API密钥使用示例开始，并迭代地增强了它的API保护，以保护通信通道，并使用API密钥授权客户端和用户。在<a class="ae kn" href="https://hackernoon.com/mobile-api-security-techniques-fc1f577840ab#.ext32ysbh" rel="noopener ugc nofollow" target="_blank">第2部分</a>中，我们将在几个OAuth2场景中从密钥转移到JWT令牌，在我们的最终实现中，我们将删除存储在客户端中的任何用户凭证和静态机密，即使令牌不知何故遭到破坏，我们也可以最大限度地减少对单个API调用的暴露。</p></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><p id="4c1a" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">感谢阅读！如果你能推荐这篇文章(点击❤按钮)，让其他人也能找到，我将不胜感激。</p><p id="ab17" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><em class="lu">最初发表于</em><a class="ae kn" href="https://approov.io/blog/mobile-api-security-techniques-part-1.html" rel="noopener ugc nofollow" target="_blank"><em class="lu">approov.io/blog</em></a><em class="lu">。</em></p><div class="jk jl jm jn fq ab cb"><figure class="lv jo lw lx ly lz ma paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lv jo lw lx ly lz ma paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lv jo lw lx ly lz ma paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mb mc md"><p id="f922" class="jr js lu jt b ju jv iv jw jx jy iy jz me kb kc kd mf kf kg kh mg kj kk kl km hn dt translated"><a class="ae kn" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kn" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kn" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kn" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jr js lu jt b ju jv iv jw jx jy iy jz me kb kc kd mf kf kg kh mg kj kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kn" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kn" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>