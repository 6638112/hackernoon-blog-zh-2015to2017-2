<html>
<head>
<title>How to avoid duplicates when you insert hundreds of thousands of entries into the same MySQL table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当您在同一个MySQL表中插入数十万个条目时，如何避免重复</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-avoid-duplicates-when-you-insert-hundreds-of-thousands-of-entries-into-the-same-mysql-table-bf8a6e1e905?source=collection_archive---------2-----------------------#2017-11-23">https://medium.com/hackernoon/how-to-avoid-duplicates-when-you-insert-hundreds-of-thousands-of-entries-into-the-same-mysql-table-bf8a6e1e905?source=collection_archive---------2-----------------------#2017-11-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><a href="https://goo.gl/RDUt4v"><div class="fe ff fg"><img src="../Images/52bf9e84126f483254abfde8427668f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh3jPIRkLQOFi35thK-fkQ.png"/></div></a></figure><p id="74dc" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">假设您正在开发一个应用程序，它要求一个表中的所有条目(姑且称之为<code class="eh jv jw jx jy b">entries</code>)都是惟一的。<br/>如果我们用PHP/Laravel编写应用程序，表的迁移(更准确地说是它的<code class="eh jv jw jx jy b">up()</code>方法)将如下所示:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="c8dc" class="kh ki hu jy b fv kj kk l kl km">public function up()<br/>    {<br/>        Schema::create('entries', function (Blueprint $table) {<br/>            $table-&gt;increments('id');<br/>            $table-&gt;string('parameters_001')-&gt;nullable();<br/>            $table-&gt;string('parameters_002')-&gt;nullable();<br/>            $table-&gt;string('parameters_003')-&gt;nullable();<br/>            $table-&gt;string('parameters_004')-&gt;nullable();<br/>            $table-&gt;timestamps();<br/>        });<br/>    }</span></pre><p id="35b2" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">解决这个问题的一种方法(如果不是想到的最明显的方法)如下:</p><p id="0ede" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">使用一个简单的检查，创建一个名为<code class="eh jv jw jx jy b">isDuplicated($entry)</code>的方法来搜索表中的条目，如果不存在就插入，否则抛出一个异常。</p><p id="fb75" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这个方法可能看起来像这样(它应该被添加到<code class="eh jv jw jx jy b">Entry</code>模型类中):</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="cbac" class="kh ki hu jy b fv kj kk l kl km">public static function isDuplicated($inputs)<br/>    {<br/>        $exists = self::where('parameter_001', $inputs['parameter_001'])<br/>                       -&gt;where('parameter_002', $inputs['parameter_002'])<br/>                       -&gt;where('parameter_003', $inputs['parameter_003'])<br/>                       -&gt;where('parameter_004', $inputs['parameter_004'])<br/>                       -&gt;count();</span><span id="b56f" class="kh ki hu jy b fv kn kk l kl km">        return $exists ? true : false;<br/>    }</span></pre><p id="c6a6" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">PS:我们可以在插入中添加一个监听器，并在使用<code class="eh jv jw jx jy b">Entry::create()</code>方法时自动进行检查，但为了简单起见，我们不会在本教程中这样做。</p><p id="b1fa" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这个解决方案工作得很好，对于大多数情况来说可能是一个好的解决方案，但是让我们假设您的应用程序很大，每天/每小时要插入数百万个条目。过一会儿，你肯定会注意到一些重复的条目。</p><p id="b754" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这是怎么发生的？您可能会问，在插入之前，您已经在检查表格了。事实证明，当应用程序试图在完全相同的时刻两次插入相同的条目时，问题就出现了。因为应用程序同时通过<code class="eh jv jw jx jy b">isDuplicated($entry)</code>方法检查表中是否已经存在条目，所以这两个操作都将返回false，我们最终两次插入相同的条目。</p><p id="8127" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">现在想到的第一个解决方案如下:使用某种锁定机制(在MySql级别):</p><p id="871d" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">要么通过使用事务:<br/><a class="ae ko" href="https://laravel.com/docs/5.5/database#database-transactions" rel="noopener ugc nofollow" target="_blank"/><br/>或者悲观锁定<br/><a class="ae ko" href="https://laravel.com/docs/5.5/queries#pessimistic-locking" rel="noopener ugc nofollow" target="_blank">https://laravel.com/docs/5.5/queries#pessimistic-locking</a></p><p id="dd2a" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">在这种情况下，我们将确保不能两次插入同一行，对吗？</p><p id="90e9" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这似乎是一个非常好的解决方案，但是如果你想一想，当你试图插入一个新的条目时，首先没有要锁定的内容，我们不是在更新一个现有的行(在这种情况下，锁定可以很好地工作)，而是在插入一个全新的行。</p><p id="e751" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">因此，在这种情况下，锁机制将毫无价值。</p><p id="00aa" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">您可能想到的另一个解决方案是为整个表添加一个索引，一个由所有字段组成的键。</p><p id="9a45" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这里出现了一个问题(记住，我们讨论的是成千上万的条目),我们可能会很快遇到一些性能问题，在整个表上建立一个索引会大大降低对它的操作速度。</p><p id="ceab" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">即使不考虑性能问题，我们还有另一个问题。</p><p id="5acc" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">假设我们试图插入这个条目两次:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="47d2" class="kh ki hu jy b fv kj kk l kl km">['parameter_001'=&gt; 'value_001',<br/>'parameter_002'=&gt; 'value_002',<br/>'parameter_003'=&gt; 'value_003',<br/>'parameter_004'=&gt; 'value_004'<br/>];</span></pre><p id="0ace" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">不出所料，第一个将被插入，第二个将被拒绝(也不出所料),因为违反了我们使用的索引/键。</p><p id="41c5" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">但是，如果我们尝试将以下条目插入两次:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="e460" class="kh ki hu jy b fv kj kk l kl km">['parameter_001'=&gt; 'value_001',<br/>'parameter_002'=&gt; 'value_002',<br/>'parameter_003'=&gt; 'value_003'<br/>];</span></pre><p id="be42" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">它将被插入两次，没有任何问题。但是为什么会这样呢？</p><p id="d074" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">请记住，我们在这个表中字段是可空的，这意味着，当我们试图插入一个新条目时，我们的“全局”索引将防止所有子键都存在且已经插入的条目。但是如果省略了一个子键，他们的检查就会失败，我们就会得到一个重复的条目。</p><p id="a5b8" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">尽管这个解决方案并不正确，但它让我们接近了我们应该做的事情，从某种意义上说，我们应该让MySql来处理这个问题，而不是在代码中处理，我们可以使用相同的概念，而不会影响性能，也不会因为省略了“子键”而失败。</p><p id="3060" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这个问题的解决方案是创建一个额外的行，表示条目的散列，我们称之为<code class="eh jv jw jx jy b">hash</code>，这个散列将扮演唯一键的角色，所以当我们试图插入条目时，我们将它的散列添加到其中，并尝试插入，如果操作成功，即MySql没有抛出任何异常，那么条目确实是唯一的，否则，Mysql将抛出一个异常，因为它不能插入具有相同唯一键的两行。</p><p id="8d10" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">首先我们需要将这一行添加到条目表迁移的<code class="eh jv jw jx jy b">up()</code>方法中:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="bcb2" class="kh ki hu jy b fv kj kk l kl km">$table→string('hash')→unique();</span></pre><p id="264e" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">现在，在这种情况下，还有一件事我们应该注意，我们需要确保散列是唯一的，并且没有共谋。换句话说，我们不能使用像md5这样的单向散列法，因为我们最终会得到两个具有相同密钥的条目，但是像base64(或者甚至连接所有字段)这样的方法也可以</p><p id="668b" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">PS:不要忘记将<code class="eh jv jw jx jy b">fillable</code>属性添加到模型类中</p><p id="b591" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated"><code class="eh jv jw jx jy b">protected $fillable = ['parameter_001', 'parameter_002', 'parameter_003', 'parameter_004', $hash];</code></p><p id="0f4a" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">当我们创建散列时，我们应该明确考虑的另一件事是，在我们生成散列之前，在字段之间添加一个分隔符，换句话说，当我们尝试插入以下条目时:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="83b9" class="kh ki hu jy b fv kj kk l kl km">['parameter_001'=&gt; 'value_001',<br/>'parameter_002'=&gt; 'value_002',<br/>'parameter_003'=&gt; 'value_003'<br/>];</span></pre><p id="91ff" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">我们应该为类似<code class="eh jv jw jx jy b">value_001-value_002-value_003</code>的东西生成散列</p><p id="0c64" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">PS:这里不要使用简单的<code class="eh jv jw jx jy b">implode()</code>方法，因为这会忽略条目中不存在的字段。</p><p id="ebc9" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">这背后的原因是，如果我们不添加任何分隔符，当我们有一些丢失的参数时，我们会有假阳性，并且我们对不同的字段使用相同的值。<br/>例如，以下条目不是重复的(即插入没有任何问题),但MySql会拒绝它们:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="4307" class="kh ki hu jy b fv kj kk l kl km">['parameter_001'=&gt; 'value_001',<br/>'parameter_002'=&gt; 'value_002',<br/> 'parameter_003'=&gt; 'value_003'<br/>];</span></pre><p id="2bcd" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">和</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="e50c" class="kh ki hu jy b fv kj kk l kl km">['parameter_001'=&gt; 'value_001',<br/>'parameter_002'=&gt; 'value_002',<br/>'parameter_004'=&gt; 'value_003',<br/>];</span></pre><p id="7f2f" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">因为如果我们在没有任何分隔符的情况下连接，我们将在两种情况下以<code class="eh jv jw jx jy b">value_001value_002value_003</code>的散列结束，而当我们添加分隔符时，我们将为第一个条目生成<code class="eh jv jw jx jy b">value_001-value_002-value_003</code>的散列，为第二个条目生成<code class="eh jv jw jx jy b">value_001value_002--value_003</code>(注意双<code class="eh jv jw jx jy b">-</code>符号)，这将生成与第一个不同的散列。</p><p id="f0ae" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">总而言之，每次我们想要插入一个新条目时，我们都会为这个条目生成一个唯一的散列，我们将这个散列和这个条目一起插入，由于这个散列上有一个索引，所以重复的条目不会被插入，Mysql会抛出一个异常。</p><h1 id="9acc" class="kp ki hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">mysql可能抛出的另一个与重复数据删除无关的异常呢？</h1><p id="8103" class="pw-post-body-paragraph ix iy hu iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hn dt translated">如果我们想要捕获与这种重复机制相关的异常(我们可能想要在某个地方记录它，或者在发生这种情况时执行一些逻辑)，那么捕获所有异常并不是一个好的解决方案，因为MySQL可能会因为完全不同的原因而抛出异常，而不是重复异常。</p><p id="8600" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">为了解决这个问题，我们需要分析抛出的异常，并相应地执行正确的逻辑。<br/>如果你看一下关于异常的Mysql文档，你可以找到关于我们想要处理的复制异常的信息:<br/><a class="ae ko" href="https://dev.mysql.com/doc/refman/5.7/en/error-messages-server.html#error_er_dup_entry" rel="noopener ugc nofollow" target="_blank">https://dev . Mysql . com/doc/ref man/5.7/en/error-messages-server . html # error _ er _ dup _ entry</a></p><p id="52e4" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">如您所见，当我们试图插入一个重复的条目时，MySQL抛出一个异常，该异常具有SQL状态<code class="eh jv jw jx jy b">23000</code>和错误代码<code class="eh jv jw jx jy b">1062</code>，因此我们可以编写一个方法来验证这一点:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="d6a2" class="kh ki hu jy b fv kj kk l kl km">private function isDuplicateEntryException(QueryException $e)<br/>  {</span><span id="a614" class="kh ki hu jy b fv kn kk l kl km">      $sqlState = $e-&gt;errorInfo[0];<br/>      $errorCode  = $e-&gt;errorInfo[1];<br/>      if ($sqlState === "23000" &amp;&amp; $errorCode === 1062) {</span><span id="a87a" class="kh ki hu jy b fv kn kk l kl km">        return true;<br/>      }</span><span id="107f" class="kh ki hu jy b fv kn kk l kl km">      return false;<br/>  }</span></pre><p id="1e90" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">然后我们可以在代码中添加这种检查，如下所示:</p><pre class="jz ka kb kc fq kd jy ke kf aw kg dt"><span id="baee" class="kh ki hu jy b fv kj kk l kl km">try{<br/>// insert the entry<br/> }<br/>    catch (QueryException $e) {<br/>           if ($this-&gt;isDuplicateEntryException($e)) {<br/>            throw new DuplicateEntryException('Duplicate Entry');<br/>           }</span><span id="14ed" class="kh ki hu jy b fv kn kk l kl km">           throw $e;</span><span id="ad10" class="kh ki hu jy b fv kn kk l kl km">    }</span></pre><p id="b845" class="pw-post-body-paragraph ix iy hu iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hn dt translated">本文首次发表于此:<a class="ae ko" href="http://youghourta.com/2017/11/21/avoid-duplicates-insert-hundreds-thousands-entries-mysql-table/" rel="noopener ugc nofollow" target="_blank">当你在同一个MySQL表中插入数十万个条目时如何避免重复</a></p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><a href="https://goo.gl/1ohA17"><div class="fe ff lr"><img src="../Images/4c66888dbc35e2b0486de57a3abf0178.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*JwcPRv0mzGSICkOV121lXQ.png"/></div></a></figure><figure class="jz ka kb kc fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure></div></div>    
</body>
</html>