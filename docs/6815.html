<html>
<head>
<title>Refactoring — The Hygienic Habit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构——卫生习惯</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/refactoring-the-hygienic-habit-b2ee0f5528ba?source=collection_archive---------13-----------------------#2017-10-05">https://medium.com/hackernoon/refactoring-the-hygienic-habit-b2ee0f5528ba?source=collection_archive---------13-----------------------#2017-10-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir"><p id="e1ec" class="is it hu bd iu iv iw ix iy iz ja jb ek translated">通过不断改进代码的设计，我们让工作变得越来越容易——约书亚·克里耶夫斯基，重构模式</p></blockquote><figure class="je jf jg jh ji jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff jd"><img src="../Images/0ea36d3a5fa6df780832875c11c45d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37QdPSQ_r7hYKjOafYipeA.jpeg"/></div></div><figcaption class="jq jr fg fe ff js jt bd b be z ek"><a class="ae jc" href="https://www.pinterest.com/pin/343751384028774338/" rel="noopener ugc nofollow" target="_blank">Pinterest</a></figcaption></figure><p id="77db" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">重构是对现有的、有效的代码进行改进。</p><p id="5cb5" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">好吧，但是“更好”是什么意思？它意味着更好的结构、更好的构建、更好的可读性和更好的理解。</p><p id="94b1" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">您的代码更容易使用，更容易添加新功能，更容易发现和修复错误，更容易扩展和维护，这是一种防止代码逐渐失控的方法。</p><h2 id="1602" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">什么是重构<em class="lm">什么是</em></h2><blockquote class="ln lo lp"><p id="75b4" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">如果你曾经看过一个有点太长的方法，发现其中有几行是属于一起的，就把它们分开放入它们自己的方法中。</p><p id="6545" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">然后用对新方法的调用替换了原始代码。这是一种重构，是提取方法的重构。</p></blockquote><p id="5b7f" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">这是一个小型的 <strong class="jw hv">技术</strong>的<strong class="jw hv">集合</strong>，用于改进已经存在的代码。这段代码已经写好了，并且已经在运行了。我们没有改变它的功能。</p><p id="e17d" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">这些单独的技术，每一个都是一个单独的重构技术，它们通常很小，每一个都处理一个特定的常见问题。</p><p id="396c" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">不存在任何人都可以遵循的一套规则或特定的顺序。但是有一套技术可以帮助你重构代码。</p><figure class="lv lw lx ly fq jj fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/85e0bac2c99f7d30ef192b1c475aa4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*4JV5NUv3wpfbJVVTPsTEGQ.png"/></div><figcaption class="jq jr fg fe ff js jt bd b be z ek">Extract Method Refactoring — <a class="ae jc" href="https://refactoring.guru/extract-method" rel="noopener ugc nofollow" target="_blank">refactoring.guru</a></figcaption></figure><p id="aaf8" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">现在，如果你已经写了一段时间的代码，你几乎已经做了一些。但是使用<strong class="jw hv">形式重构技术</strong>，<strong class="jw hv">给决策</strong>带来了更多的自觉意识。</p><p id="159d" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">它不会取代你的直觉，但它会给你更多的问题去问:</p><ol class=""><li id="f2aa" class="lz ma hu jw b jx jy kb kc kf mb kj mc kn md jb me mf mg mh dt translated">如果你试图拆分一些代码，你真正应该寻找什么？</li><li id="b548" class="lz ma hu jw b jx mi kb mj kf mk kj ml kn mm jb me mf mg mh dt translated">当局部变量和非局部变量混合时你会怎么做？</li><li id="d7fb" class="lz ma hu jw b jx mi kb mj kf mk kj ml kn mm jb me mf mg mh dt translated">有没有什么原因让你不把一些代码拆分成它自己的方法？</li></ol><h2 id="bc1b" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">—技术类别</h2><p id="5f32" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">思考重构技术的一个有用的方法是理解它们可以根据它们操作的代码的不同层次被分成几个类别。</p><p id="fe47" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">他们中的一些人关心的是<strong class="jw hv">个体方法</strong>本身，而不是担心类层次或设计模式。</p><p id="857c" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">然后，我们从更高的角度进行重构。我们仍然<strong class="jw hv">在研究这个方法，但是</strong>现在对我们的类更加<strong class="jw hv">了解了。这个方法在正确的类中吗？。</strong></p><p id="9e69" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">而且，我们可以上升到另一个抽象层次，不要太关注方法，而是更多地关注不同类之间的<strong class="jw hv">通信。<em class="lq">A类似乎除了使用B类的方法和属性之外什么也不做？。</em></strong></p><p id="1efd" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">我们甚至更上一层楼。在<strong class="jw hv">面向对象的应用程序中，有一些技术确实大放异彩。我们应该使用更多的继承和多态还是更少的继承和多态？。</strong></p><blockquote class="ln lo lp"><p id="63c7" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">您将看到几个重构<strong class="jw hv">看起来是彼此</strong>的精确逆。一种重构技术被称为“添加参数”，但另一种被称为“移除参数”。</p><p id="ccfc" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">毕竟，完全可以理解的是，你需要的技术有时是另一种技术的对立面。</p></blockquote><h2 id="a9a0" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated"><em class="lm">什么重构不是</em></h2><p id="e64d" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">重构是<strong class="jw hv"> <em class="lq">不是</em>调试</strong>。</p><p id="fd27" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">你的代码已经需要工作了。这不是发现bug的方法，你应该在bug发生的时候就修复它。</p><p id="0247" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">所以，这是真的，<strong class="jw hv">在</strong>重构的过程中<strong class="jw hv">你可能会发现bug</strong>。但是当你开始处理这个问题的时候。你已经停止了重构，你已经开始修复错误，这是一种非常不同的心态。</p><p id="d6f3" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">重构是<strong class="jw hv"> <em class="lq">而不是</em>的表现</strong>。</p><p id="45ca" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">这是另一个非常普遍的误解，即我们清理代码会使它更快。</p><p id="2f66" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">不，代码性能不是重构的目标，甚至也不是期望。<strong class="jw hv">但是，我们的表现是！</strong>。我们将能够更快地阅读和理解代码。不仅仅是单独的代码片段，而是更大的应用程序。</p><p id="4357" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated"><strong class="jw hv">重构是<em class="lq">而不是</em>增加功能</strong></p><p id="c399" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">如果在这个过程中你添加了一个新的特性，你就不再是重构了。因为在重构中，我们不会改变代码的行为。</p><p id="f518" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">我们可能会在内部做很多事情，创建新的类，将功能从一个地方转移到另一个地方，重命名，重组。但是重构过程的最终结果不会改变代码的可见行为。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="1428" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">因此，之前使用我们应用程序的任何最终用户根本不知道我们做了什么。我们没有修复错误，我们没有让它更快，我们没有增加功能。</p><h2 id="91f5" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">为什么要使用重构</h2><p id="8f13" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">那么，为什么要进行重构呢？</p><p id="cb04" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">好吧，所以，重构<strong class="jw hv">不是</strong>添加功能，重构不是寻找bug，重构不是关于性能，<strong class="jw hv">但是我们简单地重构</strong> <strong class="jw hv">，因为我们想做那些事情</strong>。</p><p id="60e5" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">因为结构良好的代码将使添加新特性和新功能变得更加容易。这将使开始分析性能变得更加容易。因此，我们正在重构，以消除未来的障碍。</p><p id="88b1" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">我们做重构是有原因的。<strong class="jw hv">如果没有理由重构，那就不要做。</strong></p><blockquote class="ln lo lp"><p id="6673" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">如果我们编写了一个应用程序，并且很久都没有使用过。它起作用了，它足够快了。与他们的任何其他系统都没有冲突，也没有需要添加的功能。</p><p id="8176" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">这可能是世界上最丑陋的代码，但是，它不需要重构。因为没有理由这样做。</p></blockquote><p id="9ecc" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">在<strong class="jw hv">团队文化</strong>中，当它不是文化的一部分时，团队通常很难<strong class="jw hv">获得批准</strong>花时间重构，因为好处不会立即显现。</p><p id="f4ea" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">是的，我们没有增加功能，我们没有提高性能，我们没有修复错误，<strong class="jw hv">所以为什么要这么麻烦呢？我们费心是为了能更容易地做这些事情。</strong></p><h2 id="a25a" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">何时使用重构</h2><p id="6103" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">重构<strong class="jw hv">是不是</strong> <strong class="jw hv">不是一个独立的阶段。</strong></p><p id="6adc" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">当你第一次学习重构时，它听起来像是你作为一个独立的阶段做的事情。你写一个应用程序，然后重构它。</p><p id="9f66" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">好吧，如果你有一个混乱的现有代码，你可能需要不时地这样做，但是，目的是你开始一直这样做。</p><p id="71fd" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated"><strong class="jw hv">当你写代码的时候，你可以边写边重构。你写一个新的类或一些新的方法，检查并测试它，然后花几分钟扫描并确保它尽可能地被重构。</strong></p><p id="21d9" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">在团队环境中，学习重构的一个很好的方法是<strong class="jw hv">代码审查或结对编程</strong>。</p><p id="a199" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">把多双眼睛带到同一个代码上。你会发现不同的人发现不同的重构机会。</p><p id="4ebe" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">而且，如果你是一个单独的开发者，你需要更加注意应用个人技术，尤其是那些你不会自然想到的技术。</p><h2 id="3d77" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">如何重构</h2><h1 id="6965" class="mz ks hu bd kt na nb nc kx nd ne nf lb ng nh ni le nj nk nl lh nm nn no lk np dt">⚠ …</h1><blockquote class="ln lo lp"><p id="b195" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">我们不会深入研究每一种重构技术，它试图解决什么问题，以及如何在代码中应用它。其中大部分都很容易理解，你可以在下面的“下一步去哪里”一节中找到它们。从常见的低级技术开始，一直到更多不同的级别。</p></blockquote><h2 id="676d" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">—步骤</h2><p id="b13f" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">首先，<strong class="jw hv">你不需要知道所有的重构，只要开始使用它们</strong>。</p><p id="7fc6" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">事实上，要想学好它们，更实际的做法是挑选一些技巧，并开始积极地应用它们。</p><blockquote class="ln lo lp"><p id="c1b3" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">在学习了这些重构技术之后，你会发现自己很自然地写出了更模块化的代码，更好的面向对象的代码，知道了将一部分功能或一部分数据放在什么地方。</p></blockquote><p id="d47b" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated"><strong class="jw hv">那么，如何开始呢？</strong>从底层开始，较低的级别，基本重构，一路向上。</p><p id="3918" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">比如重命名和提取方法，缩短参数列表，最小化无用的临时变量，让你的条件更容易阅读。</p><p id="05b4" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">所以，当你在看代码的一部分时，<strong class="jw hv">只需要浏览两三遍那部分代码</strong>。</p><p id="9f96" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">你在<strong class="jw hv">T5】而不是T7】寻找的是<strong class="jw hv">，在那里我可以应用<em class="lq"> X </em>重构技术</strong>。</strong></p><p id="c1a1" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">你要寻找的是会引起你注意的<strong class="jw hv">事物</strong>。让这段代码变得难闻的东西。我们用它来作为我们需要改进的指标。<em class="lq">这就是被称为</em> <strong class="jw hv"> <em class="lq">的代码气味。</em>T19】</strong></p><p id="08a2" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">所以，重复的代码，冗长的方法，冗长的参数列表，太多的注释，还有<a class="ae jc" href="https://en.wikipedia.org/wiki/Code_smell#Common_code_smells" rel="noopener ugc nofollow" target="_blank">列表和</a>。</p><p id="ca5c" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">但是，有些代码气味<strong class="jw hv">不是来自扫描</strong>，它们将<strong class="jw hv">需要密切关注</strong>。比如，数据块或下推或上拉方法或字段的地方。</p><blockquote class="ln lo lp"><p id="61d7" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">许多最常见的编程ide，如Visual Studio、Xcode和Eclipse，实际上会帮助您实现许多这些重构技术。</p></blockquote><h2 id="d63f" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">—自动化测试</h2><p id="9f97" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">我们正在改变代码，这带来了风险。</p><p id="3bd0" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">要证明你在重构<strong class="jw hv">时所做的<strong class="jw hv">改变仅仅是你想要的</strong>，最好的方法就是在</strong>之前和之后对你的代码<strong class="jw hv">运行一组<strong class="jw hv">自动化单元测试</strong>。</strong></p><p id="c29e" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">自动化测试可以使用类似Java中Jnit的测试框架来完成。</p><blockquote class="ln lo lp"><p id="8970" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">自动化测试一直到测试驱动开发或行为驱动开发策略都是对重构的极大补充。</p></blockquote><h2 id="fb57" class="kr ks hu bd kt ku kv kw kx ky kz la lb kf lc ld le kj lf lg lh kn li lj lk ll dt translated">接下来去哪里</h2><p id="9403" class="pw-post-body-paragraph ju jv hu jw b jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq jb hn dt translated">当你对一套重构感到满意，并且想更进一步探索更多的时候，那么你的资源绝对应该包括马丁福勒的<strong class="jw hv"/><a class="ae jc" href="https://martinfowler.com/books/refactoring.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw hv">重构改进现有代码的设计</strong> </a> <strong class="jw hv">】。</strong></p><blockquote class="ln lo lp"><p id="14ed" class="ju jv lq jw b jx jy jz ka kb kc kd ke lr kg kh ki ls kk kl km lt ko kp kq jb hn dt translated">这本书不打算从头到尾读一遍。大部分是重构的目录。所以与其说是教程，不如说是参考。</p></blockquote><p id="7bbe" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">refactoring.guru的<strong class="jw hv"/><a class="ae jc" href="https://refactoring.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jw hv"/></a><strong class="jw hv"/>(与马丁·福勒的书相关)和<a class="ae jc" href="https://refactoring.guru/refactoring" rel="noopener ugc nofollow" target="_blank"><strong class="jw hv">refactoring . guru</strong></a><strong class="jw hv"/>网站都有简短的摘要，并附有代码示例。</p><p id="465a" class="pw-post-body-paragraph ju jv hu jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq jb hn dt translated">随着你越来越熟悉，你可能还想在你的平台或环境中寻找关于重构的资源。原理完全一样。但是经常会有<strong class="jw hv">平台特定的提示和窍门</strong>。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><blockquote class="ir"><p id="108f" class="is it hu bd iu iv nq nr ns nt nu jb ek translated">感谢阅读！如果你喜欢这篇文章，你能点击👏按钮？很有帮助！</p></blockquote></div></div>    
</body>
</html>