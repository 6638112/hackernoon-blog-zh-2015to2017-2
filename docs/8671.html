<html>
<head>
<title>Wrestling With Blockchain Scalability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与区块链可扩展性角力</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/wrestling-with-blockchain-scalability-a1295e47962f?source=collection_archive---------9-----------------------#2017-12-10">https://medium.com/hackernoon/wrestling-with-blockchain-scalability-a1295e47962f?source=collection_archive---------9-----------------------#2017-12-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d726" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">安德鲁·巴里瑟</p><p id="0e37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一直在纠结如何扩大区块链科技的规模。这是房间里所有围绕加密货币的兴奋的大象；可伸缩性问题没有解决。最有前景的解决方案闪电网络(lightning networks)未经证实，似乎依赖于可疑的担保，例如在链上赎回集合资金的能力。它还引入了具有潜在集中化动态的轴辐式模型。这是可行的。我不知道。但是我们不应该满足。</p><p id="85b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，可扩展性问题是限制我对区块链技术感兴趣的主要原因。八年来，我们进展甚微。除了闪电网络之外，唯一的进展就是对块大小和高度膨胀的网络(以太坊)的争论。</p><p id="28b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个在可伸缩性问题上做了真正有趣尝试的团队是IOTA。它们的缠结可以支持潜在的无限容量；事实上，它随着使用而增强。然而，它目前是一个通过使用“协调者”节点的集中式系统。Iota纠结背后的想法耐人寻味；您应该检查一下，因为它将挑战您关于A)可验证性和B)可伸缩性的假设。但是使用协调器节点只是欺骗，破坏了系统的可信度。他们声称最终会回滚。但在那之前，它不是一个有效的、分散的系统。无论如何都要去看看。</p><p id="cc1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我对处理区块链可扩展性的选项太少感到不满。可伸缩性是至关重要的，因为分散的、不可信的系统的真正应用是在机器之间。机器需要在不可信的环境下高频通信；这是区块链真正的未来:机器与机器的协调。不受可扩展性限制的区块链可以驱动数十亿台机器进行大规模数据交换。</p><h2 id="117f" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated"><strong class="ak">老双花问题</strong></h2><p id="2df5" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">比特币区块链就是为了解决双花问题而发明的。交易背后的加密技术并不新鲜。事务内部的语义并不特别新颖。但是对于不受约束的事务，必须在事务之间建立一个<em class="kp">优先顺序</em>，以确定哪些事务在历史上<em class="kp">有效。可能有任意多的<em class="kp">语法上</em>有效的交易，即A发送1个比特币给B，或者A发送给C，或者A发送给D；根据交易的语法，所有这些都是有效的。但是对于任何给定的硬币，历史上只有1是有效的。为了建立优先顺序，我们必须使事件的顺序在数学上不证自明；区块链解决了这个问题。</em></p><p id="a427" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">如何在现有区块链中排除重复支出</strong></p><p id="9198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们来解构这个问题，通过调查到底需要什么才能知道一个交易是有效的，与传统的区块链，如比特币。我们不需要描述完整的协议，只需要知道(不可信地)我收到的特定交易没有被其他人重复花费。</p><ul class=""><li id="8c94" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">在比特币区块中发布交易。</li><li id="70b2" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">我验证了事务在内部是一致的。</li><li id="dbff" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">我验证块解决方案和标题。我还确定这是最长的嵌段分支，即主链。用一个轻便的钱包，我可以只验证比特币块头。这只能给予部分信任，因为它不排除矿工们对我撒谎的可能性，但它确实验证了工作证明算法。</li><li id="15e5" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">我验证了事务属于发布的块(通过检查块的merkle根)。</li><li id="266f" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">我对每个单独的块重复上述过程。</li><li id="7839" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">我为整个地址空间和整个历史中所有未用完的比特币输出建立了一个全局状态。对于每个块，我必须处理并保留整个全局状态。</li></ul><p id="3d80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是实际<em class="kp"> bare </em>验证一笔交易的最低限度是检查输入的有效性。每一个比特币输入都是前一次交易的输出，或者说是挖矿块奖励。因此，为了验证给定的输入，我必须做两件事之一:</p><ul class=""><li id="0927" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">始终维护全局状态，以确保正确性(在任何地方)。</li></ul><p id="0d31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者</p><ul class=""><li id="fbc8" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">只验证我要验证的事务中的事务。只有那些需要是有效的。理论上，我可以回溯交易，直到我发现它们的源头是大宗奖励。</li><li id="2204" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">问题#1是，由于输入可能在事务中合并，当我回溯时，我必须跟踪的输入数量呈指数增长。</li><li id="a552" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">问题#2，更严重的一个，是我必须检查<em class="kp">整个块</em>到<em class="kp">，排除我已经考虑的交易输入的</em>重复花费的存在。换句话说，<strong class="it hv"> <em class="kp">为了排除重复花费，我必须对所有交易有一个全局的看法。</em>T11】</strong></li></ul><p id="cefc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这才是问题的关键。要知道一项投入是有效的，我必须排除它已被用于其他地方的可能性。要排除某个事物的存在，我必须对所有事物有全局观。问题是，重复花费一项投入的交易可能在任何地方，因此我必须到处寻找。据我所知，这是区块链可扩展性问题的根源。</p><p id="cf79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果有某种方法来排除双重花费的存在，而不检查整个块并维护全局状态，会怎么样呢？如果只有一个地方可以找呢？如果消费交易只能在一个地方有效会怎样？</p><h2 id="e197" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">硬币树</h2><p id="416b" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">我一直在纠结一个不同的想法，在这个想法中，只有一个地方可以去寻找。不需要排除重复花费的存在，因此需要一个全局的观点，将只有<em class="kp">一个语法上有效的地方来改变特定硬币的状态</em>。因此，根据定义，只有一个地方可以寻找。</p><h2 id="66c2" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">无限时间戳</h2><p id="7a98" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">通过引用块发布的merkle根的“Merkle路径”,可以演示几乎无限数量的数据点的时间戳。彼得·托德在许多演讲中称之为出版证明。演示证明基本上是免费的，并且不受现有区块链理工大学的限制。这应该让你暂停；这暗示着更多的可能性。</p><h2 id="60d8" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">出版证明树中的地址空间</h2><p id="82d9" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">出版证明的工作范围几乎是无限的。我们可以在出版证明Merkle树的叶子中创建一个<em class="kp">地址空间</em>，其中每个唯一的叶子都有一个唯一的标识符。这直接对应于从Merkle根到该叶的Merkle路径中的左和右的二进制表示。这都是众所周知的密码学。</p><figure class="lf lg lh li fq lj fe ff paragraph-image"><div class="fe ff le"><img src="../Images/fdaeaa71c0a538f28efe818bd3dc91da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*xCpzjkZmMVO0_WPlGi0eZQ.png"/></div><figcaption class="lm ln fg fe ff lo lp bd b be z ek">Non-Interactive Zero-Knowledge Proofs of Non-Membership, Olivier Blazy, Celine Chevalier, Damien Vergnaud</figcaption></figure><p id="0f45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了表示给定的不可分割令牌的事务，我可以提供两件事情:该令牌的一组有效事务，包括所有的权利所有权签名，以及一系列这些事务随时间的发布证明。验证将以下列方式进行:</p><ul class=""><li id="9d2d" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">验证所有块标题</li><li id="89bf" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">每个令牌传输都由一个事务和相关的发布证明来表示。后一项是一个Merkle路径，从我的事务的散列指向一个发布的历史块中的一个发布的Merkle根。这证明了时间戳。</li></ul><p id="6392" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上述方法的优点是不需要对事件有一个全局的看法。只有一个地方可以查看，即对应于所考虑的特定令牌的Merkle树的叶节点。没有其他位置是有效的，因此我不需要排除它们。</p><h2 id="66a4" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">问题是</h2><p id="9ea1" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">以上工作解决了一个重大问题。我称之为“胡言乱语攻击”。如果一个miner只是发布一个merkle root，其中包含与我的令牌的有效事务事件不对应的节点，那该怎么办？问题在于:</p><ul class=""><li id="eebe" class="kq kr hu it b iu iv iy iz jc ks jg kt jk ku jo kv kw kx ky dt translated">我拥有我所有有效历史交易的出版证明</li><li id="4300" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">这些证明很简洁，不需要查看块中的所有事务，也不需要查看其他地址或其他令牌。</li><li id="1022" class="kq kr hu it b iu kz iy la jc lb jg lc jk ld jo kv kw kx ky dt translated">然而，我<strong class="it hv"> <em class="kp">不</em> </strong>拥有我未进行交易的块中未发布的证明。</li></ul><p id="4e69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可能会遇到如下问题:我可以简洁地证明，在块#10处，一个令牌被发送给我，其中包含一个有效的事务。我可以证明我发布了一个交易，在第25块把硬币发给你。我还可以证明，在第10块和第25块中，发布的事务是接收者需要检查的唯一事务。但是我<em class="kp">不能</em>证明<em class="kp">在第11-24块之间没有</em>花费那枚硬币的交易。</p><p id="d846" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在上面的例子中，对于第11-24块，我看到了一连串的Merkle根。但是我甚至不能辨别它们是否有效。</p><h1 id="4ecf" class="lq jq hu bd jr lr ls lt jv lu lv lw jz lx ly lz kc ma mb mc kf md me mf ki mg dt translated">潜在的解决方案</h1><p id="3d6c" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">上述问题并没有真正解决。虽然我认为基于出版证明的方案展示了有趣的特性，但它们本身是不够的。</p><p id="1df2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下解决方案是推测性的。</p><h2 id="2826" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">签名的非成员证明</h2><p id="deb1" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">为了处理上述问题，我需要证明，在不需要验证整个区块的情况下，我在区块#10收到的硬币在中间区块11-24期间从未花费。如果有一种简洁的方法来证明一个大集合中的某个值不属于某个成员，那么我们就可以解决这个问题。我们可以将转账交易签名分解成几个部分。输入签名的组成部分之一可以是固定的不变量，其应该在所有块中保持相同，但是除了签名者之外的所有人都不知道，直到花费发生。我们可以修改协议，要求两件事:如上所述，在merkle树中证明交易的发布，同时在单独的数据结构中“显示”支出签名。</p><p id="d7e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，举例来说，如果有某种方法以某种方式揭示N个字符串(其中N是大的),以提供一些简洁的证明P，从而证明N在P中存在或不存在是微不足道的，那么我们将解决这个问题。在我们上面的例子中，你会在第10和25区收到我的出版证明，以及签名的转让交易。您还可以验证块10和25中使用的签名是否存在。最后，你将检查来自第11-24块的证明，对于其中的每一个，<em class="kp">证明来自第10块的签名从未在任何这些块中出现过</em>。如果这个证明能够简洁地完成，我们就完成了。</p><p id="391b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以上不知道怎么实现，但这是我正在思考的事情。如果你知道一个解决方法，请让我知道。</p><h2 id="3025" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">zk-SNARKS证明树</h2><p id="0cac" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">一种更加投机的方法是使用零知识SNARK证明的递归树。假设我有一系列真断言N，我可以为每个断言创建一个zkSNARK，形成一组N个证明。zk-SNARK验证算法本身就是一个可验证的断言。因此，我可以构建一棵树，在这棵树里，我最初的断言和它们的证明就像树叶一样位于底部。每个父节点都是另一个zkSNARK证明，证明其子节点zkSNARKS是有效的。zkSNARK验证简洁明了。我们最终形成一个根节点。这个节点递归地证明了树中的所有语句都是真的，即使它们是未知的。我们想要创建的是一个方案，其中我们可以做两件事:通过Merkle路径提供发布证明，但也证明这个树中的所有内容都是正确的，即使我不知道这个树中的所有内容。</p><p id="0b48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面的目的是简明地证明一个挖掘者没有在出版证明Merkle树中填充垃圾，也就是所谓的“胡言乱语攻击”。如果我们能够做到这一点，就不需要其他核查方案。</p><h2 id="cc58" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">最后</h2><p id="7817" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">最后，我一直在努力思考一些方案，在这些方案中，不需要网络的全局状态来验证单个输入事务的正确性。我相信这是可伸缩性的关键。出版证明几乎无限的可伸缩性表明，这种效果是可能的。</p><p id="7820" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">任何上述方案的一个限制是，即使可以找到防篡改算法，挖掘者也必须将所有信息聚集在一个块中，以构建必要的Merkle树、证明等。这引入了它自己的可伸缩性问题，尽管比当前的最新技术要有利得多</p><h2 id="5bce" class="jp jq hu bd jr js jt ju jv jw jx jy jz jc ka kb kc jg kd ke kf jk kg kh ki kj dt translated">反馈、想法和纠正</h2><p id="a9ac" class="pw-post-body-paragraph ir is hu it b iu kk iw ix iy kl ja jb jc km je jf jg kn ji jj jk ko jm jn jo hn dt translated">所有这些想法都还不成熟。如果有任何明显的缺陷，或改进，或任何其他有用的意见，请让我知道。</p><p id="ce91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">推特:【https://twitter.com/abarisser T2】</p></div></div>    
</body>
</html>