<html>
<head>
<title>Handling errors in gRPC and go-kit services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理gRPC和go-kit服务中的错误</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/handling-errors-in-golang-grpc-and-go-kit-services-d0fa0a112449?source=collection_archive---------6-----------------------#2017-11-02">https://medium.com/hackernoon/handling-errors-in-golang-grpc-and-go-kit-services-d0fa0a112449?source=collection_archive---------6-----------------------#2017-11-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/87b0973e9af1ccdb50f32adb6469f3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ccuxKW-yUILVqqvpmBb-A.png"/></div></div></figure><div class=""/><p id="a95b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您查找如何处理gRPC/go-kit服务中的自定义错误，您可能会发现一些粗略的说明，但没有系统。这是一个令人沮丧的遗漏，因为自定义错误在Go项目中是有用且常见的。这是我的尝试。</p><ol class=""><li id="27dd" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">在protobuf中定义一条错误消息，包含服务内部和服务之间所需的字段/数据。</li><li id="31a9" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">为生成的错误实现Go的错误接口，这样它就可以像Go中的其他错误一样被传递。</li><li id="34e4" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">支持堆栈跟踪，以便您可以看到错误的来源并了解它是如何产生的。</li><li id="039e" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">在响应的字段中响应错误，从而向其他服务公开错误。</li></ol><h1 id="4b6f" class="ko kp if bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">在protobuf中定义一个有用的错误消息</h1><p id="2d42" class="pw-post-body-paragraph jc jd if je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">什么是有用的错误？首先，我们的错误需要一条类似“找不到用户”的消息和一个类似404的代码。此外，嵌套错误适用于验证之类的情况，在这种情况下，错误由下属组成，消息可能类似于带有嵌套错误的“无效用户”{“email”:“必须设置”，“<a class="ae lr" href="https://hackernoon.com/tagged/password" rel="noopener ugc nofollow" target="_blank">密码</a>”:“必须更强”}。一段字符串用于捕捉所有其他细节——例如，如果您想要一个本地化的、面向用户的消息；把它放在细节里。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="13ea" class="mb kp if lx b fv mc md l me mf">// example.proto<br/><br/>message Error {<br/>  string message = 1;<br/>  int32 code = 2;<br/>  map&lt;string, string&gt; nested_errors = 3;<br/>  repeated string details = 4;<br/>  bytes stack = 5 [(gogoproto.customtype) = "Stack"];<br/>}</span></pre><h1 id="6058" class="ko kp if bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">实现错误接口</h1><p id="2b95" class="pw-post-body-paragraph jc jd if je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">通过实现error接口，您可以像处理writing Go中的任何其他错误一样传递和使用错误。您将希望您的函数也将您的自定义错误作为错误接口返回，否则您将遇到这种令人困惑的行为:<a class="ae lr" href="https://golang.org/doc/faq#nil_error" rel="noopener ugc nofollow" target="_blank">为什么我的nil错误值不等于nil？</a></p><blockquote class="mg mh mi"><p id="1821" class="jc jd mj je b jf jg jh ji jj jk jl jm mk jo jp jq ml js jt ju mm jw jx jy jz hn dt translated">对于返回错误的函数来说，最好总是在它们的签名中使用<code class="eh mn mo mp lx b">error</code>类型(就像我们上面做的那样),而不是一个具体的类型，比如<code class="eh mn mo mp lx b">*MyError</code>,以帮助保证错误被正确地创建。作为一个例子，<code class="eh mn mo mp lx b"><a class="ae lr" href="https://golang.org/pkg/os/#Open" rel="noopener ugc nofollow" target="_blank">os.Open</a></code>返回一个<code class="eh mn mo mp lx b">error</code>，即使如果不是<code class="eh mn mo mp lx b">nil</code>，它总是具体类型<code class="eh mn mo mp lx b"><a class="ae lr" href="https://golang.org/pkg/os/#PathError" rel="noopener ugc nofollow" target="_blank">*os.PathError</a></code>。</p></blockquote><p id="d9e7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在网上看过一些意见，大部分来自谷歌阵营，他们认为编译后的protobuf代码应该与你自己手写的代码分开保存，这样这个API就不可能在Go中使用。相反，您应该在protobuf中定义一个错误，在您的代码中定义一个错误，并根据需要将它们相互转换。但是在实践中，手写代码和protobufs一起并没有造成问题，并且有利于像这样的API和其他有用的API，比如用于通常检索的嵌套字段的getters。所以我说继续吧。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="23c2" class="mb kp if lx b fv mc md l me mf">// error.go<br/><br/>// assert Error implements the error interface.<br/>var _ error = &amp;Error{}<br/><br/>// Error implements the error interface.<br/>func (e *Error) Error() string {<br/>	b := new(bytes.Buffer)<br/>	e.printStack(b)<br/>	pad(b, ": ")<br/>	b.WriteString(e.Message)<br/>	if b.Len() == 0 {<br/>		return "no error"<br/>	}<br/>	return b.String()<br/>}</span></pre><h1 id="b9b7" class="ko kp if bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">支持堆栈跟踪</h1><p id="118e" class="pw-post-body-paragraph jc jd if je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">堆栈跟踪可以很容易地找到错误的来源，并了解它们是如何产生的。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="fa71" class="mb kp if lx b fv mc md l me mf">/path/main.go:20: github.com/travisjeffery/example.c:<br/>	/path/main.go:16: ...b:<br/>	/path/main.go:12: ...a: shit's on fire, yo</span></pre><p id="4af2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我使用gogo的protobuf分支来添加自定义类型的堆栈字段，官方的<a class="ae lr" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a> protobuf不支持这种类型。公共字段很烦人，我不希望它的内容被封送/解封——前者我无能为力，因为protobuf对私有字段很恼火，后者我可以通过实现nop的封送器/解封器接口来解决。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="f50d" class="mb kp if lx b fv mc md l me mf">// stack.go<br/><br/>type Stack struct {<br/>	Callers []uintptr<br/>}<br/><br/>func (t Stack) Marshal() ([]byte, error) {<br/>	return nil, nil<br/>}<br/><br/>func (t *Stack) MarshalTo(data []byte) (n int, err error) {<br/>	return 0, nil<br/>}<br/><br/>func (t *Stack) Unmarshal(data []byte) error {<br/>	return nil<br/>}<br/><br/>func (t Stack) MarshalJSON() ([]byte, error) {<br/>	return []byte(`null`), nil<br/>}<br/><br/>func (t *Stack) UnmarshalJSON(data []byte) error {<br/>	return nil<br/>}<br/><br/>func (t *Stack) Size() int {<br/>	return 0<br/>}</span></pre><p id="58ca" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我从<a class="ae lr" href="https://github.com/upspin/upspin/blob/master/errors/errors.go" rel="noopener ugc nofollow" target="_blank"> upspin </a>那里窃取了<a class="ae lr" href="https://github.com/travisjeffery/grpc-go-kit-error-example/blob/master/error.go#L67-L163" rel="noopener ugc nofollow" target="_blank">填充和打印堆栈跟踪</a>的代码，反正大部分都是这样。当用WrapErr和E函数创建错误并用Error()函数打印错误时，堆栈被填充。如果您想要一个没有堆栈跟踪的错误，那么您可以自己实例化一个。</p><p id="fd23" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WrapErr类似于戴夫·切尼的<a class="ae lr" href="https://github.com/pkg/errors/blob/master/errors.go#L180" rel="noopener ugc nofollow" target="_blank">错误。包装</a>，接受一个错误并用消息包装它。我在代码的最底层使用WrapErr来注释由stdlib或第三方pkg返回的错误。E接受各种类型的参数列表，并实例化相应的错误，例如E(“找不到用户”，404)会将字符串与错误消息匹配，将int与错误代码匹配。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="2699" class="mb kp if lx b fv mc md l me mf">// error.go<br/><br/>// WrapErr returns an Error for the given error and msg.<br/>func WrapErr(err error, msg string) error {<br/>	if err == nil {<br/>		return nil<br/>	}<br/>	e := &amp;Error{Message: fmt.Sprintf("%s: %s", msg, err.Error())}<br/>	e.populateStack()<br/>	return e<br/>}<br/><br/>// E is a useful func for instantiating Errors.<br/>func E(args ...interface{}) error {<br/>	if len(args) == 0 {<br/>		panic("call to E with no arguments")<br/>	}<br/>	e := &amp;Error{}<br/>	b := new(bytes.Buffer)<br/>	for _, arg := range args {<br/>		switch arg := arg.(type) {<br/>		case string:<br/>			pad(b, ": ")<br/>			b.WriteString(arg)<br/>		case int32:<br/>			e.Code = arg<br/>		case int:<br/>			e.Code = int32(arg)<br/>		case error:<br/>			pad(b, ": ")<br/>			b.WriteString(arg.Error())<br/>		}<br/>	}<br/>	e.Message = b.String()<br/>	e.populateStack()<br/>	return e<br/>}</span></pre><h1 id="8ede" class="ko kp if bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">用错误字段响应</h1><p id="a945" class="pw-post-body-paragraph jc jd if je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">通过在每个响应上放置一个错误字段，将错误公开给其他服务。在服务的边缘，即端点，错误的类型被断言并在响应中设置。如果您有一个HTTP服务作为gRPC服务的网关，那么您可以使用RPC的错误代码来设置HTTP响应的状态代码。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="2b29" class="mb kp if lx b fv mc md l me mf">// example.proto<br/><br/>service Users {<br/>  rpc GetUser (GetUserRequest) returns (GetUserResponse) {}<br/>}<br/><br/>message GetUserResponse {<br/>  User user = 1;<br/>  Error error = 2;<br/>}<br/><br/>// endpoints.go<br/><br/>func makeGetUserEndpoint(userService user.Service) endpoint.Endpoint {<br/>    return func(ctx context.Context, request interface{}) (interface{}, error) {<br/>        req := request.(*GetUserRequest)<br/>        user, err := userService.GetUser(req.User)<br/>        if err != nil {<br/>            return &amp;GetUserResponse{Error: err.(*Error)}, nil<br/>        }<br/>        return &amp;GetUserResponse{User: user}, nil<br/>    }<br/>}<br/><br/>// transport.go<br/><br/>r.Methods("GET").Handle("/users/{id}", httptransport.NewServer(<br/>    endpoints.GetUserEndpoint,<br/>    decodeGetUserRequest,<br/>    encodeResponse,<br/>    options...,<br/>))<br/><br/>type errorer interface {<br/>    GetError() *example.Error<br/>}<br/><br/>func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {<br/>    if e, ok := response.(errorer); ok {<br/>        if err := e.GetError(); err != nil {<br/>            w.WriteHeader(int(err.Code))<br/>        }<br/>    }<br/>    w.Header().Set("Content-Type", "application/json; charset=utf-8")<br/>    return json.NewEncoder(w).Encode(response)<br/>}</span></pre><h1 id="42ea" class="ko kp if bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">一起看</h1><p id="b1d5" class="pw-post-body-paragraph jc jd if je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">我已经将一个<a class="ae lr" href="https://github.com/travisjeffery/grpc-go-kit-error-example" rel="noopener ugc nofollow" target="_blank">例子推送到GitHub </a>上，这样你就可以检查所有的东西了。</p><p id="9fbf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个工作流程很棒，但是如果你有更好的意见，我想听听。</p><h1 id="98ef" class="ko kp if bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">为什么不元数据/返回错误给gRPC</h1><p id="78a6" class="pw-post-body-paragraph jc jd if je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hn dt translated">我尝试编写一个API，将错误返回给gRPC，而不是设置在响应中。服务器上的中间件将把错误编码成<a class="ae lr" href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md" rel="noopener ugc nofollow" target="_blank">元数据</a>，客户机上的中间件将解码错误并返回，使gRPC调用完全像本地函数调用一样工作。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="6248" class="mb kp if lx b fv mc md l me mf">// example.proto</span><span id="e1c6" class="mb kp if lx b fv mq md l me mf">service Users {<br/>  rpc GetUser (GetUserRequest) returns (GetUserResponse) {}<br/>}</span><span id="9365" class="mb kp if lx b fv mq md l me mf">message GetUserResponse {<br/>  User user = 1;<br/>  // Error's gone<br/>}</span><span id="c8a8" class="mb kp if lx b fv mq md l me mf">// endpoints.go</span><span id="a930" class="mb kp if lx b fv mq md l me mf">func makeGetUserEndpoint(userService user.Service) endpoint.Endpoint {<br/>    return func(ctx context.Context, request interface{}) (interface{}, error) {<br/>        req := request.(*GetUserRequest)<br/>        user, err := userService.GetUser(req.User)<br/>        if err != nil {<br/>            return nil, err<br/>        }<br/>        return &amp;GetUserResponse{User: user}, nil<br/>    }<br/>}</span><span id="41bb" class="mb kp if lx b fv mq md l me mf">// client.go<br/>resp, err := usersClient.GetUser(ctx, &amp;GetUserRequest{Email: "email@example.com"})<br/>if err != nil {<br/>    ...<br/>}</span></pre><p id="2eee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问题在于<a class="ae lr" href="https://github.com/go-kit/kit/blob/0c52d4024a04395dabac42b65e5825d08d3335df/transport/grpc/server.go#L91-L95" rel="noopener ugc nofollow" target="_blank"> go-kit没有给你机会将错误编码到上下文</a>中。如果您的端点返回一个错误，go-kit将直接将其发送给gRPC，gRPC将只知道获取错误的error()字符串，而忽略其余的数据。不支持这一点的缺点是您的客户端在发出请求时必须检查两个错误，返回的错误和请求错误。我更希望go-kit支持它，但它似乎是<a class="ae lr" href="https://github.com/go-kit/kit/issues/283" rel="noopener ugc nofollow" target="_blank">不会发生。</a></p><p id="856d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">–</p><p id="0059" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请在<a class="ae lr" href="https://twitter.com/travisjeffery" rel="noopener ugc nofollow" target="_blank"> @travisjeffery </a>问好。</p><p id="1921" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">击中要害👏如果你觉得这个有用，分享一下。</p><p id="0420" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">谢谢你的阅读。</p><figure class="ls lt lu lv fq hw"><div class="bz el l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>