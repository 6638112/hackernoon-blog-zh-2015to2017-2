<html>
<head>
<title>Modifying files stored outside of PostgreSQL while maintaining full transaction safety and stateless design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修改存储在PostgreSQL之外的文件，同时保持完全的事务安全性和无状态设计</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/modifying-files-stored-outside-of-postgresql-while-maintaining-full-transaction-safety-and-d8b55327e679?source=collection_archive---------8-----------------------#2017-03-14">https://medium.com/hackernoon/modifying-files-stored-outside-of-postgresql-while-maintaining-full-transaction-safety-and-d8b55327e679?source=collection_archive---------8-----------------------#2017-03-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e576" class="pw-subtitle-paragraph is ht hu bd b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj ek translated">当事情变得<strong class="ak">太大</strong>而无法内联存储在数据库中，但我们仍然想要所有这些有趣的事务安全和读写锁，而不需要构建自己的看门人解决方案时，该怎么办？</h2></div><p id="5e40" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kg">这是一系列文章的一部分，展示了我们如何构建</em> <a class="ae kh" href="https://paw.cloud" rel="noopener ugc nofollow" target="_blank"> <em class="kg"> Paw Cloud </em> </a> <em class="kg">同步后端，以便为团队</em>  <em class="kg">提供既可靠又安全的文档共享服务。之前我写过:</em> <a class="ae kh" href="https://hackernoon.com/aws-as-a-stateless-platform-for-cloud-syncing-services-7afe1908463c#.9wg8cayun" rel="noopener ugc nofollow" target="_blank"> <em class="kg"> AWS作为云同步服务的无状态平台。</em>T19】</a></p><p id="bce1" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们这个系统的主要目标是<a class="ae kh" href="https://hackernoon.com/aws-as-a-stateless-platform-for-cloud-syncing-services-7afe1908463c#.lt7yl1pet" rel="noopener ugc nofollow" target="_blank">确保我们所有服务器的完全无状态操作</a>这包括能够在任何时候断开任何实例，而不会造成任何数据损坏或丢失。因为我们所有的API都包装在事务中，所以我认为我们应该为我们的云同步API做同样的事情。</p><p id="2d3b" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">由于我们选择使用Git的底层C库(<a class="ae kh" href="https://libgit2.github.com/" rel="noopener ugc nofollow" target="_blank"> libgit2 </a>)作为同步云项目的服务器端支持，在PostgreSQL数据库中存储数据并不容易。首先，它会非常昂贵，其次需要对libgit2进行许多定制和相当复杂的改编。因此，出于成本和方便的考虑，将项目存储在亚马逊S3上是有意义的。</p><p id="8907" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在每次交互中从S3加载一个项目(即使在同一个AWS区域内)是很慢的，所以我们希望在加载到后台服务器上时有一个项目当前很热门的概念。由于我们在面向web的服务器上有不止一个Django实例(这些实例位于负载均衡器之后),所以我们需要一种通用的方法来确保即使请求来自不同的面向客户端的API服务器，也不会有并发的读或写操作与同一文档上的写操作同时发生。</p><h2 id="a91c" class="ki kj hu bd kk kl km kn ko kp kq kr ks jt kt ku kv jx kw kx ky kb kz la lb lc dt translated">PostgreSQL <a class="ae kh" href="https://www.postgresql.org/docs/current/static/explicit-locking.html" rel="noopener ugc nofollow" target="_blank">行锁</a>来拯救！</h2><p id="d248" class="pw-post-body-paragraph jk jl hu jm b jn ld iw jp jq le iz js jt lf jv jw jx lg jz ka kb lh kd ke kf hn dt translated">Postgres让我们显式地获得一个行锁。这个概念让我们可以为Django模型创建一个有用的抽象类，我们可能需要锁。</p><p id="f040" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">PostgreSQL提供了两种行锁:<strong class="jm hv">用于共享</strong>一种<strong class="jm hv">共享</strong>锁，用于读操作，以及<strong class="jm hv">用于更新</strong>一种<strong class="jm hv">独占</strong>锁，用于写操作。可以同时获得多个共享锁，而独占锁不需要同时获得其他锁。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Implementation of an exclusive lock in a Django model. Just add another method to get the shared lock by replacing the <strong class="ak">FOR UPDATE</strong> with <strong class="ak">FOR SHARE </strong>(the the full abstract model <a class="ae kh" href="https://gist.github.com/hishnash/52e5622de571c10f4d5f12368b205620" rel="noopener ugc nofollow" target="_blank">here</a>).</figcaption></figure><p id="baca" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Postgres行锁在当前事务结束之前一直被获取。与咨询锁不同，如果不提交/撤销事务，就无法显式释放它们。</p><p id="9f64" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果锁被另一个事务占用，这些锁也将阻止对相应行的标准更新，因此我们不直接锁定文档行，而是锁定指向文档的<em class="kg"> document_state </em>实体。这是为了让文档周围的正常数据库活动(如重命名权限更改等)不会被行锁阻塞。在<em class="kg"> document_state </em>实体上，我们只保存与同步操作相关的数据，比如版本散列和S3上持久化文件的名称。</p><p id="e768" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有了基于用户交互类型的行锁，我们就可以在动作被发送到worker服务器实例之前获得一个共享锁或一个排他锁，在worker服务器实例中，文档处于<strong class="jm hv"> HOT </strong>状态并准备好被处理。</p><p id="dd8b" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">为了确保我们总是在用户文档的正确版本上工作，对worker微服务的每个API调用都包含从数据库中读取的版本哈希(这被认为是真实的来源)。如果缓存在worker上的文件版本与数据库中的版本不匹配，我们需要从S3重新加载文档的存档。</p><p id="bdf9" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">当用户对项目进行写操作时，工作服务器生成一个新的UUID作为文件名，将更新的档案上传到S3，并将这个文件名和文档散列返回给Django实例。更新后的文件信息保存在项目的<em class="kg"> document_state </em>行(我们获得了排它锁的行)。</p><p id="0ff3" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这确保了如果在任何时候写API调用失败(例如工作服务器在写入过程中关闭)，相应的事务将失败，因此下一组API调用将使用旧版本，因为数据库不会更新版本散列。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Exclusive lock decorator for our API view (<a class="ae kh" href="http://www.django-rest-framework.org" rel="noopener ugc nofollow" target="_blank">django REST framework</a>) . Our shared lock decorator is very much the same just swapping out the <strong class="ak"><em class="ir">get_exclusive_lock</em></strong><em class="ir"> context call as well as some user permissions / logging differences.</em></figcaption></figure><p id="937f" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">项目重装过程是我今天想谈的最后一个方面。因为我们在等待锁时阻塞了一个<a class="ae kh" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank"> Python </a>线程，所以我们需要在一个单独的线程上重新加载，以允许上面描述的重试(第25行)在重新加载后排在队列的第一位。然而，在重载器请求获得另一个锁之前，我们不想释放当前的独占锁(在第21行)。事实上，我们知道项目需要重新加载，所以如果有其他请求进来，它也会失败。因此，我们需要两个独立的线程:一个执行项目的重新加载，另一个监视项目上的所有挂起的锁，并在重新加载器在队列中有一个挂起的锁时发送一条消息，以便主线程可以释放它的锁。这里，在第23行，主线程等待这个消息。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lt"><img src="../Images/73fcb8772a14f42acf6b44483080f982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjDZ0mZtd8M70mMycn2WUA.png"/></div></div><figcaption class="lp lq fg fe ff lr ls bd b be z ek">Flow diagram of the threads and locks used durring an api action. (Some additional Postgres Advisory <a class="ae kh" href="https://www.postgresql.org/docs/current/static/explicit-locking.html#ADVISORY-LOCKS" rel="noopener ugc nofollow" target="_blank"><strong class="bd ma">pg_advisory</strong></a><em class="ir"> locks are used on the Reload thread to ensure only one reload is pending per document)</em></figcaption></figure><p id="feea" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里要注意:由于我们需要Cpython守护线程，我们意识到我们不能对Django实例使用<a class="ae kh" href="https://greenlet.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> greenlet </a>。事实上，greenlet是一个Python库，它通过伪造线程来实现并行操作。在我们实现这个功能之前，我们使用的是Python服务器运行时<a class="ae kh" href="http://gunicorn.org/" rel="noopener ugc nofollow" target="_blank">guni corn</a>——它是基于greenlet的——但是我们需要切换回标准的uWSGI配置。</p><p id="76e6" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在Django中使用可锁定模型的额外好处是使我们的其他管理cronjobs(计费、清理、电子邮件)在Django实例的无状态分布式集群上运行，同时确保单个数据库项不会被多个作业同时处理。例如，当运行我们的计费cronjob时，我们在一个团队数据库实体上获得一个排他锁。这既保护我们免于重复的信用卡费用，也确保团队的数据在计费处理期间不会改变，使得代码更加简单，因为我们不需要检查这种边缘情况。一旦获得了排他锁，就不会在该行上提交其他数据库事务。因此，我们大大降低了我们在计费cronjob中的更新由于冲突而被PostgreSQL拒绝的可能性。</p><p id="e998" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们已经注意到我们系统的一个明显问题，如果我们微服务节点上的任务突然开始花费很长时间，并且我们超时不够快，我们可能会以许多许多并发的<a class="ae kh" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>连接结束。随着API调用越来越频繁地失败，重载过程开始产生失控效应。为了防止这种情况，在调用微服务后端时有一个严格的超时很重要。</p><p id="02e4" class="pw-post-body-paragraph jk jl hu jm b jn jo iw jp jq jr iz js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><em class="kg"> P.S .所有代码片段均在</em> <a class="ae kh" href="https://opensource.org/licenses/MIT" rel="noopener ugc nofollow" target="_blank"> <em class="kg"> MIT许可</em> </a> <em class="kg">下发布。</em></p><div class="li lj lk ll fq ab cb"><figure class="mb lm mc md me mf mg paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mb lm mc md me mf mg paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mb lm mc md me mf mg paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mh mi mj"><p id="f922" class="jk jl kg jm b jn jo iw jp jq jr iz js mk ju jv jw ml jy jz ka mm kc kd ke kf hn dt translated"><a class="ae kh" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kh" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kh" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kh" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jk jl kg jm b jn jo iw jp jq jr iz js mk ju jv jw ml jy jz ka mm kc kd ke kf hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kh" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kh" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff mn"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="mo lo l"/></div></figure></div></div>    
</body>
</html>