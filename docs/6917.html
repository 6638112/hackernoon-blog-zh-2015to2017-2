<html>
<head>
<title>TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以打字打的文件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-first-typescript-demo-905ea095a70f?source=collection_archive---------4-----------------------#2017-10-10">https://medium.com/hackernoon/the-first-typescript-demo-905ea095a70f?source=collection_archive---------4-----------------------#2017-10-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3410" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上周是推出<a class="ae jp" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>的五周年纪念日，我有机会回去拜访<a class="ae jp" href="http://twitter.com/ahejlsberg" rel="noopener ugc nofollow" target="_blank"> Anders </a>和团队，参加每周一次的TypeScript <a class="ae jp" href="https://hackernoon.com/tagged/design" rel="noopener ugc nofollow" target="_blank">设计</a>会议——祝贺他们的里程碑，祝贺他们在我离开团队后的4年里继续用TypeScript取得的令人难以置信的进步。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="9d25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我还利用这个机会翻出了一些我在我们从事TypeScript(当时的代号为Strada)工作的早期所做的TypeScript旧演示，与团队分享。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="5c37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2010年秋天，我和Steve Lucco一起开始了一个项目，帮助应用规模的开发团队管理大型JavaScript代码库。Steve曾经和办公室的几个工程副总裁聊过，他们强调了他们的开发团队在投资于基于web的应用程序和体验时，从C++/C#到JavaScript的快速转变。这些团队错过了C++和C#的类型系统和Visual Studio IDE提供的生产力工具和信心——他们想知道当他们转向JavaScript时我们能做些什么来帮助他们。与此同时，我们看到了更广泛的行业趋势，即快速的JavaScript引擎、HTML5的进步以及几个令人印象深刻的大型web“应用程序”都在快速改变JavaScript在过去几年中在web上的使用方式。</p><p id="91cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">已经有很多选择，但似乎没有一个能引起足够广泛的市场共鸣。在微软内部，<a class="ae jp" href="https://github.com/nikhilk/scriptsharp" rel="noopener ugc nofollow" target="_blank"> Script# </a>被一些大型团队使用。这让他们可以直接使用C#而不是JavaScript，但结果是，当你试图与你真正要编程的运行时模型保持一定距离时，你会遇到阻抗不匹配的问题。还有<a class="ae jp" href="https://developers.google.com/closure/compiler/" rel="noopener ugc nofollow" target="_blank">谷歌的Closure编译器</a>，它提供了一个丰富的类型系统，嵌入在JavaScript代码的注释中，以指导一些高级的缩小过程(同时，捕捉并报告与类型相关的错误)。最后，这是JavaScript生态系统中<a class="ae jp" href="http://coffeescript.org/" rel="noopener ugc nofollow" target="_blank"> CoffeeScript </a>迅速崛起的时间框架——成为第一个被大量使用的trans pile-to-JavaScript语言，并为JavaScript开发工作流中的trans piler铺平了道路。(<em class="ke">先不说</em>——我在早期经常用一个类比“coffee script:TypeScript::Ruby:c#/Java/c++”来解释TypeScript，经常加上——“c#/Java/c++开发人员比Ruby开发人员多50倍:-)”)</p><p id="32d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们很快发现我们想要提供的是这三者交汇处的“最好的”——一种尽可能接近JavaScript语义(如CoffeeScript)和语法(如Closure Compiler)但能够提供类型检查和丰富工具(如Script#)的语言。</p><p id="3f3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在2010年的秋天和冬天开始做这个兼职项目。作为帮助确保我们有东西展示的强制功能，我们在一个小型会议上与来自微软研究和产品团队的编程语言人员签约做了一个内部演示。然而，在演讲的前一个月，史蒂夫(当时该项目的唯一工程师！)手腕受伤，这使得他无法进行任何严肃的编码工作。因此，我不想退出这个话题——我决定拼凑一些东西，让我们能够理解我们试图提供的体验——即使没有实际工作的编译器。(史蒂夫在构建第一个真正的TypeScript编译器后不久就这样做了，这使得我们的第一个内部客户——构建后来成为VS代码的团队——开始真正使用TypeScript)。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="c60d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们在2011年2月1日，在我们团队之外的第一次Strada演示中使用的主要代码。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kf jw l"/></div></figure><p id="ef43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有许多最终成为TypeScript的元素非常突出。</p><ol class=""><li id="41a9" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">第28–30行代码中的隐式类型流，不需要注释。</li><li id="bf49" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">类是能够同时表达类的实现和类型的重要方式——类在普通的JavaScript中很方便，但在TypeScript中更有价值，在TypeScript中，您希望同时描述实现和类型，并且不希望每件事都要说两遍。</li><li id="04e1" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">能够与普通的旧JavaScript代码和库无缝互操作——即使它们还没有相关的类型。</li></ol><p id="39ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是你也可以在这里看到一些我们最终从TypeScript中摆脱的东西。</p><ol class=""><li id="1303" class="kg kh hu it b iu iv iy iz jc ki jg kj jk kk jo kl km kn ko dt translated">这里展示的更“函数式”的类语法是我们真正想要实现的——我刚刚完成了F#的工作，它使用了类似的简化类语法，我们也在同一时间讨论了C#的语法。它也非常适合当时流行的将JavaScript“类”中的状态表示为闭包捕获的状态的风格——而不是像您在ECMAScript中标准化的基于原型的类方法中看到的那样表示为对象属性。在TypeScript公开发布之前的大部分时间里，这是一个有争议的话题ECMAScript类的进展工作正朝着一个不同的方向发展，尽管我们想努力与未来的标准保持一致，但我们并不喜欢在标准方法之上编写TypeScript类的方式(在常见情况下，变量的名称要说四次)。我们最终优先考虑标准一致性——这在当时是一个风险很大的赌注——事先并不清楚ES6最终会比ES4(从未发布)更好——但回想起来，这是TypeScript承诺在JavaScript上保持尽可能薄的层的关键促成因素，即使它从ES3发展到ES5，再到ECMAScript2017及更高版本。</li><li id="dd8f" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">前缀位置的类型——您可以看到类型在上面被指定为<code class="eh ku kv kw kx b">string name</code>,而不是现在TypeScript中的<code class="eh ku kv kw kx b">name: string</code>。我们最初被这种语法所吸引，因为我们对现在被称为<code class="eh ku kv kw kx b">any</code>的类型使用了名称<code class="eh ku kv kw kx b">var</code>，允许对<code class="eh ku kv kw kx b">any</code>的隐式类型化在类似于<code class="eh ku kv kw kx b">var x = ...</code>的语句中有效地显式化。这也类似于不久前在C#中引入<code class="eh ku kv kw kx b">var</code>时所做的工作。但是将一个类型放在语法中的这个位置会导致许多解析问题，类似JavaScript的语言使用了<code class="eh ku kv kw kx b">name: string</code>格式(最著名的是——action script和不再使用的ECMAScript4)。这个很早就改变了——几个月后我得到的代码样本已经使用了<code class="eh ku kv kw kx b">:</code>语法。</li><li id="a7ba" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">我们有C#风格的<code class="eh ku kv kw kx b">class Foo : Bar</code>语法用于超类——我们后来过渡到使用<code class="eh ku kv kw kx b">extends</code>。</li><li id="4458" class="kg kh hu it b iu kp iy kq jc kr jg ks jk kt jo kl km kn ko dt translated">稍微微妙一些——注意代码在<code class="eh ku kv kw kx b">&lt;script type="text/strada"&gt;</code>块中——注释指出<code class="eh ku kv kw kx b">StradaCompiler.js</code>负责动态编译<code class="eh ku kv kw kx b">text/strada</code>块。实际上，我们当时设想您将通过<code class="eh ku kv kw kx b">&lt;script&gt;</code>标签在HTML中直接提供类型脚本代码——而不是有一个单独的构建步骤——并且它将在页面加载时被传输(并且希望被缓存)。这在当时对于小规模CoffeeScript项目来说是一种有点流行的技术，但是当我们与更多更大的开发团队交谈时，我们发现这对于许多/大多数生产工作流来说是不实际的。在实践中，获得这种紧密的开发工作流体验最终由WebPack和类似的运行观察器等工具解决，这些工具动态地重新编译代码，但仍然以编译后的形式呈现给浏览器。</li></ol><p id="581c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但更有趣的是我们如何让这段代码实际工作。</p></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="5bf2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当时我有一个小项目，用F#编写一个JavaScript解释器(作为我从使用F#过渡到使用JavaScript的一个宣泄工具)，其中一部分是一个相当可靠的JavaScript (ES5)解析器。我对语法做了一些修改(令人惊讶地小),以支持我们在Strada中添加的新结构——主要是按照以下思路:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kf jw l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Aside — looks like we had `readonly` in this early version too.</figcaption></figure><p id="473b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我侵入了pretty-printer，将生成的ast作为普通的JavaScipt发出——但是我没有丢弃类型，而是将它们转换成闭包编译器注释。现在，或多或少没有办法使这成为一个健壮的过程——但这对于演示来说已经足够了！</p><p id="9528" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从那里——你猜对了——我们只是在结果代码上调用闭包编译器作为“类型检查器”。Closure Compiler在AppEngine上有一个方便的托管服务(现在<a class="ae jp" href="https://closure-compiler.appspot.com/home" rel="noopener ugc nofollow" target="_blank">仍然有</a>),所以我们只是将漂亮打印的代码发布到那个服务上以获取错误。</p><p id="7543" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也是Silverlight(和Flash)仍然在客户端发挥重要作用的时代。所以为了运行解析器(在F#中实现),我们将它作为Silverlight托管在页面中——它寻找<code class="eh ku kv kw kx b">text/strada</code>脚本，解析它们，将它们发送到Closure并报告错误。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kf jw l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Still a little cringe-inducing seeing this code.</figcaption></figure><p id="e1b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">结果是，当我们在开发人员工具中改变了<code class="eh ku kv kw kx b">&lt;script&gt;</code>标签的内容时，我们可以得到实时的错误报告，给人一种只有后台类型检查器在运行的印象。这成功地演示了我们试图实现的体验的一些关键部分——尽管在实践中，这种方式表明它不可能扩展到甚至单个真实用户😄。</p><p id="a51f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们演示的另一个代码片段。您可以从这里的TypeScript中看到一些更有趣的区别——将<code class="eh ku kv kw kx b">double</code>作为一种类型而不是<code class="eh ku kv kw kx b">number</code>(我们想象我们也可以添加<code class="eh ku kv kw kx b">int</code>——但这使我们远离了JavaScript语义)和接口上的<code class="eh ku kv kw kx b">I</code>前缀作为C#启发的约定——以及一些保留下来的东西，如接口和无缝混合非类型化对象查找和强类型类的能力。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kf jw l"/></div></figure></div><div class="ab cl jx jy hc jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hn ho hp hq hr"><p id="4c30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在第一次演示后一年半多一点，我们推出了TypeScript。在此后的5年里，TypeScript已经成为软件行业中发展最快的编程语言之一。</p><p id="aa5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在从外部来看，我一直对TypeScript团队的能力印象深刻，他们既坚持了作为JavaScript之上的一个薄层的根基，同时又不断发展以应对作为一个类型系统的挑战，该类型系统实际上可以在几乎任何JavaScript代码库上高效地使用。随着新的框架和开发风格在JavaScript生态系统中出现，TypeScript也在设法发展，同时仍然保持专注和平易近人。</p><p id="cfe4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">祝贺团队和TypeScript社区中的每一个人，他们做出了令人难以置信的努力，让这一切成为现实！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lc jw l"/></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">Our JSConf EU 2012 presentation launching TypeScript</figcaption></figure><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="ld jw l"/></div></figure></div></div>    
</body>
</html>