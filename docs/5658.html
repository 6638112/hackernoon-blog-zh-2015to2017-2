<html>
<head>
<title>SICP 1.3.1: “ Formulating Abstractions with Higher-Order Procedures: Procedures as Arguments”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SICP 1.3.1:“用高阶过程制定抽象:作为参数的过程”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sicp-1-3-1-formulating-abstractions-with-higher-order-procedures-procedures-as-arguments-6bdd6be0d43?source=collection_archive---------14-----------------------#2017-08-08">https://medium.com/hackernoon/sicp-1-3-1-formulating-abstractions-with-higher-order-procedures-procedures-as-arguments-6bdd6be0d43?source=collection_archive---------14-----------------------#2017-08-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="7b0a" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">(计算机程序的结构和解释)</h2></div><p id="accd" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的1.3.1习题解答也在Github 上<strong class="jl hv">这里:<a class="ae kf" href="https://github.com/bolducp/SICP/tree/master/exercises/chapter_01/1.3_exercises" rel="noopener ugc nofollow" target="_blank">https://Github . com/bold UCP/SICP/tree/master/exercises/chapter _ 01/1.3 _ exercises</a></strong></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><blockquote class="kn ko kp"><p id="4ff0" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">我们应该对强大的<a class="ae kf" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程语言</a>提出的要求之一是，通过给常见模式命名来构建抽象，然后直接根据抽象进行工作。(第。56)</p></blockquote><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/6b8c1812578fee538d70978cd916abfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*zYNGGLs9_P6Pr5IsQ-3AdA.jpeg"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">image credit: <a class="ae kf" href="http://crossfithorgen.ch/blog/skill-levels/" rel="noopener ugc nofollow" target="_blank">http://crossfithorgen.ch/blog/skill-levels/</a></figcaption></figure><blockquote class="lg"><p id="c5b2" class="lh li hu bd lj lk ll lm ln lo lp ke ek translated">“通常，相同的编程模式将用于许多不同的过程。为了将这种模式表达为概念，我们需要构造能够接受过程作为参数或返回过程作为值的过程。操作过程的过程称为高阶过程。本节将展示高阶过程如何作为强大的抽象机制，极大地增强我们语言的表达能力。”(第56- 57页)</p></blockquote><h1 id="45aa" class="lq lr hu bd ls lt lu lv lw lx ly lz ma ja mb jb mc jd md je me jg mf jh mg mh dt translated">1.3.1:作为参数的过程</h1><p id="6349" class="pw-post-body-paragraph jj jk hu jl b jm mi iv jo jp mj iy jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">本节首先提供了三个处理各种数据集合(例如特定序列中的整数、立方、分数)求和的过程示例，并指出所有过程中的相似逻辑，而不管累积的项目类型如何。这引出了对求和的一般概念的讨论，借助于一个普通求和<a class="ae kf" href="https://hackernoon.com/tagged/procedure" rel="noopener ugc nofollow" target="_blank">过程</a>的例子，该过程从三个原始函数中抽象出重复的逻辑，并提供变量部分作为自变量。</p><blockquote class="kn ko kp"><p id="4ac8" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">这种常见模式的存在是一个强有力的证据，表明有一个有用的抽象正等待被呈现出来。(第。58)</p></blockquote><h1 id="16bf" class="lq lr hu bd ls lt lu lv lw lx ly lz ma ja mn jb mc jd mo je me jg mp jh mg mh dt translated">练习</h1><p id="8b4b" class="pw-post-body-paragraph jj jk hu jl b jm mi iv jo jp mj iy jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">我的答案在每个练习题下面的灰色文本块中提供。</p><h2 id="b36b" class="mq lr hu bd ls mr ms mt lw mu mv mw ma js mx my mc jw mz na me ka nb nc mg nd dt translated">练习1.29</h2><blockquote class="kn ko kp"><p id="2f76" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">辛普森法则是一种比上述方法更精确的数值积分方法。使用辛普森法则，函数<em class="hu"> f </em>在<em class="hu"> a </em>和<em class="hu"> b </em>之间的积分近似为</p><p id="0a76" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">h/3[y0+4 y1+2 y2+4 y3+2 y4+…+2yn 2+4yn 1+yn]</p><p id="f982" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">其中，对于某个偶数n，h =(b a)/n，yk=f(a+kh)。(增加<em class="hu"> n </em>会增加近似的精确度。)定义一个过程，将参数<em class="hu"> f </em>、<em class="hu"> a </em>、<em class="hu"> b </em>和<em class="hu"> n </em>作为参数，并返回使用辛普森规则计算的积分值。使用您的程序对0和1之间的立方体进行积分(其中<em class="hu"> n </em> = 100和<em class="hu"> n </em> = 1000)，并将结果与上面显示的积分程序进行比较。</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="fb50" class="mq lr hu nf b fv nj nk l nl nm">(define (simpson f a b n)<br/>  (define h (/ (- b a) n))<br/>  (define (yk k)<br/>    (f (+ (* k h) a)))<br/>  (define (term x)<br/>    (* (cond ((= x 0) 1)<br/>             ((= x n) 1)<br/>             ((even? x) 2)<br/>             (else 4))<br/>       (yk x)))<br/>  (* (/ h 3)(sum term 0 inc n)))</span><span id="76c9" class="mq lr hu nf b fv nn nk l nl nm">(simpson cube 0 1 100.0)  ; .24999999999999992<br/>(integral cube 0 1 0.01)  ; .24998750000000042</span><span id="7afd" class="mq lr hu nf b fv nn nk l nl nm">(simpson cube 0 1 1000.0)  ; .2500000000000003<br/>(integral cube 0 1 0.001) ; .249999875000001</span></pre><h2 id="ceb5" class="mq lr hu bd ls mr ms mt lw mu mv mw ma js mx my mc jw mz na me ka nb nc mg nd dt translated"><strong class="ak">练习1.30 </strong></h2><blockquote class="kn ko kp"><p id="06a0" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">上面的求和过程产生一个线性递归。可以重写该过程，以便迭代地执行求和。通过填写以下定义中缺少的表达式来说明如何做到这一点:</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="8f29" class="mq lr hu nf b fv nj nk l nl nm">(define (sum term a next b)<br/>  (define (iter a result)<br/>    (if &lt;??&gt;<br/>        &lt;??&gt;<br/>        (iter &lt;??&gt; &lt;??&gt;)))<br/>  (iter &lt;??&gt; &lt;??&gt;))</span><span id="3ca8" class="mq lr hu nf b fv nn nk l nl nm"><br/>(define (sum-recursive term a next b)<br/>  (if (&gt; a b)<br/>      0<br/>      (+ (term a)<br/>         (sum-recursive term (next a) next b))))</span><span id="ef80" class="mq lr hu nf b fv nn nk l nl nm">(define (sum term a next b)<br/>  (define (iter a result)<br/>    (if (&gt; a b)<br/>        result<br/>        (iter (next a)(+ (term a) result))))<br/>  (iter (term a) 0))</span><span id="867f" class="mq lr hu nf b fv nn nk l nl nm">; testing:</span><span id="6962" class="mq lr hu nf b fv nn nk l nl nm">(define (inc n) (+ n 1))</span><span id="2354" class="mq lr hu nf b fv nn nk l nl nm">(define (identity x) x)</span><span id="aba0" class="mq lr hu nf b fv nn nk l nl nm">(define (sum-integers a b)<br/>  (sum identity a inc b))</span><span id="7864" class="mq lr hu nf b fv nn nk l nl nm">(sum-integers 1 10) ; 55</span></pre><h2 id="6142" class="mq lr hu bd ls mr ms mt lw mu mv mw ma js mx my mc jw mz na me ka nb nc mg nd dt translated"><strong class="ak">练习1.31 </strong></h2><blockquote class="kn ko kp"><p id="7de4" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">sum过程只是大量类似抽象中最简单的一个，这些抽象可以作为高阶过程来捕获。编写一个名为product的类似程序，返回给定范围内各点函数值的乘积。尝试递归和迭代方法。展示如何根据乘积定义阶乘。也用乘积来计算使用公式的近似值:π/4=(2⋅4⋅4⋅6⋅6⋅8…)/(3⋅3⋅5⋅5⋅7⋅7…)</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="8e9f" class="mq lr hu nf b fv nj nk l nl nm">(define (inc n) (+ n 1))</span><span id="874b" class="mq lr hu nf b fv nn nk l nl nm">(define (identity x) x)</span><span id="3c2c" class="mq lr hu nf b fv nn nk l nl nm">; recursive<br/>(define (product term a next b)<br/>  (if (&gt; a b)<br/>      1<br/>      (* (term a)<br/>         (product term (next a) next b))))</span><span id="7350" class="mq lr hu nf b fv nn nk l nl nm">; iterative<br/> (define (product-iter term a next b)<br/>   (define (iter a result)<br/>     (if (&gt; a b)<br/>         result<br/>         (iter (next a)(* (term a) result))))<br/>   (iter (term a) 1))</span><span id="9683" class="mq lr hu nf b fv nn nk l nl nm">; factorial</span><span id="2f9b" class="mq lr hu nf b fv nn nk l nl nm">(define (factorial n)<br/>  (product-iter identity 1 inc n))</span><span id="c8fc" class="mq lr hu nf b fv nn nk l nl nm">; testing<br/>(factorial 0)<br/>(factorial 1)<br/>(factorial 2)<br/>(factorial 3)<br/>(factorial 6)</span><span id="fb6e" class="mq lr hu nf b fv nn nk l nl nm">; π/4 = (2⋅4⋅4⋅6⋅6⋅8...) / (3⋅3⋅5⋅5⋅7⋅7...)</span><span id="07f2" class="mq lr hu nf b fv nn nk l nl nm">(define (pi-product n)<br/>  (define (term x)<br/>     (if (even? x)<br/>         (/ (+ x 2) (+ x 1))<br/>         (/ (+ x 1) (+ x 2))))<br/>  (product-iter term 1 inc n))</span><span id="fb98" class="mq lr hu nf b fv nn nk l nl nm">(pi-product 4)</span></pre><h2 id="8be8" class="mq lr hu bd ls mr ms mt lw mu mv mw ma js mx my mc jw mz na me ka nb nc mg nd dt translated">练习1.32</h2><blockquote class="kn ko kp"><p id="143f" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">展示sum和product(练习1.31)都是更一般的概念accumulate的特例，accumulate使用一些一般的累加函数来组合一组术语:</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="7cf7" class="mq lr hu nf b fv nj nk l nl nm">(accumulate combiner null-value term a next b)</span></pre><blockquote class="kn ko kp"><p id="5290" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">Accumulate将与sum和product相同的项和范围规格作为参数，以及一个组合器过程(两个参数),该过程指定当前项如何与前面项的累积相组合，以及一个空值，该空值指定当项用完时要使用的基值。编写accumulate并演示sum和product如何都可以定义为简单的accumulate调用。写两个过程，一个生成递归过程，一个迭代。</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="32dc" class="mq lr hu nf b fv nj nk l nl nm">(define (inc n) (+ n 1))</span><span id="2d5e" class="mq lr hu nf b fv nn nk l nl nm">(define (identity x) x)</span><span id="7aaa" class="mq lr hu nf b fv nn nk l nl nm">(define (accumulate combiner null-value term a next b)<br/>  (if (&gt; a b)<br/>    null-value<br/>    (combiner (term a)<br/>              (accumulate combiner null-value term (next a) next b))))</span><span id="a6ba" class="mq lr hu nf b fv nn nk l nl nm">(define (accumulate-iter combiner null-value term a next b)<br/>  (define (iter a result)<br/>    (if (&gt; a b)<br/>        result<br/>        (iter (next a)(combiner (term a) result))))<br/>  (iter (term a) null-value))</span><span id="a651" class="mq lr hu nf b fv nn nk l nl nm">(define (product term a next b)<br/>  (accumulate * 1 term a next b))</span><span id="63b6" class="mq lr hu nf b fv nn nk l nl nm">(define (sum term a next b)<br/>  (accumulate-iter + 0 term a next b))</span><span id="f5b4" class="mq lr hu nf b fv nn nk l nl nm">; testing<br/>(sum identity 1 inc 10) ; 55<br/>(product identity 1 inc 6) ; 720</span></pre><h2 id="0a24" class="mq lr hu bd ls mr ms mt lw mu mv mw ma js mx my mc jw mz na me ka nb nc mg nd dt translated">练习1.33</h2><blockquote class="kn ko kp"><p id="1bff" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">通过在要组合的项上引入一个<em class="hu">过滤器</em>的概念，你可以得到一个更一般的累加版本(练习1.32)。也就是说，只组合那些从满足指定条件的范围内的值派生的术语。产生的filtered-accumulate抽象采用与accumulate相同的参数，以及一个指定过滤器的参数的附加谓词。将过滤-累积写成一个过程。</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="f0d2" class="mq lr hu nf b fv nj nk l nl nm">(define (filtered-accumulate combiner null-value term a next b filter?)<br/>  (define (iter a result)<br/>    (cond ((&gt; a b) result)<br/>          ((filter? a) (iter (next a)(combiner (term a) result)))<br/>          (else (iter (next a) result))))<br/>  (iter a null-value))</span></pre><blockquote class="kn ko kp"><p id="ea6c" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">展示如何使用filtered-accumulate表达以下内容:</p><p id="c765" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">1.区间<em class="hu"> a </em>到<em class="hu"> b </em>内素数的平方和(假设你有一个素数？谓词已经编写)</p><p id="be47" class="jj jk kq jl b jm jn iv jo jp jq iy jr kr jt ju jv ks jx jy jz kt kb kc kd ke hn dt translated">2.所有小于<em class="hu"> n </em>且与<em class="hu"> n </em>互质的正整数的乘积(即所有正整数i &lt; n使得GCD(i，n)=1GCD。</p></blockquote><pre class="kv kw kx ky fq ne nf ng nh aw ni dt"><span id="252c" class="mq lr hu nf b fv nj nk l nl nm">Part I:</span><span id="1f21" class="mq lr hu nf b fv nn nk l nl nm">(define (smallest-divisor n)<br/>  (find-divisor n 2))</span><span id="a53b" class="mq lr hu nf b fv nn nk l nl nm">(define (find-divisor n test-divisor)<br/>  (cond ((&gt; (square test-divisor) n) n)<br/>        ((divides? test-divisor n) test-divisor)<br/>        (else (find-divisor n (+ test-divisor 1)))))</span><span id="f2a8" class="mq lr hu nf b fv nn nk l nl nm">(define (divides? a b)<br/>  (= (remainder b a) 0))</span><span id="3d84" class="mq lr hu nf b fv nn nk l nl nm">(define (prime? n)<br/>  (= n (smallest-divisor n)))</span><span id="b662" class="mq lr hu nf b fv nn nk l nl nm">(define (inc n) (+ n 1))<br/>(define (square n) (* n n))</span><span id="fd70" class="mq lr hu nf b fv nn nk l nl nm">(define (sum-prime-squares a b)<br/>  (filtered-accumulate + 0 square a inc b prime?))</span><span id="637c" class="mq lr hu nf b fv nn nk l nl nm">; testing<br/>(sum-of-prime-squares 1 4) ;14<br/>(sum-of-prime-squares 3 50) ;10462</span><span id="094e" class="mq lr hu nf b fv nn nk l nl nm"><br/>Part II:</span><span id="b0ed" class="mq lr hu nf b fv nn nk l nl nm">(define (identity x) x)</span><span id="5742" class="mq lr hu nf b fv nn nk l nl nm">(define (gcd a b)<br/>  (if (= b 0)<br/>      a<br/>      (gcd b (remainder a b))))</span><span id="8502" class="mq lr hu nf b fv nn nk l nl nm">(define (relative-prime? x y)<br/>  (= (gcd x y) 1))</span><span id="83ed" class="mq lr hu nf b fv nn nk l nl nm">(define (product-relatively-primes n)<br/>  (define (filter-relative-prime x)<br/>    (relative-prime? x n))<br/>  (filtered-accumulate * 1 identity 1 inc n filter-relative-prime))</span><span id="8fce" class="mq lr hu nf b fv nn nk l nl nm">; testing<br/>(product-relatively-primes 20) ; 8729721</span></pre><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>