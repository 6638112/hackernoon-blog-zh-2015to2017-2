<html>
<head>
<title>Hash-consing in Tezos</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tezos中的哈希考虑</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/hash-consing-in-tezos-e4a59eeea5cd?source=collection_archive---------10-----------------------#2017-12-31">https://medium.com/hackernoon/hash-consing-in-tezos-e4a59eeea5cd?source=collection_archive---------10-----------------------#2017-12-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="463a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经多次谈到散列考虑作为一种为Tezos区块链有效存储合同数据的方式。下面是为什么它有用，它是如何工作的，以及它的局限性是什么。</p><h1 id="54b4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么它有用</h1><p id="bf54" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Tezos中的哈希考虑让智能合约无缝共享数据，没有重复。如果两个智能合约存储同一个表，则它们只被存储一次。如果它们存储的数据略有不同，重叠部分也只存储一次。每当两个数据相同时就会发生这种情况，即使是偶然的。</p><p id="4b2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这有几个好处:</p><ul class=""><li id="2537" class="kt ku hu it b iu iv iy iz jc kv jg kw jk kx jo ky kz la lb dt translated">许多契约很可能实现子令牌，很像以太坊中著名的“ERC20”契约。这种契约通常在公钥和金额之间维护一个大的映射。复制这个映射对于创建其他令牌是有用的，这些令牌以相同的分配开始，然后分开。例如，EggCoin的发行者可以轻松地将一个鸡蛋分配给ChickenCoin的每个持有者，而无需复制任何数据。</li><li id="2c83" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">智能合约代码也是共享的。许多契约中使用的函数只存储一次。没有必要调用“库”契约，因为区块链上的任何一段代码都是隐式的库！</li><li id="9c88" class="kt ku hu it b iu lc iy ld jc le jg lf jk lg jo ky kz la lb dt translated">契约开发人员不必担心序列化已复制的大型结构或将大型结构传递给其他智能契约的成本。没有昂贵的数据拷贝。</li></ul><h1 id="d55b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">它是如何工作的</h1><h2 id="62b4" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">创建复杂值</h2><p id="e90c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">迈克尔逊值是类型化的，迈克尔逊类型是由一些原子类型构建的，如<code class="eh lv lw lx ly b">int</code>(任意精度整数)<code class="eh lv lw lx ly b">string</code>(字符串)<code class="eh lv lw lx ly b">timestamp</code>(时间戳)，甚至<code class="eh lv lw lx ly b">signature</code>(加密签名)，以及其他一些原子类型。</p><p id="50b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使用构造函数组合这些原子类型来构建更复杂的类型。例如，<code class="eh lv lw lx ly b">pair int string</code>表示一对两个值，一个整数和一个字符串，<code class="eh lv lw lx ly b">or signature string</code>表示一个值，或者是一个签名或者是一个字符串，<code class="eh lv lw lx ly b">list timestamp</code>是一个时间戳列表，<code class="eh lv lw lx ly b">map key_hash nat</code>是一个公钥散列和一个正整数之间的关联映射的类型。</p><h2 id="9a85" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">都是二叉树</h2><p id="4aa6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">最后，所有这些复杂的结构本质上都可以用二叉树来表示。叶子是原子类型，中间节点构造新的类型。</p><p id="f4dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，下面是以下结构的表示。它将一个整数列表作为第一个元素，将一对字符串和时间戳作为第二个参数。</p><figure class="ma mb mc md fq me fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff lz"><img src="../Images/7097f9544ec19b2f0350435a195d9693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiHuF3qt4NETVRsLBB6YDA.png"/></div></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">sample hash-consed value</figcaption></figure><p id="f1b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">列表是使用“cons”操作符构建的，该操作符在列表前添加一个值，以及一个表示空列表的多态nil值。</p><p id="36cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意树中的每个节点和叶子都有一个散列。这让我们将这棵树存储在一个哈希表中:</p><figure class="ma mb mc md fq me fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/405f77020b76397069403107417456b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*mN3NshO6pshps3m86aysfA.png"/></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">Structure represented in a hash table</figcaption></figure><p id="257b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意每个条目如何表示一个值，以及条目的散列如何反映该值的全部内容。</p><h2 id="c055" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">共享数据</h2><p id="0a6d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">一旦数据被共享，事情就变得有趣了。</p><p id="5e91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，假设我们希望在表list <code class="eh lv lw lx ly b">[3839; 7816; 1234; 3839]</code>中存储一个新值。这几乎与列表<code class="eh lv lw lx ly b">[1234; 7816; 1234; 3839]</code>相同，但是第一个元素已经改变，现在匹配最后一个元素。</p><p id="86a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是表示的样子:</p><figure class="ma mb mc md fq me fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff mq"><img src="../Images/fdad7b289a5623a8d1523142503a9141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2IcuodAg0tDisbdYp0OPA.png"/></div></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">The new list is stored by simply adding a cons node</figcaption></figure><p id="e3c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意整数<code class="eh lv lw lx ly b">4839</code>只存储一次，列表的尾部<code class="eh lv lw lx ly b">[7816;1234;4839]</code>也是如此。这是自动发生的，因为相同的值存储在哈希表的相同位置。我们的树不再是一棵树，而是一只<a class="ae jp" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank"> DAG </a>。</p><h1 id="8e45" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">困难和解决方法</h1><h2 id="8fb5" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">开销</h2><p id="6f7e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">散列考虑为它存储的每个值引入了散列的开销。引入160位散列来存储64位整数会引入250%的开销！解决这个问题的一种方法是只对超过一定大小的子树应用散列考虑。例如，如果散列仅应用于大于1KB的子树，开销将小于2%。</p><h2 id="6a53" class="lh jr hu bd js li lj lk jw ll lm ln ka jc lo lp ke jg lq lr ki jk ls lt km lu dt translated">碎片帐集</h2><p id="a335" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">假设存储上述数据的契约将字符串“Hello，Tezos”更改为“Tezos，Rocks”。新的结构看起来像这样</p><figure class="ma mb mc md fq me fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff mr"><img src="../Images/727c38e94daa8ea5da881fbd44b6d839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MM6JCnae0RG0roPARdK0WA.png"/></div></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">Changing “Hello, Tezos!” to “Tezos rocks!!”</figcaption></figure><p id="1af3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">树中的大多数节点保持不变，但是一些节点现在是不相关的(用浅绿色表示),因为它们没有连接到树的根。</p><p id="a748" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">移除这些节点被称为“<a class="ae jp" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>”。幸运的是，由于我们从不在数据结构中形成循环，我们可以使用一种非常简单的垃圾收集方式，称为<a class="ae jp" href="https://en.wikipedia.org/wiki/Reference_counting" rel="noopener ugc nofollow" target="_blank">引用计数</a>。简单地说，对于每个节点，我们跟踪它指向了多少个其他节点。如果计数降到零，并且该节点不是智能合同中的顶级值，则可以删除整个子树。</p><p id="3df4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总的来说，通过引用计数进行垃圾收集所花的时间永远不会比创建数据所花的时间多。然而，事情变得棘手的地方是，在许多事务过程中缓慢构建的数据结构可能需要在单个事务后进行垃圾收集。这不适用于区块链，因为我们希望严格限制处理一个块所需的时间。</p><p id="e035" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，诀窍是限制在每个块执行的垃圾收集量，然后如果需要，在下一个块继续。这是可行的，但要正确实现并不容易。</p><h1 id="a772" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">分担费用</h1><p id="f4ae" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">用尽分类账的状态代表了一种成本，谁应该为此买单，如何买单？</p><p id="1e51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一种模式是让每个合同持有与所用空间量成比例的特殊余额。如果一个交易增加了所需的存储空间，额外的存储成本可以从交易费中提取。</p><p id="10b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了激励用户清理未使用的数据，如果合同被破坏，将存储余额退还给合同创建者是有意义的。</p><p id="4191" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在数据共享的情况下，这个模型是如何工作的？如果数据是共享的，那么复制它并不会真正增加存储，也不应该花费太多，但是销毁它的一个实例并不一定会减少存储。</p><p id="dd4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">处理这个问题的一个自然模式是分摊费用。例如，如果Alice创建了一个数据x，她可能会存储0.100 ꜩ。假设现在鲍勃复制了数据x。他将拿出0.050 ꜩ用于存储，爱丽丝将收到0.050 ꜩ.的退款仍然正好有0.100 ꜩ致力于在区块链上存储数据x，但是它现在在Alice和Bob之间平均分配，他们都准备通过删除他们的数据来恢复0.050 ꜩ。</p><p id="031e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不幸的是，我还没有找到一种方法来有效地进行这种核算。例如，假设Alice创建了一个列表<code class="eh lv lw lx ly b">[1;2;3;4;5;...;100000]</code>，Bob创建了整数<code class="eh lv lw lx ly b">1000000</code>。<code class="eh lv lw lx ly b">1000000</code>上的引用计数增加1，很容易立即计算出Bob应该为额外的存储支付多少费用。但是，为了确定Alice是否有资格获得小额退款，必须从列表中一直回溯到第一个元素。另一种方法是让存储中的每个节点维护指向引用它们的每个契约的指针，但是这种方法的空间效率非常低:如果<code class="eh lv lw lx ly b">N</code>用户存储一个<code class="eh lv lw lx ly b">M</code>元素的公共列表，这将引入<code class="eh lv lw lx ly b">N * M</code>指针！</p><h1 id="1a47" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="bdf9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">散列考虑可能不会出现在Tezos的第一版中，但我希望在v2中看到它。一个重要的未解决的问题是如何有效地执行存储成本核算。</p></div></div>    
</body>
</html>