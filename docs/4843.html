<html>
<head>
<title>The Reader Monad — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">读者单子——第一部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-reader-monad-part-1-1e4d947983a8?source=collection_archive---------0-----------------------#2017-06-26">https://medium.com/hackernoon/the-reader-monad-part-1-1e4d947983a8?source=collection_archive---------0-----------------------#2017-06-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="e362" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章将涵盖<a class="ae jp" href="https://hackernoon.com/tagged/foundations" rel="noopener ugc nofollow" target="_blank">基础</a>。这将主要是一个练习，学习如何专门化类型、简化替换并提出唯一合理的实现。</p><h1 id="8e01" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">动机</h1><p id="0f48" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><code class="eh kt ku kv kw b">Reader</code> monad，或者更一般地说是<code class="eh kt ku kv kw b">MonadReader</code>接口，解决了将同一个配置线程化到多个函数的问题。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="fc8b" class="lf jr hu kw b fv lg lh l li lj">-- Imagine this is a directory<br/>type Config = FilePath</span><span id="9182" class="lf jr hu kw b fv lk lh l li lj">load :: Config -&gt; String -&gt; IO String<br/>load config x = readFile (config ++ x)</span><span id="e5a4" class="lf jr hu kw b fv lk lh l li lj">loadRevision :: Config -&gt; Int -&gt; IO String<br/>loadRevision config x = load config ("history" ++ show x ++ ".txt")</span><span id="e4ba" class="lf jr hu kw b fv lk lh l li lj">loadAll :: Config -&gt; Int -&gt; String -&gt; IO (String, String)<br/>loadAll config x y = do<br/>    a &lt;- load config y<br/>    b &lt;- loadRevision config x<br/>    return (a, b)</span></pre><p id="d068" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你看一下<code class="eh kt ku kv kw b">loadAll</code>，你会发现<code class="eh kt ku kv kw b">config</code>没有被使用，而是被线程化到了子函数中。这是样板文件的常见来源，读者monad试图改善它。</p><p id="b3aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们可以使用<code class="eh kt ku kv kw b">MonadReader</code>重写这个函数，而不是将<code class="eh kt ku kv kw b">config</code>线程化到每个函数，配置将被隐式传递。为了检索配置，我们调用<code class="eh kt ku kv kw b">ask</code>:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2a2f" class="lf jr hu kw b fv lg lh l li lj">-- Imagine this is a directory<br/>type Config = FilePath</span><span id="5cbc" class="lf jr hu kw b fv lk lh l li lj">load :: (MonadReader Config m, MonadIO m) =&gt; String -&gt; m String<br/>load x = do<br/>    config &lt;- ask<br/>    liftIO $ readFile (config ++ x)</span><span id="2fe5" class="lf jr hu kw b fv lk lh l li lj">loadRevision :: (MonadReader Config m, MonadIO m) =&gt; Int -&gt; m String<br/>loadRevision x = load ("history" ++ show x ++ ".txt")</span><span id="2dd2" class="lf jr hu kw b fv lk lh l li lj">loadAll :: (MonadReader Config m, MonadIO m) =&gt; Int -&gt; String -&gt; m (String, String)<br/>loadAll x y = do<br/>    a &lt;- load y<br/>    b &lt;- loadRevision x<br/>    return (a, b)</span></pre><p id="1d67" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你看看中间函数<code class="eh kt ku kv kw b">loadRevision</code>和<code class="eh kt ku kv kw b">loadAll</code>，我们不再需要接受和传递配置。然而“叶子”功能<code class="eh kt ku kv kw b">load</code>变得更加复杂。我们稍后将扩展这个例子，使它可以跨具体配置重用，并将其与备选方案进行比较；但首先是一些基础知识。</p><h1 id="2351" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">((-&gt;) e)，Reader，ReaderT和MonadReader</h1><p id="9862" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">当Haskellers提到“读者单子”时，他们可能指的是四个相关事物中的一个:</p><ol class=""><li id="6fef" class="ll lm hu it b iu iv iy iz jc ln jg lo jk lp jo lq lr ls lt dt translated">具有相同第一个参数的函数的<code class="eh kt ku kv kw b">Monad</code>实例，写为<code class="eh kt ku kv kw b">((-&gt;) e)</code>(我认为是<code class="eh kt ku kv kw b">(e -&gt;)</code>)有点令人费解。</li><li id="1c9f" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><code class="eh kt ku kv kw b">type Reader = ReaderT Identity</code></li><li id="871d" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated"><code class="eh kt ku kv kw b">ReaderT</code>型</li><li id="05af" class="ll lm hu it b iu lu iy lv jc lw jg lx jk ly jo lq lr ls lt dt translated">任何实现<code class="eh kt ku kv kw b">MonadReader</code>类型类的东西。</li></ol><p id="87f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理解所有这四个概念是值得的。</p><h1 id="17ce" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">第一个参数相同的函数的单子是做什么的？</h1><p id="b0e6" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">记住一个<code class="eh kt ku kv kw b">Monad</code>也是一个<code class="eh kt ku kv kw b">Functor</code>和一个<code class="eh kt ku kv kw b">Applicative</code>。为了理解<code class="eh kt ku kv kw b">((-&gt;) e)</code>的单子，我们将在把<code class="eh kt ku kv kw b">((-&gt;) e)</code>代入类型签名后，通过查看类型来猜测<code class="eh kt ku kv kw b">Functor</code>、<code class="eh kt ku kv kw b">Applicative</code>和<code class="eh kt ku kv kw b">Monad</code>实例的实现。</p><h2 id="b19c" class="lf jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">仿函数实例</h2><p id="2c37" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先是<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Functor" rel="noopener ugc nofollow" target="_blank">Functor</a></code>实例。让我们写出<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:fmap" rel="noopener ugc nofollow" target="_blank">fmap</a></code>的类型。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7598" class="lf jr hu kw b fv lg lh l li lj">Class Functor f where<br/>  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="883d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从这个类型签名看不出<code class="eh kt ku kv kw b">((-&gt;) e)</code>的<code class="eh kt ku kv kw b">Functor</code>实例会做什么。</p><p id="dc12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理解<code class="eh kt ku kv kw b">Functor</code>的实现应该是什么的一个简单方法是查看<code class="eh kt ku kv kw b">base</code>中的实现。另一种方法是通过写出专门化的实例签名来推断它。这是一个有些乏味的过程，但是对于实现实例和理解它们必须如何工作来说，这是一个很好的实践。</p><p id="2013" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个过程从替换类型类中引入的类型变量开始，在这个例子中是<code class="eh kt ku kv kw b">f</code>。</p><p id="f001" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们用<code class="eh kt ku kv kw b">f = ((-&gt;) e)</code>代替:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="77fa" class="lf jr hu kw b fv lg lh l li lj">fmap :: (a -&gt; b) -&gt; (((-&gt;) e) a) -&gt; (((-&gt;) e) b)</span></pre><p id="2707" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们简化</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5e55" class="lf jr hu kw b fv lg lh l li lj">fmap :: (a -&gt; b) -&gt; (((-&gt;) e) a) -&gt; (((-&gt;) e) b)<br/>fmap :: (a -&gt; b) -&gt; ((-&gt;) e a) -&gt; ((-&gt;) e b)<br/>fmap :: (a -&gt; b) -&gt; (e -&gt; a) -&gt; (e -&gt; b)<br/>fmap :: (a -&gt; b) -&gt; (e -&gt; a) -&gt; e -&gt; b</span></pre><p id="0042" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将用下面的替换来重新标记变量，<code class="eh kt ku kv kw b">e = a</code>、<code class="eh kt ku kv kw b">a = b</code>和<code class="eh kt ku kv kw b">b = c</code>(因为我已经知道要寻找什么；)).</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="c486" class="lf jr hu kw b fv lg lh l li lj">fmap :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span></pre><p id="f4b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以看到<code class="eh kt ku kv kw b">((-&gt;) e)</code>的<code class="eh kt ku kv kw b">fmap</code>被合成<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:." rel="noopener ugc nofollow" target="_blank">.</a></code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="7378" class="lf jr hu kw b fv lg lh l li lj">fmap :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c<br/>fmap f g x = f (g x)</span></pre><p id="bc56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于该类型签名，没有其他非邪恶的实现。</p><p id="8cd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就引出了一个有趣的恶作剧，通过把<code class="eh kt ku kv kw b">fmap . fmap</code>写成<code class="eh kt ku kv kw b">fmap fmap fmap</code>来引诱你的同事</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1fe2" class="lf jr hu kw b fv lg lh l li lj">&gt; (fmap fmap fmap) (+1) [Just 1, Just 2, Nothing]<br/>[Just 2, Just 3, Nothing]</span></pre><h2 id="4fc1" class="lf jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">应用实例</h2><p id="12c4" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">首先让我们写出<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:pure" rel="noopener ugc nofollow" target="_blank">pure</a></code>。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="3265" class="lf jr hu kw b fv lg lh l li lj">pure :: a -&gt; f a</span></pre><p id="b728" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">替换<code class="eh kt ku kv kw b">f = ((-&gt;) e)</code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e8bf" class="lf jr hu kw b fv lg lh l li lj">pure :: a -&gt; (((-&gt;) e) a)</span></pre><p id="fc0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简化</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="ff5b" class="lf jr hu kw b fv lg lh l li lj">pure :: a -&gt; e -&gt; a</span></pre><p id="5ec6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们最终得到一个函数，它接受一个<code class="eh kt ku kv kw b">a</code>和一些随机的其他参数<code class="eh kt ku kv kw b">e</code>，并返回一个<code class="eh kt ku kv kw b">a</code>。这必须适用于所有的<code class="eh kt ku kv kw b">e</code>和<code class="eh kt ku kv kw b">a</code>，并且没有办法组合未知的类型。因此，该函数唯一能做的就是返回给它的<code class="eh kt ku kv kw b">a</code>。因此是<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:const" rel="noopener ugc nofollow" target="_blank">const</a></code>:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4a53" class="lf jr hu kw b fv lg lh l li lj">pure :: a -&gt; e -&gt; a<br/>pure x _ = x</span></pre><p id="dece" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来我们有<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:-60--42--62-" rel="noopener ugc nofollow" target="_blank">&lt;*&gt;</a></code>或<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#v:ap" rel="noopener ugc nofollow" target="_blank">ap</a></code>。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="370d" class="lf jr hu kw b fv lg lh l li lj">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="5772" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">替换<code class="eh kt ku kv kw b">f = ((-&gt;) e)</code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d5b1" class="lf jr hu kw b fv lg lh l li lj">(&lt;*&gt;) :: (((-&gt;) e) (a -&gt; b)) -&gt; (((-&gt;) e) a) -&gt; (((-&gt;) e) b)</span></pre><p id="efda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简化</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="55d8" class="lf jr hu kw b fv lg lh l li lj">(&lt;*&gt;) :: ((e -&gt; (a -&gt; b)) -&gt; (e -&gt; a) -&gt; (e -&gt; b)<br/>(&lt;*&gt;) :: (e -&gt; a -&gt; b) -&gt; (e -&gt; a) -&gt; (e -&gt; b)<br/>(&lt;*&gt;) :: (e -&gt; a -&gt; b) -&gt; (e -&gt; a) -&gt; e -&gt; b</span></pre><p id="3357" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此,<code class="eh kt ku kv kw b">&lt;*&gt;</code>接受两个函数，两个函数都以<code class="eh kt ku kv kw b">e</code>作为第一个参数，并将它们链接在一起，形成一个新的函数，它接受一个<code class="eh kt ku kv kw b">e</code>并给出链接的输出。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="28ff" class="lf jr hu kw b fv lg lh l li lj">(&lt;*&gt;) :: (e -&gt; a -&gt; b) -&gt; (e -&gt; a) -&gt; e -&gt; b<br/>f &lt;*&gt; g = \e -&gt; f e (g e)</span></pre><h2 id="330d" class="lf jr hu bd js lz ma mb jw mc md me ka jc mf mg ke jg mh mi ki jk mj mk km ml dt translated">单子实例</h2><p id="cf19" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我们已经讲过<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#v:return" rel="noopener ugc nofollow" target="_blank">return</a></code>:只是<code class="eh kt ku kv kw b">pure</code>，只是<code class="eh kt ku kv kw b">const</code>。</p><p id="f977" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，绑定的类型:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="03e6" class="lf jr hu kw b fv lg lh l li lj">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span></pre><p id="d128" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">替换<code class="eh kt ku kv kw b">m = ((-&gt;) e)</code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1faf" class="lf jr hu kw b fv lg lh l li lj">(&gt;&gt;=) :: (((-&gt;) e) a) -&gt; (a -&gt; (((-&gt;) e) b)) -&gt; (((-&gt;) e) b)</span></pre><p id="3ab9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简化</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="5f0e" class="lf jr hu kw b fv lg lh l li lj">(&gt;&gt;=) :: (e -&gt; a) -&gt; (a -&gt; (e -&gt; b)) -&gt; (e -&gt; b)<br/>(&gt;&gt;=) :: (e -&gt; a) -&gt; (a -&gt; e -&gt; b) -&gt; e -&gt; b</span></pre><p id="529f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Bind基本上是一个翻转的<code class="eh kt ku kv kw b">&lt;*&gt;</code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="55fb" class="lf jr hu kw b fv lg lh l li lj">(&gt;&gt;=) :: (e -&gt; a) -&gt; (a -&gt; e -&gt; b) -&gt; e -&gt; b<br/>g &gt;&gt;= f = flip f &lt;*&gt; g</span></pre><p id="4f7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#v:join" rel="noopener ugc nofollow" target="_blank">join</a></code>比较有意思。<code class="eh kt ku kv kw b">join</code>将两层单子展平为一层。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="59d3" class="lf jr hu kw b fv lg lh l li lj">join :: Monad m =&gt; m (m a) -&gt; m a</span></pre><p id="aaea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们替换<code class="eh kt ku kv kw b">m = ((-&gt;) e)</code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="72ae" class="lf jr hu kw b fv lg lh l li lj">join :: (((-&gt;) e) (((-&gt;) e) a))) -&gt; (((-&gt;) e) a)</span></pre><p id="cc00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简化</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="2b65" class="lf jr hu kw b fv lg lh l li lj">join :: (((-&gt;) e) ((-&gt;) e a))) -&gt; ((-&gt;) e a)<br/>join :: ((-&gt;) e) (e -&gt; a)) -&gt; (e -&gt; a)<br/>join :: (e -&gt; (e -&gt; a)) -&gt; e -&gt; a<br/>join :: (e -&gt; e -&gt; a) -&gt; e -&gt; a</span></pre><p id="631f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于这种类型的签名，只有一个真正的非邪恶的实现，它等价于:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="624d" class="lf jr hu kw b fv lg lh l li lj">join :: (e -&gt; e -&gt; a) -&gt; e -&gt; a<br/>join f x = f x x</span></pre><p id="8630" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b">join</code>我们免费获得，但很高兴看到它是如何手工实现的。它有时用于创建第一个和第二个值相同的元组。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="33d0" class="lf jr hu kw b fv lg lh l li lj">&gt; join (,) 1<br/>(1, 1)</span></pre><h1 id="ac09" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">什么是Reader？</h1><p id="fc1d" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">你可以把<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Reader.html#t:Reader" rel="noopener ugc nofollow" target="_blank">Reader</a></code>想象成<code class="eh kt ku kv kw b">(e -&gt; a)</code>周围的<code class="eh kt ku kv kw b">newtype</code></p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="4714" class="lf jr hu kw b fv lg lh l li lj">newtype Reader e a = Reader { runReader :: e -&gt; a }</span></pre><p id="6e25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，如今它被定义为<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT" rel="noopener ugc nofollow" target="_blank">ReaderT</a></code>的专门版本。</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="93de" class="lf jr hu kw b fv lg lh l li lj">type Reader = ReaderT Identity</span></pre><p id="a24c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，它就像<code class="eh kt ku kv kw b">Functor</code>、<code class="eh kt ku kv kw b">Applicative</code>和<code class="eh kt ku kv kw b">Monad</code>实例、<code class="eh kt ku kv kw b">((-&gt;) e)</code>一样工作。如果<code class="eh kt ku kv kw b">((-&gt;) e)</code>就够了，那就真的没有理由用了。</p><h1 id="e083" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">莫纳瑞德</h1><p id="0d4c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html#t:MonadReader" rel="noopener ugc nofollow" target="_blank">MonadReader</a></code>是阅读器单子的通用接口。类型类本质上如下所示:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="d2fa" class="lf jr hu kw b fv lg lh l li lj">class Monad m =&gt; MonadReader r m | m -&gt; r where<br/>  ask :: m r<br/>  local :: (r -&gt; r) -&gt; m a -&gt; m a</span></pre><p id="3cdd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们通过替换<code class="eh kt ku kv kw b">m = ((-&gt;) e)</code>和<code class="eh kt ku kv kw b">r = e</code>来看看<code class="eh kt ku kv kw b">((-&gt;) e)</code>的实现必须是什么:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="e740" class="lf jr hu kw b fv lg lh l li lj">instance MonadReader e ((-&gt;) e) where<br/>  ask :: e -&gt; e<br/>  ask = ?<br/>  <br/>  local :: (e -&gt; e) -&gt; (e -&gt; a) -&gt; e -&gt; a<br/>  local = ?</span></pre><p id="09e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html#v:ask" rel="noopener ugc nofollow" target="_blank">ask</a></code>只能真正成为一件事:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="6234" class="lf jr hu kw b fv lg lh l li lj">ask :: e -&gt; e<br/>ask = id</span></pre><p id="b6f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html#v:local" rel="noopener ugc nofollow" target="_blank">local</a></code>有点棘手。并不是完全由类型决定的。文档说它接受一个修改环境的函数<code class="eh kt ku kv kw b">e -&gt; e</code>和一个使用修改后的环境的函数<code class="eh kt ku kv kw b">e -&gt; a</code>。</p><p id="f8d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们开始吧:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="1678" class="lf jr hu kw b fv lg lh l li lj">local :: (e -&gt; e) -&gt; (e -&gt; a) -&gt; e -&gt; a<br/>local f action = action . f</span></pre><h1 id="6fbe" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">里德特</h1><p id="91c1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated"><code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT" rel="noopener ugc nofollow" target="_blank">ReaderT</a></code>是<code class="eh kt ku kv kw b">Reader</code>的变形金刚版本。它允许你用另一个<code class="eh kt ku kv kw b">Monad</code>添加“阅读器”的“第一参数线程化”能力。常见的选择是<code class="eh kt ku kv kw b">ReaderT e IO</code>。我们在文章开头的例子可以用<code class="eh kt ku kv kw b">ReaderT e IO</code>代替<code class="eh kt ku kv kw b">MonadReader</code>来重写，但是直接指定转换器栈并没有什么好处。使用阅读器monad接口<code class="eh kt ku kv kw b">MonadReader</code>编写函数更加灵活。</p><p id="de4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">直接使用<code class="eh kt ku kv kw b">ReaderT</code>的一个好处是我们可以利用<code class="eh kt ku kv kw b">local</code>的一个更有表现力的版本，主要是<code class="eh kt ku kv kw b"><a class="ae jp" href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#v:withReaderT" rel="noopener ugc nofollow" target="_blank">withReaderT</a></code>，它有以下类型:</p><pre class="kx ky kz la fq lb kw lc ld aw le dt"><span id="a48f" class="lf jr hu kw b fv lg lh l li lj">withReaderT :: (r' -&gt; r) -&gt; ReaderT r m a -&gt; ReaderT r' m a</span></pre><p id="ed03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与<code class="eh kt ku kv kw b">local</code>不同的是<code class="eh kt ku kv kw b">withReaderT</code>可以将环境的类型从<code class="eh kt ku kv kw b">r</code>更改为<code class="eh kt ku kv kw b">r'</code>。</p><h1 id="6fbb" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">接下来</h1><p id="ae6f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">目前就这些。在以后的帖子中，我将讨论一些增强功能，并将Reader Monad与一些替代方案进行比较。</p><blockquote class="mm mn mo"><p id="96ac" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="dca4" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">要了解更多信息，请阅读我们的“关于”页面、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">喜欢/在脸书上给我们发消息</a>，或者简单地发送<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is mp it b iu iv iw ix iy iz ja jb mq jd je jf mr jh ji jj ms jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq mt"><div class="bz el l di"><div class="mu mv l"/></div></figure></div></div>    
</body>
</html>