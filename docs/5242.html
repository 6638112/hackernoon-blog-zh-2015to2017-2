<html>
<head>
<title>Cleaning Up Our Projects with Hpack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Hpack清理我们的项目</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/cleaning-up-our-projects-with-hpack-9253dabcb8e2?source=collection_archive---------20-----------------------#2017-07-17">https://medium.com/hackernoon/cleaning-up-our-projects-with-hpack-9253dabcb8e2?source=collection_archive---------20-----------------------#2017-07-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="30c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约一个月前，我们发布了免费的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank">堆栈迷你课程</a>。如果你以前从未使用过Stack，你完全应该去看看那个课程！这篇文章将让你先睹为快，了解课程中的一些内容。</p><p id="6819" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果您已经熟悉堆栈的基础知识，并且认为您不需要该课程，请不要担心！在本文中，我们将通过另一个很酷的工具来简化您的工作流程！</p><p id="9e02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几乎所有你创建的Haskell项目都会用到Cabal。Cabal为你执行了几项重要的任务。它为您下载依赖项，并在文件系统中定位您编写的代码。它还链接你所有的代码，这样GHC就可以编译它。为了让Cabal做到这一点，你需要创建一个描述所有这些事情的<code class="eh jq jr js jt b">.cabal</code>文件。例如，它需要知道你的代码的每一部分依赖于什么库。您还必须指定源文件目录在文件系统中的位置。</p><p id="cbd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个<code class="eh jq jr js jt b">.cabal</code>文件的组织有时有点混乱。语法可能相当冗长。如果我们使用“Hpack”工具，我们可以使我们的生活更简单。Hpack允许您以更简洁的格式指定您的项目组织。一旦指定了Hpack格式的所有内容，就可以用一个命令生成<code class="eh jq jr js jt b">.cabal</code>文件。</p><h1 id="c2b7" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">使用Hpack</h1><p id="84df" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">使用hpack的第一步当然是下载它。这很简单，只要你在你的系统上安装了Stack。使用命令:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="149d" class="lf jv hu jt b fv lg lh l li lj">stack install hpack</span></pre><p id="430a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将在系统范围内安装Hpack，这样您就可以在所有项目中使用它。下一步是在一个名为<code class="eh jq jr js jt b">package.yaml</code>的文件中指定代码的组织。这里有一个简单的例子:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="ea77" class="lf jv hu jt b fv lg lh l li lj">name: HpackExampleProject</span><span id="85b6" class="lf jv hu jt b fv lk lh l li lj">version: 0.1.0.0</span><span id="07ff" class="lf jv hu jt b fv lk lh l li lj">ghc-options: -Wall</span><span id="e1c1" class="lf jv hu jt b fv lk lh l li lj">dependencies:<br/>  - base</span><span id="1d22" class="lf jv hu jt b fv lk lh l li lj">library:<br/>  source-dirs: src/</span><span id="f83e" class="lf jv hu jt b fv lk lh l li lj">executables:<br/>  HpackExampleProject-exe:<br/>    main: Main.hs<br/>    source-dirs: app/<br/>    dependencies:<br/>      HpackExampleProject</span><span id="8e11" class="lf jv hu jt b fv lk lh l li lj">tests:<br/>  HpackExampleProject-test:<br/>    main: Spec.hs<br/>    source-dirs: test/ <br/>    dependencies:<br/>      HpackExampleProject</span></pre><p id="db0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个例子将生成一个非常简单的cabal文件。它看起来很像运行<code class="eh jq jr js jt b">stack new HpackExampleProject</code>的默认模板。有几个基本的字段，比如我们项目的名称、版本和编译器选项。我们可以指定关于我们的代码库、可执行文件和任何测试套件的细节，就像我们可以在一个<code class="eh jq jr js jt b">.cabal</code>文件中一样。这些组件中的每一个都可以有自己的依赖关系。我们还可以指定全局依赖关系。</p><p id="ce62" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们创建了这个文件，我们需要做的就是从包含这个文件的目录中运行<code class="eh jq jr js jt b">hpack</code>命令。这将生成我们的<code class="eh jq jr js jt b">.cabal</code>文件:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="5eca" class="lf jv hu jt b fv lg lh l li lj">&gt;&gt; hpack<br/>generated HpackExampleProject.cabal</span></pre><h1 id="b026" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">Hpack解决了哪些问题？</h1><p id="9723" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">hpack解决的一个大问题是模块推理。您的<code class="eh jq jr js jt b">.cabal</code>文件应该指定作为您的库的一部分的所有Haskell模块。您总是有两个组:“公开的”模块和“其他”模块。列出这些模块中的每一个都是很烦人的，随着你的库变得越来越大，这个列表会变得很长！更糟糕的是，当您创建了一个新模块，但忘记将它添加到。阴谋文件。使用Hpack，您不需要记住添加大多数新文件！它会查看您的文件系统，并确定为您提供了哪些模块。假设您已经在源目录中这样组织了文件:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="faa6" class="lf jv hu jt b fv lg lh l li lj">src/Lib.hs<br/>src/API.hs<br/>src/Internal/Helper.hs<br/>src/Internal/Types.hs</span></pre><p id="15fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用正常的。<code class="eh jq jr js jt b">cabal</code>方法，您需要手动列出这些模块。但是没有在package.yaml文件中列出任何内容，您将在。cabal文件:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="7a31" class="lf jv hu jt b fv lg lh l li lj">exposed-modules:<br/>  API<br/>  Internal.Helper<br/>  Internal.Types<br/>  Lib</span></pre><p id="bed1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您可能不希望所有的模块都公开。您可以对程序包文件进行简单的修改:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="9cdd" class="lf jv hu jt b fv lg lh l li lj">library:<br/>  source-dirs: src/<br/>  exposed-modules:<br/>    - API<br/>    - Lib</span></pre><p id="df34" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并且hpack将纠正<code class="eh jq jr js jt b">.cabal</code>文件。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="caef" class="lf jv hu jt b fv lg lh l li lj">exposed-modules:<br/>  API<br/>  Lib<br/>other-modules:<br/>  Internal.Helper<br/>  Internal.Types</span></pre><p id="24c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从这一点来看，Hpack会将所有新的Haskell模块推断为“其他”模块。您只需要在package.yaml中列出“暴露的”模块。只需要记住一件事！你需要在每次添加新模块时运行<code class="eh jq jr js jt b">hpack</code>，否则Cabal不知道你的代码在哪里。这仍然比每次修改<code class="eh jq jr js jt b">.cabal</code>文件容易得多。<code class="eh jq jr js jt b">.cabal</code>文件本身仍然包含一长串模块名。但是它们中的大部分不会出现在<code class="eh jq jr js jt b">package.yaml</code>文件中，这是你主要的交互点。</p><p id="6955" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用hpack的另一个好处是全局依赖性。请注意，在示例中，我们在所有其他部分的上方有一个“dependencies”字段。这意味着我们的库、可执行文件和测试套件都将免费获得base作为依赖项。如果没有hpack，我们将需要在每个单独的部分中指定base作为依赖项。</p><p id="c58c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">hpack还提供了大量其他语法。一个简单的例子是github规范。您可以将以下单行放入您的程序包文件中:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="512e" class="lf jv hu jt b fv lg lh l li lj">github: username/reponame</span></pre><p id="f1ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您将在您的<code class="eh jq jr js jt b">.cabal</code>文件中免费获得以下代码行。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="cdee" class="lf jv hu jt b fv lg lh l li lj">homepage:          https://github.com/username/reponame#readme<br/>bug-reports:       <a class="ae jp" href="https://github.com/username/reponame/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/username/reponame/issues</a></span></pre><h1 id="be69" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">摘要</h1><p id="d7ed" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">一旦你超越了玩具项目，你的包的维护将不是微不足道的。如果你使用hpack，你将更容易组织你的第一个大项目。语法更清晰。组织更直观。最后，你将为自己省去执行许多重复任务的压力。对<code class="eh jq jr js jt b">.cabal</code>文件的不断编辑将会中断您的流程和构建过程。所以避免它们会让你更有效率。</p><p id="1531" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你以前从未使用过Stack或Cabal，这里有很多东西需要掌握。但是希望你相信有简单的方法来组织你的Haskell代码！如果您对如何学习感兴趣，请注册参加我们免费的<a class="ae jp" href="http://academy.mondaymorninghaskell.com/p/your-first-haskell-project" rel="noopener ugc nofollow" target="_blank"> Stack迷你课程</a>！您将了解到组织Haskell项目的所有简单方法。</p><p id="d98f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您从来没有使用过Haskell，并且对这一切感到完全困惑，没有必要烦恼！下载我们的<a class="ae jp" href="https://www.mmhaskell.com/checklist" rel="noopener ugc nofollow" target="_blank">入门清单</a>，你将踏上学习Haskell的征途！</p></div></div>    
</body>
</html>