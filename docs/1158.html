<html>
<head>
<title>On troubleshooting networks: Traceroute</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络故障排除:Traceroute</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/on-troubleshooting-networks-traceroute-92a1569011f?source=collection_archive---------0-----------------------#2016-09-16">https://medium.com/hackernoon/on-troubleshooting-networks-traceroute-92a1569011f?source=collection_archive---------0-----------------------#2016-09-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/0a6aedc565397260e854ba49732a05f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*jQk0LXWfUvo3f5s6gA_9-w.png"/></div></figure><p id="a1ac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我想开始一系列关于网络概念的帖子。没有什么非常复杂的，只是为了好玩。我认为开始讨论traceroute是个好主意，因为它是最著名的故障排除工具之一。</p><p id="841c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">希望你喜欢阅读。</p><h1 id="2a1a" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">Traceroute。</h1><p id="59d8" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">从事网络工作的人都曾使用过traceroute来排除连通性故障，但我们对它的工作原理和结果解释又了解多少呢？</p><p id="f0ac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">大多数人都知道traceroute“使用ICMP”，但这是一个非常宽泛的说法，并不总是100%准确。我为什么这么说？让我们从分析最常见的traceroute实现之一——来自Windows的traceroute开始。</p><h1 id="af6a" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">tracert.exe</h1><p id="d931" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">traceroute的这种实现最简单的用法只需要一个参数:我们希望跟踪路由的目的IP地址。<br/>当我们点击进入时，引擎盖下的<strong class="ja hv">tracert.exe</strong>是什么？它立即向目的IP地址发送3个类型8代码为0的ICMP数据包，也称为回应请求或更常见的Ping。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff kz"><img src="../Images/a1483cece83d7dc2daabf57ef63a3e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37QDZyfVT-AlRf_7k66fSQ.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">These 3 ICMP packets have a particularity though: Their TTL value is 1.</figcaption></figure><p id="d6d1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Time_to_live" rel="noopener ugc nofollow" target="_blank">TTL是一个IP报头</a>，每当一个IP分组从一个子网移动到另一个子网时，它就递减1。换句话说，路由器每转发一次数据包，就会减少数据包的TTL。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ln"><img src="../Images/f1f18cbc07b544ce5147ec9855a220f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOwVRxMUpLNk2Eb2nfsU0w.png"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Expanded IP header in Wireshark</figcaption></figure><p id="8ac1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">于是<strong class="ja hv">tracert.exe</strong>向目的IP地址发送了3个pings，TTL值为1。这些数据包先去哪里？嗯，假设目的地IP地址不是我们网络中的另一台主机，我们运行<strong class="ja hv">tracert.exe</strong>的计算机将查找自己的路由表，决定将这个数据包发送到哪里。在大多数情况下，我们会有一台带有简单默认路由的计算机，它指向我们所说的默认网关(因为它是为默认路由指定的网关)。</p><p id="febf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">数据包到达默认网关，默认网关是具有路由功能的网络设备。可能是路由器或者防火墙。该路由器将查看数据包报头，以决定如何处理它。在正常情况下，我会提到路由器也会检查自己的路由表，但是除了目的IP地址之外，路由器还会检查一样东西:TTL报头。</p><p id="074f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如我们之前提到的，TTL报头的值为1，路由器在转发数据包时会将其递减，因此在我们的例子中，路由器必须转发TTL值为0的数据包。这可能吗？好吧，一个坏掉的IP堆栈可能想这么做，但简单的回答是<strong class="ja hv">不</strong>。一旦你必须转发一个数据包，并将其TTL值减少到0，你将<strong class="ja hv">丢弃它</strong>并向<strong class="ja hv">原始发送者</strong>发回通知。在我们的例子中，<strong class="ja hv">原始发送者</strong>是谁？我们的电脑。</p><p id="4a91" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">路由器会向我们的计算机发回什么样的通知？要是我们有某种标准化的网络控制协议就好了！</p><p id="7388" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">没错，路由器会发回一个类型11码0 的<a class="ae lm" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Control_messages" rel="noopener ugc nofollow" target="_blank"> ICMP包，也就是所谓的“TTL过期(或TTL超出)在途”。此ICMP还将包含原始丢弃的数据包作为其有效负载，因此您的计算机可以识别已被丢弃的数据包。</a></p><p id="cc37" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">嗯，这很好，但是tracert.exe如何利用这一点呢？轻松点。ICMP包当然是IP包，所以有IP头吧？tracert.exe可以从IP报头中得到什么有用的信息？<strong class="ja hv">源IP地址</strong>。由于TTL过期数据包是在路由器上发起的新数据包，源IP地址是路由器的IP地址，因此<strong class="ja hv">tracert.exe</strong>将读取该IP地址，并识别谁是第一跳:</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff lo"><img src="../Images/64c09d587b2ea68cb25461ee74acafda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVSQQ64mSdCYn7m0qO410w.png"/></div></div></figure><p id="0e7f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的截图中可以看到，我们的电脑<strong class="ja hv"> 192.168.1.103 </strong>向<strong class="ja hv">8.8.8.8</strong>发送3个pings(其中TTL==1在截图中看不到，但在本文之前的截图中可以看到)并从<strong class="ja hv"> 192.168.1.254 </strong>取回3个TTL过期的数据包。这就是<strong class="ja hv">tracert.exe</strong>如何识别第一跳，以及它如何测量我们与该跳之间的延迟(发送ping和接收TTL过期数据包之间的时间差)。这个过程是相同的，直到TTL足够大，可以到达目的地而不会在传输中过期，在这种情况下，我们将获得对ping的回复(Echo Reply ICMP)。</p><p id="e784" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，是的，我们可以说<strong class="ja hv">tracert.exe</strong>“使用ICMP”，因为除了第3层之外没有其他协议。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/c2ec9fcbacd4f0da3df041de467d11af.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*xHRjfNhZK5ePT2EQt-ZNjg.png"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Request timed out at hop #2. What’s going on?</figcaption></figure><h1 id="de82" class="jw jx hu bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">请求超时。</h1><p id="eaac" class="pw-post-body-paragraph iy iz hu ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hn dt translated">在我们的<strong class="ja hv">tracert.exe</strong>输出中看到这条消息并不少见。这是什么意思？简而言之，这意味着我们从未收到TTL过期的ICMP数据包，也没有收到回应ICMP对发送的pings的回复。原因？</p><p id="38b9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">-出于安全或经济原因，路由器被配置为不发送这些回复。<br/> -要么是我们的pings在到达路由器之前丢失了，要么是ICMP回复在返回给我们的途中丢失了。</p><p id="4396" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在上面的截图中，我倾向于认为跳#2的路由器被配置为不发送这些ICMP数据包，只是因为其余的跳看起来运行良好并报告回来，所以我会丢弃路径中严重的数据包丢失(参见？我们已经开始从tracert.exe的结果中获得一些有用的东西。</p><figure class="la lb lc ld fq iv fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/442c25307d13f5d1e846849b458c48e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*jz8F4RLPN1yUFkHFCqiM6A.png"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">Fun fact: After hop #9 we have crossed the Atlantic Ocean (+100ms).</figcaption></figure><p id="c73f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在其他情况下，在某一跳后会出现<strong class="ja hv">请求超时</strong>消息，但我们从未获得新的跳IP地址。在这种情况下，就像上面的截图一样，在跳#14之后，有一个设备丢弃ICMP数据包。在某些情况下，直到最后一个结果之前，您还会错过一堆结果:在这种情况下，中间设备会丢弃不是ping的ICMPs(回应请求和回应回复)。</p><p id="83f4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在这种情况下，只有这个输出，我们不能肯定地说有多少跳，直到目的地和<strong class="ja hv">tracert.exe</strong>将继续下去，直到跳#30(默认)。</p><p id="0fb8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你是如何度过这一关的？你不能。<em class="lr">但是我听说过</em><a class="ae lm" href="http://linux.die.net/man/1/tcptraceroute" rel="noopener ugc nofollow" target="_blank"><em class="lr">tcptraceroute</em></a><em class="lr">！</em> —是的，<strong class="ja hv"> tcptraceroute </strong>有一点不同，但是它在很多场景下都不会起作用。让我解释一下原因:</p><p id="d5e8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv"> Tcptraceroute </strong>向目的地发送TCP SYN数据包，从TTL == 1开始，每次得到一个结果后递增其值。尽管如此，我们必须接收TTL过期的icmp才能确定是谁丢弃了数据包——如果设备丢弃icmp，我们将无法获得它们。</p><p id="bfb2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">那为什么<strong class="ja hv"> tcptraceroute </strong>呢？因为如果最终主机不回复ping，它可能会回复您的TCP SYN数据包。或者中间的防火墙可能允许TCP流量入站，但不允许ICMP入站(并允许任何内容出站，包括TTL过期的ICMP)。<br/> <br/>从上面的截图中，我还想强调一个细节。理论上讲，tracert.exe跳应该增加它的延迟，即使它不到1毫秒并且不反映输出，但是为什么到达跳#6比到达跳#7花费更长的时间呢？ICMPs肯定不会回到过去。就我们现在所知，每一跳都是独立测量的，延迟是指我们发送ping命令后多久才能收到TTL过期的ICMP，在更远的一跳上有更高的延迟听起来并不疯狂。从上面的截图我不能确定，但很可能是这两个中的一个:</p><ul class=""><li id="7464" class="ls lt hu ja b jb jc jf jg jj lu jn lv jr lw jv lx ly lz ma dt translated"><strong class="ja hv"> ICMP节流</strong>:一些网络管理员，尤其是网络繁忙的ISP，配置策略以非常低的优先级回复这些ICMP，这样他们可能会非常快地将你的ICMP转发到下一跳，但是当他们必须回复时，他们可能会进一步延迟响应。</li><li id="f373" class="ls lt hu ja b jb mb jf mc jj md jn me jr mf jv lx ly lz ma dt translated"><strong class="ja hv">网络波动</strong>:路径中的一个设备可能比我们测试第7跳时负载更重。</li></ul><p id="3906" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">#6和#7之间的延迟差异不是很大，但在某些情况下，您可能会在更近的跃点上看到高达100毫秒的延迟。不要被这个迷惑，即使有那些奇怪的结果，也可能根本没有问题。</p><blockquote class="mg mh mi"><p id="e3e6" class="iy iz lr ja b jb jc jd je jf jg jh ji mj jk jl jm mk jo jp jq ml js jt ju jv hn dt translated">有趣的事实:Linux中的大多数traceroute实现默认使用UDP。</p></blockquote><p id="05c9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，同样，traceroute不一定“使用ICMP”，但它肯定依赖于它:-)。</p><p id="a8a6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你认为这篇文章有用或有趣，请不要忘记点击下面的小绿心，推荐给其他读者。如果你能在你最喜欢的社交网络上与你的朋友和同事分享，我会非常感激。你也可以看看 <a class="ae lm" href="https://wormhole.network/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">虫洞网络</em> </a> <em class="lr">，一家提供按需安全私有网络即服务的公司。你可能会感兴趣。</em></p><p id="cc71" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="lr">谢谢！</em></p><div class="la lb lc ld fq ab cb"><figure class="mm iv mn mo mp mq mr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mm iv mn mo mp mq mr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mm iv mn mo mp mq mr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mg mh mi"><p id="f922" class="iy iz lr ja b jb jc jd je jf jg jh ji mj jk jl jm mk jo jp jq ml js jt ju jv hn dt translated"><a class="ae lm" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是T21家庭的一员。我们现在<a class="ae lm" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lm" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz lr ja b jb jc jd je jf jg jh ji mj jk jl jm mk jo jp jq ml js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lm" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lm" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="la lb lc ld fq iv fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff ms"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>