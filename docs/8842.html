<html>
<head>
<title>A Space Adventure Introducing Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Python的太空冒险</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/https-medium-com-muzsik33-a-space-adventure-introducing-python-7cde79b53219?source=collection_archive---------9-----------------------#2017-12-17">https://medium.com/hackernoon/https-medium-com-muzsik33-a-space-adventure-introducing-python-7cde79b53219?source=collection_archive---------9-----------------------#2017-12-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d516" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">这篇文章不是针对绝对的初学者。这是专门为JS开发人员或类似的人准备的，他们正在寻找非常流行的编程语言Python的有趣介绍。解释了许多概念:多重继承，列表理解，语言的基础和特性。所有的代码都可以立即复制/粘贴到一个repl中，在文章的末尾有一个repl可以直接查看。</h2></div></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><h1 id="aa5c" class="jq jr hu bd js jt ju jv jw jx jy jz ka ja kb jb kc jd kd je ke jg kf jh kg kh dt translated"><strong class="ak">在90328443435329598个外星生物的宇宙中。两个新生命来自虚空… </strong></h1><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff ki"><img src="../Images/c8c52cdc8dcaf6de8d9a28c36e1f6605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9UGX6-8d6sOBpHDi2oe3Q.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Python Alien</figcaption></figure><blockquote class="ky"><p id="12b3" class="kz la hu bd lb lc ld le lf lg lh li ek translated">你好人类。我听说你叫马塞尔。而你是7530305890人类中的一员。</p><p id="2b2a" class="kz la hu bd lb lc lj lk ll lm ln li ek translated">我是一只<a class="ae lo" href="https://hackernoon.com/tagged/python" rel="noopener ugc nofollow" target="_blank">巨蟒</a>，我的名字叫圭多，是三只巨蟒之一。</p><p id="af91" class="kz la hu bd lb lc lj lk ll lm ln li ek translated">现在，有:90328443435329600外星生物。</p></blockquote><p id="f407" class="pw-post-body-paragraph lp lq hu lr b ls lt iv lu lv lw iy lx ly lz ma mb mc md me mf mg mh mi mj li hn dt translated">现在，一些代码，完全编译成上面写的:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">classes, multiple inheritance, __init__, def, self, global</figcaption></figure><p id="cc26" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">total_aliens = 90328443435329598</code>。也就是说Python是动态类型的。</p><p id="eb23" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">class Alien(object):</code>和<code class="eh mr ms mt mu b">class Human(Alien):</code>表示外星人类继承类对象，而人类继承外星人类。</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">def, __init__, self, and global</figcaption></figure><p id="2e3d" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">def</code>简单来说就是如何创建一个函数。</p><p id="3d80" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">__init__</code>是当一个类的新实例被创建时自动运行的，它是初始化器。</p><p id="5c41" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">self</code>:类中的每个方法都需要第一个参数。不一定非得是<code class="eh mr ms mt mu b">self</code>，但这是惯例。这就是self的目的，摘自对堆栈溢出的简明描述:</p><ul class=""><li id="09df" class="mv mw hu lr b ls mm lv mn ly mx mc my mg mz li na nb nc nd dt translated"><code class="eh mr ms mt mu b">instance_object.parent_class_method(arg)</code>内部转换为:<code class="eh mr ms mt mu b">parent_class.parent_class_method(instance_object, arg)</code>。所以<code class="eh mr ms mt mu b">self</code>将实例对象绑定到方法调用，类似于JS中的<code class="eh mr ms mt mu b">this</code>，需要注意一些微妙之处。</li></ul><p id="e995" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">最后，<code class="eh mr ms mt mu b">global</code>:如上所述编写它引用了全局变量，因此它可以在函数范围内修改。</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">super and pass</figcaption></figure><p id="71bf" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">super</code>与人类继承的直接父类，Alien交互。该参数将新实例的<code class="eh mr ms mt mu b">self.being</code>设置为等于<code class="eh mr ms mt mu b">human</code>。</p><p id="3a49" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">在Python中，当你写一个空函数、一个空的<code class="eh mr ms mt mu b">if/else</code>或任何类似的东西时，<code class="eh mr ms mt mu b">pass</code>是必要的。如果没有<code class="eh mr ms mt mu b">pass</code>会出现错误。</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Instance of class, print, dot notation</figcaption></figure><p id="6ae4" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">如图所示，创建了一个新实例。<code class="eh mr ms mt mu b">print</code>是一个人记录值的方式。</p><p id="cfcd" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">获取与类的实例相关联的值是通过点符号来完成的。</p><p id="521e" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">好了，接下来是功能性<a class="ae lo" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>和故事的继续。</p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="a038" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><em class="ne">人类，我有六项任务你必须完成才能离开这个星球:</em></p><p id="63f3" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">离开这个星球，有一个生成器函数，它运行你解决问题的每一个实例。这为你的飞船家园积累了燃料。这是功能:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek"><a class="ae lo" href="https://stackoverflow.com/questions/1756096/understanding-generators-in-python" rel="noopener ugc nofollow" target="_blank">Generator function</a>, there will be a longer explanation later</figcaption></figure><p id="6c6d" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><em class="ne">首先我给你一个列表(</em> <code class="eh mr ms mt mu b"><em class="ne">['str_1', 'str_2', …]</em></code> <em class="ne">)，里面会有六个字符串。你必须检查每个字符串的第一个字母在数字上是什么(a是0，b是1，等等。)，然后检查这个索引是否存在于列表中，最后将那个字符串添加到一个新列表中。返回新列表。</em></p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">list, for in, append, index, len</figcaption></figure><p id="8b7b" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">这将返回<code class="eh mr ms mt mu b">['damnation', 'fuggedaboutit', 'zoological', 'buttercup']</code>。</p><p id="25f5" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">[]</code>:在这种情况下，它是一个列表，而不是数组。它们略有不同。</p><ul class=""><li id="9a66" class="mv mw hu lr b ls mm lv mn ly mx mc my mg mz li na nb nc nd dt translated">主要区别:<code class="eh mr ms mt mu b">array([3, 6, 9, 12])/3.0</code>(数组语法)返回<code class="eh mr ms mt mu b">array([1, 2, 3, 4])</code>，而<code class="eh mr ms mt mu b">[3, 6, 9, 12]/3.0</code>(列表语法)返回错误。</li></ul><p id="3a74" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">for str in strs:</code>是Python中最常见的循环类型。它从第零个索引开始遍历每个索引的值。</p><p id="d1de" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">some_list.append(some_value)</code>将指定值推到列表末尾。</p><p id="f41d" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">some_list.index(some_value)</code>在列表中查找<code class="eh mr ms mt mu b">some_value</code>并返回值所在的第一个索引。如果没有找到，<code class="eh mr ms mt mu b">ValueError</code>异常发生。</p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="4c98" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">你的燃油量是17%。现在，一个不同的任务。另一个功能。第一个论点:一个单一的数字。第二个参数:一个字典( <code class="eh mr ms mt mu b"><em class="ne">{‘some_key': 'some_value', …}</em></code> <em class="ne">)，包含一个名为</em> <code class="eh mr ms mt mu b"><em class="ne">a_list</em></code> <em class="ne">的键，其值是一个充满字符串(</em> <code class="eh mr ms mt mu b"><em class="ne">'a_list':[...]</em></code> <em class="ne">)和分隔符(</em> <code class="eh mr ms mt mu b"><em class="ne">'separator': ‘something'</em></code> <em class="ne">)的列表。如是:</em> <code class="eh mr ms mt mu b"><em class="ne">{‘a_list': […], ‘separator': ‘something'}</em></code> <em class="ne">)。第一个参数指定使用列表中的多少个字符串。将用分隔符连接的每个字符串存储到一个变量或内存位置，并返回该值。</em></p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">range, dictionary</figcaption></figure><p id="962c" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">这返回:<code class="eh mr ms mt mu b">‘Trump is terrible! Genghis Khan is terrible! That noisy person is terrible! ’</code></p><p id="adb5" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">range(num)</code>是指定个数的迭代器。如果只有一个参数，它将从零开始迭代到数字减一。Range可以接受三个参数，这类似于一个精简的for循环:<code class="eh mr ms mt mu b">range(-10, -100, -30) =&gt; -10 -40 -70</code>，无论<code class="eh mr ms mt mu b">for this_thing_is in range(...)</code>是什么，<code class="eh mr ms mt mu b">=&gt;</code>都是值。</p><p id="2eba" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">{...}</code>:字典是无序的键/值对或者关联数组。关键字必须是字符串，要通过括号符号访问值，还必须插入一个字符串值或变量名。</p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="7bd3" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">你现在的利率是34%。接下来，我给出一个更令人困惑的挑战。首先，你不知道给出了多少个论点！第一组参数包含数字、值None或字符串。第二组包含以这种方式关联的键/值对: <code class="eh mr ms mt mu b"><em class="ne">some_keyword=some_value</em></code> <em class="ne">。</em> <code class="eh mr ms mt mu b"><em class="ne">some_keyword</em></code> <em class="ne">将是一个字符串。</em> <code class="eh mr ms mt mu b"><em class="ne">some_value</em></code> <em class="ne">将是一个数字。归还字典。一个键/值。密钥只能是我第一次给你的逆序字符串(参数)。该值必须是串联字符串，仅使用从零索引到指定为该值的数字的关键字中的字符串，所有字符串都是一个不带空格的字符串。</em></p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">tuples (reversed), enumerate, if/elif/else, is None, isinstance(arg, int)</figcaption></figure><p id="74a6" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">这登出:<code class="eh mr ms mt mu b">{‘big amazing animal’: ‘elephant’}</code>。</p><p id="58fd" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">如果您在<code class="eh mr ms mt mu b">reversed(args)</code>之前输出参数，您会看到参数是:<code class="eh mr ms mt mu b">(‘animal’, ’amazing', None, 6, ‘big')</code>。这是一个元组。不可变对象的序列。元组是用括号写的，它们不能像列表或数组那样在特定索引处改变。</p><p id="1d4a" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">enumerate</code>允许用户拥有自动计数器并同时访问数值。</p><p id="a3de" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">if/elif/else</code>就是如何写if/else语句。</p><p id="7b95" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">is None</code>是返回true或false值以检查<code class="eh mr ms mt mu b">None</code>值的方式。它类似于<code class="eh mr ms mt mu b">null</code>，但在JS中更类似于<code class="eh mr ms mt mu b">undefined</code>，因为许多代码实例都可以返回这个值，比如当一个人通过一个更高阶的函数改变一个列表时，他不期望返回一些东西，或者当一个函数不返回任何东西时，它返回<code class="eh mr ms mt mu b">None</code>。</p><p id="b542" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">isinstance(arg, int)</code>用于检查arg是否是指定类的实例。<code class="eh mr ms mt mu b">int</code>在这种情况下也可以这样表达:</p><ul class=""><li id="79b9" class="mv mw hu lr b ls mm lv mn ly mx mc my mg mz li na nb nc nd dt translated"><code class="eh mr ms mt mu b">isinstance(marcel, Alien)</code>还真会。类、字符串、整型和所有你期望的都可以用这种方式检查。</li></ul></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="efd9" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><em class="ne">好，很好。你现在是51%。现在，一个有趣的问题。给你一个矩阵。一个列表中有三个列表，每个列表里面有四个字符串。首先，创建一个新列表，将每个列表的每个索引关联起来，如下:(</em> <code class="eh mr ms mt mu b"><em class="ne">[[[0][0], [1][0], [2][0]…],[[0][1], [1][1]…], ...]</em></code> <em class="ne">)然后，将每个列表展平成一个字符串，最后将该列表连接成一个字符串。你可以把所有这些逻辑放入一个语句中…一个列表理解。</em></p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">This needs explanation…</figcaption></figure><p id="f345" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">这返回:<code class="eh mr ms mt mu b">You must make it look this way. Very extremely, magically, important thing to do!</code></p><p id="f281" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">第一:<code class="eh mr ms mt mu b">[[row[i] for row in matrix] for i in range(4)]</code>。同样的事情:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">new list =&gt; loop through rows =&gt; append values into new row =&gt; append row into new list</figcaption></figure><p id="158f" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">人们必须从最外层的括号/逻辑来思考。</p><p id="d383" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">所以:<code class="eh mr ms mt mu b">[all_the_logic]</code>就是说:创建一个新的列表，这里所做的一切将决定列表最终的样子。</p><p id="d720" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">[[some_inner_logic] for i in range(4)]</code>:这将指定有4行，无论<code class="eh mr ms mt mu b">[row[i] for row in matrix]</code>在每个实例中的结果是什么，每行都将是什么。</p><p id="1b50" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">[row[i] for row in matrix]</code>表示使用范围的索引i (0，1，2，3 ),因为在创建第一、第二、第三和第四行时它是常数。在每行创建过程中，都会出现这种情况:</p><ul class=""><li id="c640" class="mv mw hu lr b ls mm lv mn ly mx mc my mg mz li na nb nc nd dt translated">循环遍历<code class="eh mr ms mt mu b">matrix</code> = &gt;中的每一行，将<code class="eh mr ms mt mu b">row[i]</code>处的值推入这个新创建的列表= &gt;将这个列表附加到最初创建的列表中。</li></ul><p id="3bac" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">此时，创建的内容如下:<code class="eh mr ms mt mu b">[['You’, ‘must', ‘make'], ['it', ‘look', ‘this'], ['way.', ‘Very', ‘extremely,'], ['magically', ‘important', ‘to do!']]</code>。转置矩阵。</p><p id="ab8b" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">到:<code class="eh mr ms mt mu b">[str for sublist in [transposed_matrix] for str in sublist]</code></p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">new list =&gt; individual string in row =&gt; append strings to new list</figcaption></figure><p id="2a2c" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">同样，从外向内的括号。</p><p id="0ea4" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">创建新列表:<code class="eh mr ms mt mu b">[result_of_logic]</code></p><p id="38fd" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">从最左边开始读for循环:<code class="eh mr ms mt mu b">sublist in [transposed_matrix]</code>就是说:从第一个开始，遍历矩阵中的每个列表。</p><p id="f71d" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">然后读取下一个for循环:<code class="eh mr ms mt mu b">for str in sublist</code>。这相当于说在这个<code class="eh mr ms mt mu b">sublist</code>内循环通过每个<code class="eh mr ms mt mu b">str</code>。这是现在可以添加到列表中的值。</p><p id="24e6" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">最后看列表理解的开头:<code class="eh mr ms mt mu b">str</code>。那就是追加到列表中的:<code class="eh mr ms mt mu b">['current_str', 'second_str', ...]</code>。因此，在某种程度上，最左边的值被推入新创建的列表，直到循环结束。仿佛<code class="eh mr ms mt mu b">append</code>自动出现。</p><p id="8dd6" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">至于:<code class="eh mr ms mt mu b">''.join(final_list)</code>，<code class="eh mr ms mt mu b">''</code>是字符串分隔符。</p><p id="8682" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">注意最左边的<code class="eh mr ms mt mu b">for</code>循环是如何首先出现的，再往右是嵌套。</p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="05dd" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">好了，现在你已经达到了68%,只剩下两个了！这个我需要你创建一个工厂函数。将有五个功能要实现。 <code class="eh mr ms mt mu b"><em class="ne">append</em></code> <em class="ne">(推到列表末尾)、</em> <code class="eh mr ms mt mu b"><em class="ne">extend</em></code> <em class="ne">(将一个列表连接到另一个列表)、</em> <code class="eh mr ms mt mu b"><em class="ne">insert</em></code> <em class="ne">(将项目插入特定索引)、</em> <code class="eh mr ms mt mu b"><em class="ne">remove</em></code> <em class="ne">(删除指定项目的每个实例)、以及</em> <code class="eh mr ms mt mu b"><em class="ne">pop</em></code> <em class="ne">(弹出列表中的最后一个项目)。您不能使用高阶函数等价物，并且您创建的每个函数</em> <strong class="lr hv"> <em class="ne">都不能改变原始列表</em> </strong> <em class="ne">。你有三到四个论点。</em></p><ol class=""><li id="f2e9" class="mv mw hu lr b ls mm lv mn ly mx mc my mg mz li nf nb nc nd dt translated"><em class="ne">一份名单</em></li><li id="eaeb" class="mv mw hu lr b ls ng lv nh ly ni mc nj mg nk li nf nb nc nd dt translated"><em class="ne">字符串形式的函数名</em></li><li id="d31a" class="mv mw hu lr b ls ng lv nh ly ni mc nj mg nk li nf nb nc nd dt translated"><em class="ne">函数需要的一个参数，如果它需要四个参数，则索引(用于插入)</em></li><li id="dc4c" class="mv mw hu lr b ls ng lv nh ly ni mc nj mg nk li nf nb nc nd dt translated"><em class="ne">一个条目(仅插入时需要)</em></li></ol><p id="f4c1" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><em class="ne">好吧，祝你好运！</em></p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">slices, list concatenation</figcaption></figure><p id="b641" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">要知道，这些功能中的每一个都不是实现这一点的最佳方式。使用相关的高阶函数要快得多。另外，要知道除了返回弹出内容的<code class="eh mr ms mt mu b">pop</code>之外，高阶函数都返回<code class="eh mr ms mt mu b">None</code>。</p><p id="a42f" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">append</code>和<code class="eh mr ms mt mu b">extend</code>:这简直就是Python的精妙之处。将一个列表添加到另一个列表会自动连接这两个列表。<code class="eh mr ms mt mu b">li.append(item)</code>和<code class="eh mr ms mt mu b">li.extend(other_li)</code>是正确的语法，但是这两个选项会改变原始列表，而上面写的选项不会。<code class="eh mr ms mt mu b">extend</code>中的<code class="eh mr ms mt mu b">other_li</code>虽然没有变异。</p><p id="1ce7" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">insert</code>和<code class="eh mr ms mt mu b">pop</code>在这种情况下都使用切片。我会关注<code class="eh mr ms mt mu b">insert</code>。注意:<code class="eh mr ms mt mu b">the_list[:idx]</code>:这意味着将列表切片到索引，但不包括它。<code class="eh mr ms mt mu b">the_list[idx:]</code>:就是从索引开始切片，包括索引到列表的最后一个索引。</p><p id="7134" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">remove</code>:简单的列表理解(他们是极快的操作btw)。<code class="eh mr ms mt mu b">[x for x in the_list if x != item]</code>:<code class="eh mr ms mt mu b">new_list = []</code>=&gt;<code class="eh mr ms mt mu b">for x in the_list:</code>=&gt;<code class="eh mr ms mt mu b">if x != item:</code>=&gt;<code class="eh mr ms mt mu b">new_list.append(x)</code>or，但技术上不是<code class="eh mr ms mt mu b">new_list += [x]</code>。但是，请注意，真正的<code class="eh mr ms mt mu b">li.remove(item)</code>只会删除该项的第一次出现。此<code class="eh mr ms mt mu b">remove</code>删除所有事件。</p></div><div class="ab cl jj jk hc jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hn ho hp hq hr"><p id="be15" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><em class="ne">非常好，进入下一个。你还有85%的燃料，这是最后一次了！下一个有点奇怪，因为它是两个功能合二为一。我会给你一个广泛的关键字和论点分类。您的函数将被多次调用，调用的参数数量是随机的，或者没有参数。和/或多种关键字。我需要你把我给你的所有参数值存储在一个非全局列表中，把所有关键字值存储在一个非全局字典中。返回字典as so: </em> <code class="eh mr ms mt mu b"><em class="ne">{'the_list': [...], 'the_dictionary': {...}}</em></code> <em class="ne">。每次调用该函数时，根据输入</em> <strong class="lr hv"> <em class="ne">，列表或字典都会发生变化，所有值都会附加到之前调用的值中。</em>T25】</strong></p><p id="f0c0" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">最后，最终调用列表作为第一个参数被解包，字典作为第二个参数被解包到另一个函数中。</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">mutating default arguments, unpacking a list, unpacking an object</figcaption></figure><p id="aba5" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated"><code class="eh mr ms mt mu b">(*args, li=[], dic={}, **keywords)</code>:注意，在这两个调用之间有两个不是关键字或参数的参数，这是必需的。</p><p id="26aa" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">但是真正奇怪的部分，为什么<code class="eh mr ms mt mu b">li</code>和<code class="eh mr ms mt mu b">dic</code>在每次函数调用过程中不断变异？Python不会为每个函数调用创建每个参数的副本，而是保存一个对原始默认参数的引用，如果不小心的话，他们很容易陷入创建不纯函数的陷阱。</p><p id="11f8" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">至于这个:<code class="eh mr ms mt mu b">back_to_earth(*dictionary_and_list()['a_list], </code>:这就是如何将一个列表解包到一个函数中，这样列表中的每一项都成为一个单独的参数。用<code class="eh mr ms mt mu b">*args</code>抓取数值。至于<code class="eh mr ms mt mu b">**dictionary_and_list()['a_dictionary])</code>:这将字典值解包到函数参数中。在字典中有相关键的函数中的每个关键字将被赋予该值。</p><p id="10b3" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">以及代码输出的内容:</p><blockquote class="ky"><p id="db6b" class="kz la hu bd lb lc lj lk ll lm ln li ek translated"><em class="nl">好吧，你那里:100%！好了，你完了，是时候离开这个Python世界了。祝贺你取得的所有成就！再见！<br/>前进<br/> 3 <br/>后退<br/> 2 <br/>到<br/> 1 <br/>大地！<br/> 0 </em></p></blockquote><p id="d361" class="pw-post-body-paragraph lp lq hu lr b ls lt iv lu lv lw iy lx ly lz ma mb mc md me mf mg mh mi mj li hn dt translated">最后但同样重要的是，在每个函数完成后，我运行<code class="eh mr ms mt mu b">liftoff.__next__()</code>。正如您在下面的代码中看到的。有一点要知道。如果再运行一次，就会出现错误。为什么？嗯，生成器函数只能读一次，不能再读了。所以当迭代结束时，不再有<code class="eh mr ms mt mu b">.__next__()</code>，所有先前的值都被垃圾收集了。</p><p id="26af" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">所有代码都在一个地方:</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="0c8f" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">和回复:</p><div class="nm nn fm fo no np"><a href="https://repl.it/@jerrymuzsik/pythonIntroductionArticle" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab ej"><div class="nr ab ns cl cj nt"><h2 class="bd hv fv z el nu eo ep nv er et ht dt translated">@jerrymuzsik的文章</h2><div class="nw l"><h3 class="bd b fv z el nu eo ep nv er et ek translated">文章中的所有代码都放在一个地方。回复它</h3></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks np"/></div></div></a></div><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff od"><img src="../Images/7cdd2091df5cc2f3ef30b98e6422d5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4A683TJgtsEyCueGJLVNA.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">This is Guido, Python alien</figcaption></figure><p id="225f" class="pw-post-body-paragraph lp lq hu lr b ls mm iv lu lv mn iy lx ly mo ma mb mc mp me mf mg mq mi mj li hn dt translated">其他一些需要注意的事项:</p><ol class=""><li id="b91d" class="mv mw hu lr b ls mm lv mn ly mx mc my mg mz li nf nb nc nd dt translated">文件名、变量名和函数名用下划线命名。</li><li id="6e87" class="mv mw hu lr b ls ng lv nh ly ni mc nj mg nk li nf nb nc nd dt translated">缩进:约定为4个空格。</li><li id="40fb" class="mv mw hu lr b ls ng lv nh ly ni mc nj mg nk li nf nb nc nd dt translated">CamelCase用的不多，只在课堂上用。</li><li id="de67" class="mv mw hu lr b ls ng lv nh ly ni mc nj mg nk li nf nb nc nd dt translated">如果变量是globalthenitisalllowercase(如果变量是全局的，那么它全部是小写的)。</li></ol><blockquote class="oe of og"><p id="4d8d" class="lp lq ne lr b ls mm iv lu lv mn iy lx oh mo ma mb oi mp me mf oj mq mi mj li hn dt translated">感谢你的阅读。任何建议，想法，评论，想法，掌声，或其他任何你觉得与这篇文章有关的事情，都将不胜感激！</p></blockquote><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="ok ml l"/></div></figure></div></div>    
</body>
</html>