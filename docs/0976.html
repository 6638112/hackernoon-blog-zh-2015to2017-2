<html>
<head>
<title>Realm for Android and initial seed data: Pre-populating from Json and extracting the database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android领域和初始种子数据:从Json预填充并提取数据库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/realm-for-android-pre-populating-from-json-and-extracting-the-database-8709a2f8db18?source=collection_archive---------1-----------------------#2016-08-01">https://medium.com/hackernoon/realm-for-android-pre-populating-from-json-and-extracting-the-database-8709a2f8db18?source=collection_archive---------1-----------------------#2016-08-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3c9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我曾经遇到过创建一个使用Realm的应用程序的“麻烦”,这个应用程序的数据库中已经填充了数据，并且在发布的应用程序中只包含创建的<a class="ae jp" href="https://hackernoon.com/tagged/database" rel="noopener ugc nofollow" target="_blank">数据库</a>文件，而忽略了用来填充它的Json(或任何其他文件)。</p><p id="d9b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为“待发布”的应用程序这样做可以节省时间(解析文件和填充数据库)和空间(省略用于创建数据库的文件)。</p><h2 id="87f6" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">主要思想:</h2><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kl"><img src="../Images/19985aa2f98da187db14595359f822cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQvB05sc2bdd4rY95P9gBQ.png"/></div></div></figure><p id="239d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将展示实现这一点的最简单的方法，但这还可以改进(也许是一个单独的<a class="ae jp" href="https://hackernoon.com/tagged/gradle" rel="noopener ugc nofollow" target="_blank"> Gradle </a>任务？)甚至成为主项目的一部分，不必为一个app维护2个代码库和2个不同的项目。</p><h2 id="5151" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">对于草率的</h2><blockquote class="kx ky kz"><p id="d64c" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">这个项目在<a class="ae jp" href="https://github.com/chronvas/RealmTesting" rel="noopener ugc nofollow" target="_blank"> Github </a>上，但是先检查“记住”部分</p></blockquote><h1 id="58f8" class="le jr hu bd js lf lg lh jw li lj lk ka ll lm ln kd lo lp lq kg lr ls lt kj lu dt translated">开始！</h1><p id="54c0" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">我用的是Android Studio (3.1)和Realm Java版本5.0.0。项目的build.gradle如下所示:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="4fe5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">app模块的build.gradle如下所示:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="8492" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是时候添加一个扩展android.app.Application的类了，所以我们的整个应用程序从这个类开始，Realm在OnCreate上进行初始化和配置。为您的设置名称非常方便。包含数据库的领域文件。这样可以<a class="ae jp" href="https://realm.io/docs/java/latest/api/io/realm/RealmConfiguration.Builder.html" rel="noopener ugc nofollow" target="_blank">通过</a>更多的配置。只要记得在Android清单中指出这个类就行了。</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="6e17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们需要Json文件。出于简洁的原因，一个简单的文件命名为“people.json”:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="12d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">的。json文件必须放在原始资源中才能被访问。如果原始资源文件夹不存在，请创建它</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff mc"><img src="../Images/48966a36e83c6629d6f2391e74e44612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*24q8D80jhFg_SpzIfbvmMg.png"/></div></div></figure><p id="ac75" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用于解析Json的表示Java类:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><h2 id="04af" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">好吧！是时候进行解析了</h2><p id="e9d5" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">通常，我们会使用一个扩展AsyncTask的助手类。但是由于Realm.executeTransaction，我们可以用这个内置方法来代替。</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="9ac7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和一个简单的呼叫按钮。importFromJson()</p><p id="d96f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，调用importFromJson不会删除数据库或其中的数据，它只是添加Json解析的结果。</p><p id="133b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Android monitor上，我们可以查看完成所需的时间，可能是从已发布的应用程序中节省的时间。</p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff md"><img src="../Images/58fecd1949e6e8e70ef9418dceba02e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*N5duMdW0sdu6p1KKF5Y0Ew.png"/></div></div></figure><h1 id="2290" class="le jr hu bd js lf lg lh jw li lj lk ka ll lm ln kd lo lp lq kg lr ls lt kj lu dt translated">现在，我的。领域数据库文件？</h1><p id="e385" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">一旦你把应用程序运行到一个设备上，在Android Studio中，打开“设备文件浏览器”，导航到“Data / Data / <package name=""> / files”目录下你就可以找到了。领域文件，并将其拖到您的计算机上。</package></p><figure class="km kn ko kp fq kq fe ff paragraph-image"><div class="fe ff me"><img src="../Images/b514c595cfac6285c67bce379221962c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*crA6Ps_YtOKMMs2AaUPSjA.png"/></div></figure><h2 id="3fe4" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">成功了吗？</h2><p id="6c35" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">为了简单起见，您可以添加另一个按钮来返回在数据库中找到的人数。这两个简单按钮的代码可能如下所示:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="8fa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在拿着。realm文件，并再次将其放在raw resources下，以用作数据库。</p><h1 id="dcf1" class="le jr hu bd js lf lg lh jw li lj lk ka ll lm ln kd lo lp lq kg lr ls lt kj lu dt translated">在“待发布”应用程序上</h1><p id="a286" class="pw-post-body-paragraph ir is hu it b iu lv iw ix iy lw ja jb jc lx je jf jg ly ji jj jk lz jm jn jo hn dt translated">只要把。领域文件，并使用App.java上的copyBundledRealmFile方法将其复制到适当的位置(FilesDir)。</p><p id="128e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我添加了一个<strong class="it hv"><em class="la">shouldOverwriteDatabaseOnAppStartup</em></strong>标志，如果你想在每次应用程序启动时用一个新的覆盖数据库，或者只保留应用程序第一次运行时copyBundledRealmFile创建的数据库:</p><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="ma mb l"/></div></figure></div><div class="ab cl mf mg hc mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hn ho hp hq hr"><h1 id="4d14" class="le jr hu bd js lf mm lh jw li mn lk ka ll mo ln kd lo mp lq kg lr mq lt kj lu dt translated">谨记！</h1><ul class=""><li id="2219" class="mr ms hu it b iu lv iy lw jc mt jg mu jk mv jo mw mx my mz dt translated">将<strong class="it hv"><em class="la">shouldOverwriteDatabaseOnAppStartup</em></strong>标志设置为true，<strong class="it hv">每次应用程序启动</strong>时，它都会复制或覆盖。领域数据库从原始目录到/files目录，所以请记住，无论你做什么改变，它将在App.java调用时丢失。为了演示这个“问题”,我又添加了2个按钮来更改和查询第一个人的名字。<strong class="it hv">为了避免这种</strong>，将标志设置为false，这将在写入之前检查文件是否存在。领域文件。</li><li id="1a7d" class="mr ms hu it b iu na iy nb jc nc jg nd jk ne jo mw mx my mz dt translated">的。领域文件仍有2个实例。在原始资源目录和/files目录中。所以节省空间是不完全的。</li><li id="8e84" class="mr ms hu it b iu na iy nb jc nc jg nd jk ne jo mw mx my mz dt translated">在读取数据库时，不要忘记使用正确的数据模型，或者在需要时使用领域迁移。</li></ul><blockquote class="kx ky kz"><p id="599e" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">我希望这篇文章对你有用。这个项目可以在这里找到<a class="ae jp" href="https://github.com/chronvas/RealmTesting" rel="noopener ugc nofollow" target="_blank">https://github.com/chronvas/RealmTesting</a></p><p id="71ec" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">特别感谢Kenneth Geisshirt阅读本文并建议realm . execute transaction over async task</p></blockquote><div class="km kn ko kp fq ab cb"><figure class="nf kq ng nh ni nj nk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nf kq ng nh ni nj nk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nf kq ng nh ni nj nk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="kx ky kz"><p id="f922" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="708a" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="km kn ko kp fq kq fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nl"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="km kn ko kp fq kq"><div class="bz el l di"><div class="nm mb l"/></div></figure></div></div>    
</body>
</html>