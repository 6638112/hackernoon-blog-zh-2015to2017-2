# 使用 Lerna 管理 JavaScript 项目的优势和劣势

> 原文：<https://medium.com/hackernoon/the-highs-and-lows-of-using-lerna-to-manage-your-javascript-projects-ff5c5cd82a99>

![](img/09ac096751f047b4b0c1b32d05fd127d.png)

概述、难点、亮点和提示

Lerna 是一个用多个包管理大规模 [JavaScript](https://hackernoon.com/tagged/javascript) 项目的[工具。](https://hackernoon.com/tagged/managing)

任何参与过由粒度组件或依赖项组成的大型项目的人都知道，过一段时间后对您的工作进行更新会变得很麻烦。在 2017 年的 JavaScript 世界中，我们到处都在导入包，Lerna 正在帮助我们管理我们在 Yoox NET-A-PORTER 的大项目。

## 谁在用 Lerna？

*   巴贝利斯
*   创建-反应-应用
*   反应路由器
*   玩笑
*   [还有很多很多更多](https://lernajs.io/#users)

## 它真正的作用&为什么它很棒

让我们从一个例子开始。

假设您有一个带有按钮组件的 React 应用程序——这个按钮组件需要使用一个文本组件(粒度很细，但只是为了举例方便):

```
// inside the super-button NPM package + repoimport SuperText from 'super-text'const SuperButton = props => (
  <button>
    <SuperText value="Click me!" />
  </button>
)export default SuperButton // inside the super-text NPM package + repoconst SuperText = props => (
  <span>
    {props.value}
  </span>
)export default SuperText
```

这些组件中的每一个都存在于它们自己的回购协议中，并且是它们自己的 NPM 包——它们需要由 20 多个开发人员来维护、版本化和工作。

假设我们有一个使用这两个组件的应用程序——如果我们想更新这两个组件作为特性的一部分，那么我们必须对每个组件进行更改，更新测试，更新版本，提交更改，让他们接受代码审查，发布包，更新使用它们的应用程序——唷。

**但是等等！**您刚刚意识到您的更改与需求略有不同，并且/或者它没有按预期工作——让我们假设这些组件要复杂得多，或者可能涉及复杂的样式等。您将不得不再次重做整个过程——如果您的团队很忙，也许他们不会抽出时间来审查代码，也许您将在接下来的 2 个小时内被阻止，并且不得不求助于阅读中型文章，直到他们解除对您的阻止！

Lerna 来救援了！ Lerna 让你把你的应用构建成一个非常大的包和应用库(都可以重命名和配置)；这些应用程序是消费者，包是粒度依赖(上面的超级按钮&超级文本)。当您完成所有需要的更改后，您可以执行一个命令:

`$ lerna run bootstrap`

这将遍历您的所有应用程序(在我们自己命名的`apps`文件夹中),并通过使用各自的包名(和版本)将每个应用程序依赖项符号链接到在`packages`中找到的任何本地版本。)在`package.json`。任何在`packages`中找不到的都将简单地从 npm 中安装，无论如何都是一样的。

这是巨大的——它允许大规模重构、更新和特性丰富，而没有*开发人员过程头痛*。对您的依赖项进行更改，引导、检查并在您的消费者应用中实施它们，您就大功告成了！保存拉取请求，直到一切就绪。

## 为什么它会令人讨厌&如何减轻痛苦

听起来很棒，对吧？我们最初是这样想的，后来我们在移植我们的大型应用程序时遇到了一些麻烦——我们基本上解决了所有这些问题:

*   **如果每个应用程序都有很多依赖项，引导会花费很长时间。** 2017 年的 web 开发通常意味着你有 500 多个依赖于运行你的应用程序的各种各样的包——无论是构建步骤、编译、捆绑、可重用的组件，还是简单地用 *left-pad* 你的字符串。
    通过将应用程序&包之间的所有共享依赖关系移动到一个根`package.json`文件中，并在引导命令中指定`--hoist`标志，来缓解这一问题。虽然还需要一段时间，但会大大缩短时间。
*   **测试运行时间很长，并且失去语法高亮。**
    `$ lerna run test`命令遍历每个包并运行在`package.json`中声明的测试脚本——这里的问题是它将为它找到的每个实例生成一个测试运行程序——在我们的例子中，我们有大约 60 个实例，它们耗尽了我们的笔记本电脑。这也意味着我们的语法突出显示(通过/失败/警告等)被忽略了，因为测试运行是在单独的 shell 进程中产生的。
    通过从根级别运行测试运行程序来解决这个问题，在那里有一个配置文件来指定在哪个目录中查找测试——我们使用 jest，配置文件使这一切变得非常容易。我们的测试从大约 2m 运行到大约 15s，我们的颜色编码恢复了！
*   **与一家大型回购公司合作的方式。我们仍在逐步解决这个问题，这将取决于您的项目、团队结构和需求——如果您正在构建一个由可重用的原子组件组成的大型共享平台，您有时会问自己“谁拥有这个平台？”通常答案是*每个人* *都应该*但是事情并不总是那样发展，这是另一篇博文的话题。**

我们仍在适应雷纳，这是一条充满挫折的崎岖之路，但最终会得到最好的解决。这对我们的项目很有帮助，也可能对你的项目有帮助。

## 想了解更多关于 Lerna 的知识？

查看[官方网站](https://lernajs.io/)或查看 [github 页面](https://github.com/lerna/lerna)

*喜欢我的漫谈吗？在* [*twitter*](https://twitter.com/_ChrisGreg) *上关注我，在我的* [*个人网站*](http://chrisgregori.co.uk/) *上了解更多我的开发故事或关注我的业余项目。💻*