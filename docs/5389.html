<html>
<head>
<title>From Reds to RediSearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从红色到再研究</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/from-reds-to-redisearch-680f79257420?source=collection_archive---------5-----------------------#2017-07-24">https://medium.com/hackernoon/from-reds-to-redisearch-680f79257420?source=collection_archive---------5-----------------------#2017-07-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4d0f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">Redis搜索变得更有趣了</h2></div><p id="1125" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你听说了吗？Redis 4.0出来了。这意味着<strong class="jl hv">模块</strong>。不仅仅是在理论上，不应该在生产中运行。意思是黄金时间。把它们扔到你的生产服务器上然后走人。</p><p id="204b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">注意:Redis(数据库)和node . JS(JS运行时)都使用“模块”这一术语来表示不同的概念——这里的语言需要稍加修饰才能清楚和区分。</em></p><p id="24db" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近我<a class="ae kg" rel="noopener" href="/@stockholmux/the-road-to-redis-chapter-3-b9796362c809">写了关于</a> <a class="ae kg" href="https://www.npmjs.com/package/reds" rel="noopener ugc nofollow" target="_blank">红人</a>，<a class="ae kg" href="https://hackernoon.com/tagged/node-js" rel="noopener ugc nofollow" target="_blank"> Node.js </a> /Redis搜索引擎模块。red相当不错——我已经围绕它构建了完整的web服务，它们运行得非常快。然而，Node.js是<a class="ae kg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>，Javascript虽然速度相当快，但仍然被解释，并且与数据库(Redis)在完全不同的层上。然而，模块是用编译语言构建的，在逻辑和数据之间没有网络层。他们必须更快，对吗？这就是我的任务——模块比脚本快多少。让我们来了解一下！</p><h2 id="a1ad" class="kh ki hu bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb dt translated">输入:重新搜索</h2><p id="f94b" class="pw-post-body-paragraph jj jk hu jl b jm lc iv jo jp ld iy jr js le ju jv jw lf jy jz ka lg kc kd ke hn dt translated">我维护red已经很多年了，我非常熟悉代码和脚本的使用。几个月来，我也一直在关注再搜索的发展(这篇关于再搜索的白皮书引起了我的兴趣)。它已经从简单的东西发展成非常强大的东西:</p><ul class=""><li id="1d79" class="lh li hu jl b jm jn jp jq js lj jw lk ka ll ke lm ln lo lp dt translated">RediSearch有自己的模块系统用于扩展<em class="kf">(触发艾勒比图像宏关于模块内部的模块)</em></li><li id="cd97" class="lh li hu jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp dt translated">在RedisConf 17期间，展示了一个RediSearch集群实现的预览演示，它以100k documents/sec的速度索引了超过10亿(是的，a <strong class="jl hv"> b </strong>)个文档。</li></ul><p id="e235" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了变音位索引，<a class="ae kg" href="http://redisearch.io/" rel="noopener ugc nofollow" target="_blank">redsearch</a>拥有red拥有的一切，甚至更多。我的目标是看看我是否能设计出Reds功能来重新搜索并创建一个(或多或少)语法兼容的Node.js模块:RedRediSearch。语法兼容性将允许red的现有用户进行相当轻松的“推倒重来”。</p><h2 id="99ca" class="kh ki hu bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb dt translated">微小的差异</h2><p id="f9d2" class="pw-post-body-paragraph jj jk hu jl b jm lc iv jo jp ld iy jr js le ju jv jw lf jy jz ka lg kc kd ke hn dt translated">不幸的是，你不能仅仅指向Reds数据的重新搜索并神奇地获得性能，你需要重新索引你的数据。RediSearch是一个Redis模块，与使用原生zsets的red相比，它使用不同的(坦率地说，更有效的)定制数据类型。除此之外，它是无痛的。你会发现索引非常快。</p><p id="d21e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">“自然语言处理”功能不能映射，尽管您可能不需要它，或者可以通过对您的索引进行一些调整来实现(我将在后面介绍)。另一件事是，创建索引在概念上是不同的——在red<em class="kf">中，red . create search</em>只准备Node.js接受数据。然而，在RediSearch中，创建一个索引是一个真正的Redis调用(<a class="ae kg" href="http://redisearch.io/Commands/#ftcreate" rel="noopener ugc nofollow" target="_blank"> FT。创建</a>，因此需要回调。除此之外，搜索和索引是相同的语法。改编我的一些脚本就像调整3-4行代码一样简单。我还添加了一个函数来确认模块的存在。我就是这么好的人。</p><h2 id="b596" class="kh ki hu bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb dt translated">你从红方的再研究中得到了什么？</h2><p id="5f94" class="pw-post-body-paragraph jj jk hu jl b jm lc iv jo jp ld iy jr js le ju jv jw lf jy jz ka lg kc kd ke hn dt translated">你会有更好的表现。在同一台机器上对相同的数据运行<a class="ae kg" href="https://github.com/tj/reds/blob/master/benchmarks/index.js" rel="noopener ugc nofollow" target="_blank"> Reds基准</a>，我在索引时的Reds重搜索性能提高了6.6到13倍(取决于文档的大小)。查询速度也更快—快了1.2到7.4倍。整个基准测试的完成速度提高了12倍。这是一个巨大的进步。</p><div class="lv lw lx ly fq ab cb"><figure class="lz ma mb mc md me mf paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/bff6a8ed9ab4e33a70189f74d32efc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*zv3CFZNcH00-2L1LMkD24Q.png"/></div></figure><figure class="lz ma mm mc md me mf paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><img src="../Images/b56c676f69430652e3d61a5a7b687253.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*OZJ1GypeOPFwpUkpnT_xlg.png"/></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek mr di ms mt">Yowza! Note: “ops” here are whole documents or search queries indexed per sec, not Redis operations per second!</figcaption></figure></div><p id="b130" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是在一台普通的笔记本电脑上，没有安装OSS Redis。</p><p id="05b5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">切换到RedRediSearch的另一个好处是一个更丰富、更灵活的查询系统。</p><p id="d447" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">切换到RedRediSearch的另一个好处是一个更丰富、更灵活的查询系统。</p><p id="49eb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">red有两种搜索能力:AND和OR。也就是说，您只能查询包含其中一个查询关键字或所有查询关键字的文档。有用，但是不太灵活。</p><p id="05da" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有了RediSearch，你就有了一个丰富的查询语言，可以让你做所有red能做的事情，还可以进行精确短语搜索、否定搜索、前缀搜索、可选关键字和组合搜索。开箱即用，RedRediSearch可以适应语法兼容的搜索:</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="bc36" class="kh ki hu mv b fv mz na l nb nc">//defaults to an "AND" search<br/>search<br/>  .query('cat dog')<br/>  .end(function(err, documents){<br/>     /* ... */<br/>  });</span><span id="9c77" class="kh ki hu mv b fv nd na l nb nc">//using the `type` fn to get an "OR" search<br/>search<br/>  .query('cat dog')<br/>  .type('or')<br/>  .end(function(err, documents){<br/>     /* ... */<br/>  });</span></pre><p id="7f7d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是您也可以通过指定如下的直接搜索来利用这种很酷的查询语言:</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="65ef" class="kh ki hu mv b fv mz na l nb nc">//documents without 'dog' but with 'cat'<br/>search<br/>  .query('cat -dog')<br/>  .type('direct')<br/>  .end(function(err, documents){<br/>     /* ... */<br/>  });</span><span id="7316" class="kh ki hu mv b fv nd na l nb nc">//documents with 'dog' and optionally with 'cat' but having 'cat' will boost placement<br/>search<br/>  .query('cat ~dog')<br/>  .type('direct')<br/>  .end(function(err, documents){<br/>     /* ... */<br/>  });</span><span id="0062" class="kh ki hu mv b fv nd na l nb nc">//complex and combinations are also possible<br/>search<br/>  .query('(cat|dog) (felix|lassie)') //must have cat or dog AND felix or lassie<br/>  .type('direct')<br/>  .end(function(err, documents){<br/>     /* ... */<br/>  });</span></pre><p id="533a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，虽然所有这些都超级酷和有用——它实际上是一个用于重新搜索的笨客户端。再研究可以做更多的事情:</p><ul class=""><li id="26c0" class="lh li hu jl b jm jn jp jq js lj jw lk ka ll ke lm ln lo lp dt translated">过滤器</li><li id="3050" class="lh li hu jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp dt translated">分类</li><li id="2d87" class="lh li hu jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp dt translated">索引和返回散列</li><li id="c8bd" class="lh li hu jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp dt translated">使用相关地理信息进行搜索</li><li id="d61c" class="lh li hu jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp dt translated">在(' slop ')之间搜索单词<em class="kf"> n </em></li><li id="d94f" class="lh li hu jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp dt translated">搜索数值字段的范围，而不仅仅是文本</li></ul><p id="4e64" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可能还有更多我尚未完全理解或发现的特性。</p><p id="3257" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">您还可以使用重新搜索来管理建议(也称为自动完成)。建议完全脱离了索引过程，您可以添加和删除建议列表中的项目，然后获得所有以相同字母开头的项目。在需要精确匹配的地方，您甚至可以进行“模糊”搜索。这里有一个简短的例子:</p><figure class="lv lw lx ly fq ma"><div class="bz el l di"><div class="ne nf l"/></div></figure><p id="81af" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关于建议的想法是基于进入搜索的查询维护建议列表，添加不是搜索遗漏的结果。当用户开始输入时，自动完成可以从后端异步获取，并在用户输入时呈现给用户。</p><p id="dde5" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">RediSearch确实是一个非常完整的工具包。</p><h2 id="6bb2" class="kh ki hu bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb dt translated">与再搜索互动</h2><p id="e64d" class="pw-post-body-paragraph jj jk hu jl b jm lc iv jo jp ld iy jr js le ju jv jw lf jy jz ka lg kc kd ke hn dt translated">前面我提到过，您可以利用的不仅仅是Node.js模块中包含的内容。Node_redis能够直接向redis发送命令，这在需要一些特殊参数时非常有用，而且，好家伙，RediSearch有额外的参数吗？red和RedRediSearch实际上只是直接向Redis发送命令的包装器。如果Node.js模块中还不存在某个特性，您完全可以一起使用它们。</p><p id="2e01" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">例如，假设您想要一个最小的“停用词”集，在索引和查询中会忽略这些停用词。现有的(red)语法对停用词使用回调函数，但是在最初创建index之前，可以手动调用FT。创建类似于:</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="0197" class="kh ki hu mv b fv mz na l nb nc">client.send_command(<br/>   'FT.CREATE',<br/>   [ myKey,'SCHEMA','payload','TEXT','STOPWORDS','2','bunny','rabbits'<br/>   ],<br/>   function(err,response) {<br/>      /* ... */<br/>   }<br/>);</span></pre><p id="25d2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这将产生两个停用词——“兔子”和“兔子”，它们将被完全忽略。因此，如果一个特性还不被支持，那么很容易打破现有的限制，利用重新搜索模块的全部功能。</p><h2 id="83ce" class="kh ki hu bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb dt translated">使用Redis模块</h2><p id="9f29" class="pw-post-body-paragraph jj jk hu jl b jm lc iv jo jp ld iy jr js le ju jv jw lf jy jz ka lg kc kd ke hn dt translated">首先你需要安装Redis 4.0(如果你还没有的话)，然后安装模块。我用的是0.19.3，但是<strong class="jl hv">查一下</strong><a class="ae kg" href="http://redisearch.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">redisearch . io</strong></a><strong class="jl hv">或者</strong><a class="ae kg" href="https://github.com/RedisLabsModules/RediSearch/releases" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">github发布页面</strong> </a> <strong class="jl hv">为最新版本。</strong></p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="2253" class="kh ki hu mv b fv mz na l nb nc">$ wget <a class="ae kg" href="https://github.com/RedisLabsModules/RediSearch/archive/v0.18.1.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/RedisLabsModules/RediSearch/archive/v0.19.3.tar.gz</a><br/><em class="kf">...Download messages...</em></span><span id="cd37" class="kh ki hu mv b fv nd na l nb nc">$ tar -xvzf v0.19.3.tar.gz<br/><em class="kf">...decompression messages...</em></span></pre><p id="ab5e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这会产生一个名为/<em class="kf">rede search-0 . 19 . 3的目录。</em>切换到那个目录，我们将<em class="kf">做</em>一切。</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="19be" class="kh ki hu mv b fv mz na l nb nc">/RediSearch-0.19.3$ make all<br/><em class="kf">...build messages...</em></span></pre><p id="c4ad" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，在Redis 4.0+ redis.conf文件的末尾，添加模块加载命令:</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="5b85" class="kh ki hu mv b fv mz na l nb nc">loadmodule /path/to/RediSearch-0.19.3/src/redisearch.so</span></pre><p id="643f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您在不同的地方解压缩tarball或者使用不同的版本，您的路径可能需要调整，但是最相关的部分是文件(<em class="kf"> redisearch.so </em>)和最后一个目录(<em class="kf"> src </em>)。</p><p id="a3ee" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此时，您应该重新加载<em class="kf"> redis-server </em>并用<em class="kf"> redis-cli </em>测试您的模块安装:</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="1965" class="kh ki hu mv b fv mz na l nb nc">&gt; ft.create<br/>(error) ERR wrong number of arguments for 'ft.create' command</span></pre><p id="54ed" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个错误是好的——这意味着你的服务器知道命令的数量。创造需求。如果模块没有加载，就会出现这种情况:</p><pre class="lv lw lx ly fq mu mv mw mx aw my dt"><span id="b5ef" class="kh ki hu mv b fv mz na l nb nc">&gt; ft.create<br/>(error) ERR unknown command 'ft.create'</span></pre><p id="d1ee" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在验证了模块的安装之后，我们需要做的就是使用Node.js模块。如果你习惯于red，使用RedRediSearch模块是非常简单的:</p><figure class="lv lw lx ly fq ma"><div class="bz el l di"><div class="ne nf l"/></div></figure><h2 id="fa1e" class="kh ki hu bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb dt translated">我应该从red转到RediSearch吗？</h2><p id="ebb8" class="pw-post-body-paragraph jj jk hu jl b jm lc iv jo jp ld iy jr js le ju jv jw lf jy jz ka lg kc kd ke hn dt translated">一般来说，我会说“是的，绝对的。”然而，你可能需要推迟。如果您正在使用开源Redis，并且您的数据适合单个实例，那么现在就去使用它。如果你使用的是Redis Enterprise Pack，你需要有一点耐心，因为他们正在对Redis search+Redis Enterprise Pack进行最后的润色，这将启用跨越整个集群的索引(想想可能性！).如果你使用的是<a class="ae kg" href="https://redislabs.com/products/redis-cloud/" rel="noopener ugc nofollow" target="_blank"> Redis企业云</a>，坚持使用red作为模块，(因此)RediSearch不可用。然而，这将很快成为<a class="ae kg" href="https://redislabs.com/products/redis-cloud-private/" rel="noopener ugc nofollow" target="_blank"> Redis私有云</a>的一个选项，敬请关注。在所有这些情况下，[Red]redsearch或Red，你都被覆盖了，因为你的应用级逻辑将保持不变。希望RedRediSearch将继续发展，以包含RediSearch的所有特性，并保持与red语法的向后兼容性。你可以在<a class="ae kg" href="https://github.com/stockholmux/redredisearch" rel="noopener ugc nofollow" target="_blank"> Github </a>上或者通过<a class="ae kg" href="https://www.npmjs.com/package/redredisearch" rel="noopener ugc nofollow" target="_blank"> NPM </a>获取模块。</p><figure class="lv lw lx ly fq ma"><div class="bz el l di"><div class="ng nf l"/></div></figure></div></div>    
</body>
</html>