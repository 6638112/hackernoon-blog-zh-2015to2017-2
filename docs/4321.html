<html>
<head>
<title>value_ptr — The Missing C++ Smart-pointer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">value_ptr —丢失的C++智能指针</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/value-ptr-the-missing-c-smart-pointer-1f515664153e?source=collection_archive---------4-----------------------#2017-05-25">https://medium.com/hackernoon/value-ptr-the-missing-c-smart-pointer-1f515664153e?source=collection_archive---------4-----------------------#2017-05-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/e0559b4c54a94713055167e5e6490ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvoC4StuubfSmfLQUbIaAw.jpeg"/></div></div></figure><div class=""/><h1 id="97f6" class="jg jh if bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="b583" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">使用<code class="eh jc jd je jf b">value_ptr</code>智能指针获取堆资源的值语义。以一些额外的复制为代价，你的代码会更简单，更容易推理。</p><p id="c93b" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">选择这个备忘单使用的智能指针。</p><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="7d28" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">可以在<a class="ae ln" href="https://github.com/LoopPerfect/valuable" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到<code class="eh jc jd je jf b">value_ptr</code>的实现。</p><h1 id="9471" class="jg jh if bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">介绍</h1><p id="a322" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">模板、lambdas和词法范围的析构函数等语言特性使C++程序员能够编写高阶容器来处理对象的生存期和副作用，并以一种可理解的方式在类型系统中记录它们。</p><p id="a7c8" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">有了智能指针，编码所有权语义和管理资源变得前所未有的简单。我们可以在标准库中找到最常见用例的智能指针，但是这些智能指针都没有提供值语义。本文将介绍<code class="eh jc jd je jf b">value_ptr</code>，以及一些激励人心的例子。</p><p id="b2c1" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">但是首先，让我们看看C++ 11标准库已经提供的功能:</p><h2 id="bd71" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">(哑)原始指针</h2><p id="89df" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">是的，原始指针仍然可以使用，但是如果智能指针适用，您应该避免使用它们。这是因为原始指针不传达任何关于资源所有权模型的信息。</p><p id="a92b" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">此外，分配和释放必须由程序员来管理，这可能会导致诸如双重删除或内存泄漏之类的错误。</p><p id="e9f3" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">看一下这段代码:</p><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="e035" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">仅仅三行字，就有如此多的未解之谜:</p><ul class=""><li id="51cb" class="mc md if kg b kh lc kl ld kp me kt mf kx mg lb mh mi mj mk dt translated"><code class="eh jc jd je jf b">x</code>可以是<code class="eh jc jd je jf b">nullptr</code>吗，我必须检查吗？</li><li id="0a51" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated"><code class="eh jc jd je jf b">x</code>有管理吗？我能不能<code class="eh jc jd je jf b">delete x</code>？<em class="mq">一定要</em>我<code class="eh jc jd je jf b">delete x</code>？</li><li id="a622" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">如果我把<code class="eh jc jd je jf b">foo</code>前的<code class="eh jc jd je jf b">y</code>删除了，<code class="eh jc jd je jf b">foo</code>还有效吗？</li><li id="e2cf" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">如果<code class="eh jc jd je jf b">foo</code>被破坏了，<code class="eh jc jd je jf b">y</code>会被删除吗？</li></ul><p id="c36c" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">如果使用得当，智能指针可以让这些变得清晰。</p><h2 id="ed56" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">唯一_ptr</h2><p id="a6f0" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated"><code class="eh jc jd je jf b">unique_ptr</code>通过取得资源的唯一所有权并将其绑定到其词法范围来管理资源的生存期。虽然不能复制，但可以通过<code class="eh jc jd je jf b">std::move</code>转移所有权。</p><p id="c8bd" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在以下情况下使用<code class="eh jc jd je jf b">unique_ptr</code>:</p><ul class=""><li id="27f7" class="mc md if kg b kh lc kl ld kp me kt mf kx mg lb mh mi mj mk dt translated">您希望将堆资源的生存期绑定到词法范围</li><li id="9e69" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">您希望强制资源一次只有一个所有者</li></ul><h2 id="a544" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">例子</h2><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><h2 id="29d1" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">共享_ptr</h2><p id="e427" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">通过计算管理下的引用数量，允许多个资源所有者。容器的复制构造函数递增计数器，并在销毁时递减计数器。如果计数器达到零，那么资源将被释放。</p><p id="87b5" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在以下情况下使用<code class="eh jc jd je jf b">shared_ptr</code>:</p><ul class=""><li id="e1fb" class="mc md if kg b kh lc kl ld kp me kt mf kx mg lb mh mi mj mk dt translated">您希望在多个引用之间共享所有权</li><li id="ce11" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">当资源不再被使用时，您希望自动处置它</li><li id="33d9" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">你没有循环依赖</li><li id="57c4" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">引用计数的开销是可以接受的</li></ul><h2 id="23a7" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">例子</h2><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><h2 id="8857" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">弱_ptr</h2><p id="f303" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">我们看到我们可以对多个所有者使用<code class="eh jc jd je jf b">shared_ptr</code>，但是如果我们在所有权图中有循环会发生什么呢？在这种情况下，我们会泄漏内存，因为引用计数器永远不会达到零！循环中的主人会让彼此活下去。</p><p id="ae2a" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">这就是<code class="eh jc jd je jf b">weak_ptr</code>发挥作用的地方。<code class="eh jc jd je jf b">weak_ptr</code>类似于<code class="eh jc jd je jf b">shared_ptr</code>，但它不增加参考计数器。如果你用一个<code class="eh jc jd je jf b">weak_ptr</code>替换你的所有权图中的循环分支，那么引用计数将正确工作。</p><h2 id="b658" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">例子</h2><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><p id="b07b" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">在以下情况下使用<code class="eh jc jd je jf b">weak_ptr</code>:</p><ul class=""><li id="16d2" class="mc md if kg b kh lc kl ld kp me kt mf kx mg lb mh mi mj mk dt translated">你绝对必须有一个循环所有权图</li></ul><h1 id="6d39" class="jg jh if bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">介绍value_ptr</h1><p id="3e81" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">值语义使您的代码更容易推理，因为与指针不同，所有权必须是严格的分层和排他的。</p><p id="f91f" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated"><code class="eh jc jd je jf b">value_ptr</code>允许我们在堆上的可复制资源上实施那些语义。</p><h2 id="2bae" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">它是如何工作的</h2><ul class=""><li id="25a9" class="mc md if kg b kh ki kl km kp mr kt ms kx mt lb mh mi mj mk dt translated">对堆上的资源拥有独占所有权。</li><li id="b4c7" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">当您将一个<code class="eh jc jd je jf b">value_ptr</code>分配给另一个<code class="eh jc jd je jf b">value_ptr</code>时，一个新的<code class="eh jc jd je jf b">value_ptr</code>对象被构建，该对象指向<em class="mq">它自己的前一个<code class="eh jc jd je jf b">value_ptr</code>资源的副本</em>。</li><li id="cdb2" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">当<code class="eh jc jd je jf b">value_ptr</code>离开其词法范围时，资源被销毁。</li><li id="e391" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">没有共享内存，所以<code class="eh jc jd je jf b">value_ptr</code>本质上是线程安全的。</li><li id="9fee" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated">现代的编译器足够聪明，可以删除大部分多余的副本。</li></ul><h2 id="e00c" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">示例1 —递归数据类型</h2><p id="b22d" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">像树这样的递归类型必须通过C++中的指针来实现，所以内存中的布局可以在编译时计算出来。然而，尽管使用了指针，我们可能仍然想要值语义的简单性:</p><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><h2 id="1af3" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">示例PImpl模式</h2><p id="4ee8" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">有时我们希望将类的接口与其实现分开。这可能是为了将代码隐藏在编译后的库后面，或者强制实施恒定的堆栈大小。</p><p id="c877" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">由于生存期是与所有者绑定的，所以智能指针在这里是合适的，但是我们想要什么语义呢？与<code class="eh jc jd je jf b">shared_ptr</code>和<code class="eh jc jd je jf b">unique_ptr</code>不同，<code class="eh jc jd je jf b">value_ptr</code>给了我们价值语义。</p><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Header</figcaption></figure><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div><figcaption class="mu mv fg fe ff mw mx bd b be z ek">Translation-unit</figcaption></figure><h2 id="e60f" class="lo jh if bd ji lp lq lr jm ls lt lu jq kp lv lw ju kt lx ly jy kx lz ma kc mb dt translated">关于PImpl模式的更多资源</h2><ul class=""><li id="98e3" class="mc md if kg b kh ki kl km kp mr kt ms kx mt lb mh mi mj mk dt translated"><a class="ae ln" href="http://oliora.github.io/2015/12/29/pimpl-and-rule-of-zero.html" rel="noopener ugc nofollow" target="_blank"> PImpl，零规则和斯科特·迈耶斯</a></li><li id="9a54" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated"><a class="ae ln" href="http://www.gotw.ca/gotw/028.htm" rel="noopener ugc nofollow" target="_blank">快速习语</a></li><li id="089f" class="mc md if kg b kh ml kl mm kp mn kt mo kx mp lb mh mi mj mk dt translated"><a class="ae ln" href="https://anteru.net/blog/2009/03/14/385/" rel="noopener ugc nofollow" target="_blank"> PImpl你的C++代码</a></li></ul><h1 id="f90a" class="jg jh if bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">实施value_ptr</h1><p id="0924" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">您可能已经注意到<code class="eh jc jd je jf b">value_ptr</code>与<code class="eh jc jd je jf b">unique_ptr</code>相似，但是具有不同的复制构造器。虽然复制一个<code class="eh jc jd je jf b">unique_ptr</code>是被禁止的，但是复制一个<code class="eh jc jd je jf b">value_ptr</code>将会创建一个资源的副本。因此，我们可以通过利用<code class="eh jc jd je jf b">unique_ptr</code>和复制功能来实现<code class="eh jc jd je jf b">value_ptr</code>。</p><p id="531a" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">这就是我们所做的；<a class="ae ln" href="https://github.com/loopperfect/valuable" rel="noopener ugc nofollow" target="_blank">看看GitHub </a>，或者用<a class="ae ln" href="https://buckaroo.pm/" rel="noopener ugc nofollow" target="_blank"> Buckaroo </a>试驾一下我们的实现:</p><pre class="lh li lj lk fq my jf mz na aw nb dt"><span id="882e" class="lo jh if jf b fv nc nd l ne nf">buckaroo install loopperfect/valuable</span></pre><h1 id="29a2" class="jg jh if bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">摘要</h1><p id="3fc6" class="pw-post-body-paragraph ke kf if kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">值语义很容易推理，甚至对于堆对象也很有用。C++标准库没有提供带有值语义的智能指针，但是C++有允许我们自己滚动的特性。</p><p id="b6ac" class="pw-post-body-paragraph ke kf if kg b kh lc kj kk kl ld kn ko kp le kr ks kt lf kv kw kx lg kz la lb hn dt translated">无法决定使用哪个智能指针？这里有一个快速图表:</p><figure class="lh li lj lk fq hw"><div class="bz el l di"><div class="ll lm l"/></div></figure><div class="lh li lj lk fq ab cb"><figure class="ng hw nh ni nj nk nl paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ng hw nh ni nj nk nl paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ng hw nh ni nj nk nl paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nm nn no"><p id="f922" class="ke kf mq kg b kh lc kj kk kl ld kn ko np le kr ks nq lf kv kw nr lg kz la lb hn dt translated"><a class="ae ln" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ln" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ln" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ln" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ke kf mq kg b kh lc kj kk kl ld kn ko np le kr ks nq lf kv kw nr lg kz la lb hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ln" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ln" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ns"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>