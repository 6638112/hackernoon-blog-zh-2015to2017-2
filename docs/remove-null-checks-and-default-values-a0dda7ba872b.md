# 删除空检查和默认值

> 原文：<https://medium.com/hackernoon/remove-null-checks-and-default-values-a0dda7ba872b>

![](img/6773517c07e8733c7c930417131eac48.png)

> "通往地狱的道路是由良好的意愿铺成的。"

这句古老的谚语在软件开发和生活中同样适用。

以下面的代码为例:

```
public List<Product> getProducts(String country) {
  if (country == null) {
    country = „at“;
  }
  List<Product> products =
    database.getProductsForCountries(country); 
  if (products == null) { 
    return Collection.emptyList();
  }
  else { 
    return products; 
  } 
}
```

# 不要把它藏在地毯下面

![](img/13a87d623fc0e7c038371f7e449dbb9e.png)

我们示例中的函数返回给定国家的产品列表。如果[国家](https://hackernoon.com/tagged/country)的值为空，那么我们只需设置一个默认值(在我们的例子中为 Austria ),然后继续运行，就像一切正常一样。

我们还考虑了底层数据库函数返回 null 的可能性。同样，我们覆盖原始结果并返回一个空列表而不是 null。

这里的问题是什么？这些步骤使我们的应用程序尽可能地防错。这是对待我们代码的一种好态度。

然而，在这种情况下，我们的良好愿望导致了不幸的结果。这种模式隐藏了潜在的错误。更糟糕的是，这些漏洞变得难以发现。

# 当用户向我们发送错误报告时

假设调用函数用 GeoIP 解析当前用户的国家。我们永远也不会知道它是否出现故障并返回 null。应用程序将表现得一切正常。我们怎么知道我们所有的客户现在都是奥地利人？如果我们的大多数客户都是奥地利人，这个问题就更容易被忽视。

单元测试在这里帮不了我们，因为这是一个*概念错误*，是由于没有考虑我们编码行为的后果而导致的。

只有当我们的客户抱怨他们不愿意用欧元付款，因为他们使用美元时，或者当我们的货运代理指出洛杉矶不在奥地利时，只有*然后*我们才意识到事情不是我们想象的那样。

# 不断增长的代码库

我们函数中的多个参数，或者对其他类的依赖，将需要空检查，这并不奇怪。我们的例子中只有一个“数据库”对象，但这导致了许多问题。

每一个额外的空检查都会引入一个新的分支，这个分支需要自己的单元测试。每个分支都会分散读者对代码原意的注意力。

大量专门用于空检查的单元测试不必要地增加了我们的代码库。请记住，我们必须维护这些检查。如果我们修改我们的代码，那么我们必须适应所有这些额外的测试。

所有这些额外的工作侵蚀了有效的 TDD 所需的纪律。

# 按照异常的本质对待它:异常

空值会立即中断执行。那是一种好的行为。让它发生吧。当系统状态出现问题时，我们希望在我们的开发机器上弹出一个大的 NullPointerException 错误消息。

不要继续像什么都没发生一样。

如果从未抛出 NullPointerException 会怎样？那么，这意味着我们的代码永远不会访问这个对象，我们可能根本不需要它。我不会把这个问题作为一个错误，而是作为一个潜在的死代码。

# 但是可以为空！

认为空值必然是错误的想法太容易了。请记住，空值可能是完全有效的结果。例如，用户可以请求尚不存在的购物篮。在这种情况下，我们可以使用 Java 的 Optional 或者声明一个异常或您选择的语言所提供的任何东西。

永远不要指望打电话的人或制作人会纠正你的“错误”。向他们展示返回空值是一种必须注意的有效情况。

# 我们应该删除所有验证吗？你说真的吗？

不，一点也不！事实恰恰相反。我们应该尽可能地进行有效性检查，如复杂性标准，用现有的电子邮件进行新的注册等等。

我在这里的全部观点是，您不应该覆盖空值的默认值。我们不仅仅想要认可。我们希望异常抛出得太频繁而不是太少。

在 null 的情况下，我们不需要手动验证。运行时会为我们做这件事。

# API 或库供应商的不同游戏

当我们提供一个 API 或一个库时，情况就不同了。简而言之，我们的最终用户是技术人员或机器。

在这种情况下，我们希望返回详细的错误描述。最终用户需要准确了解请求消息中的错误，以便修复它。

# 包扎

看看当我们将初始代码示例简化为以下代码时会发生什么:

```
public List<Product> getProducts(String country) { 
  return database.getProductsForCountries(country);
}
```

如果国家为空，那么您的数据库库将抛出一个错误消息。如果数据库返回一个 null，那么您的调用函数将抛出一个 NullPointerException。应用程序无论如何都会中断。

我们不要过度使用有效性检查。这将使我们的代码非常简短和清晰。

我们的运行时应该抛出一个`NullPointerException`或者一个`UncaughtTypeError`或者用我们的语言叫它什么的。永远不要让一个堆栈跟踪突破。向最终用户显示一条漂亮的通用错误消息。

同时，确保有一个集中的错误记录应用程序，比如 Sentry，来收集所有可用的信息，比如 StackTrace、上下文信息、执行的 SQL 语句等等。

虽然听起来不太直观，但是让我们的运行时抛出空错误可以让我们作为开发人员快速安全地修复根本原因。

我最后的建议是:不要低估代码删除带来的生产率提高。

*原载于 2017 年 12 月 9 日*[*【www.rainerhahnekamp.com】*](https://www.rainerhahnekamp.com/en/remove-null-checks-default-values/)*。*