<html>
<head>
<title>Getting Started with Relay “Modern” for Building Isomorphic Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用Relay“Modern”构建同构Web应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-started-with-relay-modern-for-building-isomorphic-web-apps-ae049e4e23c1?source=collection_archive---------2-----------------------#2017-05-01">https://medium.com/hackernoon/getting-started-with-relay-modern-for-building-isomorphic-web-apps-ae049e4e23c1?source=collection_archive---------2-----------------------#2017-05-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1aec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> Relay </strong>代号“<strong class="it hv"> Modern </strong>”是在脸书使用的流行的<strong class="it hv"> GraphQL客户端</strong>库的新版本。它在重新设计时考虑到了可扩展性，使其非常灵活地集成到任何类型的web应用程序中，包括<a class="ae jp" rel="noopener" href="/airbnb-engineering/isomorphic-javascript-the-future-of-web-apps-10882b7a2ebc">同构</a>(或通用)web应用程序。但是首先…</p><h1 id="1ad2" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么选择GraphQL？</h1><p id="00fd" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">嗯，如果你环顾四周，你会注意到同样在脸书孵化的GraphQL技术事实上正在成为开发web和移动应用后端的标准，取代RESTful APIs、JSON APIs、OData和其他类似的规范——主要是因为GraphQL面向开发者体验和性能。脸书开发商绝对抓住了这一点。</p><p id="a129" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以GitHub的GraphQL实现为例—<a class="ae jp" href="https://developer.github.com/early-access/graphql/" rel="noopener ugc nofollow" target="_blank">docs</a>+<a class="ae jp" href="https://developer.github.com/early-access/graphql/explorer/" rel="noopener ugc nofollow" target="_blank">playground</a>，您可以看到它是如何“实时”工作的，并尝试执行几个示例查询。把这个链接给一个从未听说过GraphQL的前端开发人员，几个小时之内，他就能掌握核心概念，开始使用它，并完成工作^_^</p><p id="66c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你还在考虑用什么技术为你的下一个应用构建一个<a class="ae jp" href="https://github.com/kriasoft/nodejs-api-starter" rel="noopener ugc nofollow" target="_blank">数据API服务器</a>，请不要再犹豫了，GraphQL是这个用例的绝佳选择。此外，它非常适合在基于微服务的架构中构建API网关。</p><p id="3b5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，问题不是你是否需要使用GraphQL:)，而是哪个GraphQL客户端库最适合我们的项目？最起码，你可以只使用<a class="ae jp" href="https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> HTML5获取API </a>。让我们看看它是什么样子的。首先创建几个助手方法— <code class="eh kt ku kv kw b">fetchQuery()</code>、<code class="eh kt ku kv kw b">commitMutation()</code>等等。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="35a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，您可以通过您的应用程序使用这些助手函数来获取大块数据并将数据提交给服务器，如下所示:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="7b58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这种方法对于小型应用程序来说很好，但是它不能很好地伸缩，也不能很好地与基于组件的UI架构一起工作(稍后将详细介绍)。</p><h1 id="d9cf" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">为什么要接力？</h1><p id="5e32" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">新中继的核心特性之一是能够从客户端代码中提取GraphQL查询，然后合并并优化它们，这样，例如，您可以解析客户端代码(在编译步骤中)，找到所有GraphQL查询，将它们保存到数据库中，并使您的客户端(web)应用程序发送查询id而不是文本字符串。这种技术至少在移动设备上有巨大的性能优势，减少了客户端捆绑包的大小、网络流量和CPU/内存占用。</p><p id="4a21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它支持订阅，因此您可以通过Web套接字或类似的传输将数据从服务器传输到客户机，反之亦然，还支持“实时查询”，这是使用HTTP长轮询技术的订阅的简化替代方案。</p><p id="8884" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Relay的新版本中，您可以配置“字段处理程序”，它可以用于从服务器有效负载接收的后处理。当您需要在应用程序中实现一些非标准的分页算法时，这是非常方便的。此外，您现在可以配置“客户端模式扩展”，这是一种将一些任意属性/元数据附加到从GraphQL后端提取的现有数据记录的便捷方式，以便在客户端使用。这应该能够取代以前需要Flux/Redux存储的一些用例。</p><p id="03dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能知道，Relay有一个数据存储，可用于缓存从服务器获取的数据记录，但更重要的是，它有一些<em class="le">智能ass </em>逻辑，确保垃圾收集器(GA)清理所有不再使用的数据。祝你在没有中继的情况下顺利实现:)</p><p id="4967" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，Relay Compiler(稍后将详细介绍)足够智能，可以从客户端代码中使用的GraphQL查询中生成流类型。多酷啊。</p><h1 id="c53d" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">里面是什么</h1><p id="b4f7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">“现代”接力赛由四个NPM包组成，即:</p><ul class=""><li id="a39f" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><code class="eh kt ku kv kw b"><strong class="it hv">relay-runtime</strong></code> —为创建运行时使用的复杂GraphQL客户端提供核心构建块。</li><li id="7150" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><code class="eh kt ku kv kw b"><strong class="it hv">relay-compiler</strong></code> —一个命令行工具，用于从源代码中提取GraphQL查询，对其进行优化，并以JavaScript代码的形式保存在磁盘上。</li><li id="7f25" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><code class="eh kt ku kv kw b"><strong class="it hv">babel-plugin-relay</strong></code>—Babel Compiler的一个插件，用<code class="eh kt ku kv kw b">() =&gt; require('xxx.graphql')</code>语句替换源代码中所有硬编码的GraphQL查询，其中<code class="eh kt ku kv kw b">xxx.graphql</code>是Relay Compiler生成的相应文件的名称。</li><li id="444e" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><code class="eh kt ku kv kw b"><strong class="it hv">react-relay</strong></code> —是一组与<a class="ae jp" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>应用程序一起使用的高阶组件，这个包在引擎盖下使用<code class="eh kt ku kv kw b">relay-runtime</code>。如果你正在用Angular，Vue.js等构建你的前端，就不需要它了。</li></ul><p id="cf37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">花点时间看看公共中继“现代”API是什么样子的:</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/8924d30d77db00d30baeeb0d539a7cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*uHqVx_HZ1zaU1-xyvrXsmw.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Relay “Modern” v1.0.0-rc.3 (April 27, 2017)</figcaption></figure><p id="e99c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如您所见，<code class="eh kt ku kv kw b">react-relay</code>包只提供了一个顶级React组件— <code class="eh kt ku kv kw b">QueryRenderer</code>和三个助手函数，用于将React组件包装成支持中继的高阶组件。就是这样！剩余的五个字段(<code class="eh kt ku kv kw b">graphql</code>、<code class="eh kt ku kv kw b">fetchQuery</code>等)只是从<code class="eh kt ku kv kw b">relay-runtime</code>模块的再输出。</p><p id="c858" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，<code class="eh kt ku kv kw b">react-relay</code>在<code class="eh kt ku kv kw b">react-relay/classic</code>和<code class="eh kt ku kv kw b">react-relay/compat</code>名称空间中公开了更多的API方法和字段。但是除非你正在使用一个构建在Relay <code class="eh kt ku kv kw b">v0.x</code>之上的遗留代码库，否则你不会想去研究这些。现在让我们看看如何将Relay“Modern”集成到您的项目中。</p><h1 id="3b13" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">如何入门Relay.js</h1><p id="0b6f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">我假设你已经熟悉了<a class="ae jp" href="https://facebook.github.io/react/" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae jp" href="http://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>和<a class="ae jp" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，并且有了使用这个堆栈的基本项目结构。如果你不是React的忠实粉丝，我认为下面的代码样本也可以应用到另一个前端框架或库，只需做一些小的调整。</p><p id="b8a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，运行以下命令安装前面提到的所有软件包:</p><pre class="kx ky kz la fq ma kw mb mc aw md dt"><span id="b082" class="me jr hu kw b fv mf mg l mh mi">yarn install relay-runtime@1.0.0-rc.3<br/>yarn install react-relay@1.0.0-rc.3<br/>yarn install relay-compiler@1.0.0-rc.3 --dev<br/>yarn install babel-plugin-relay@1.0.1-rc.3 --dev</span></pre><p id="c81f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">将<code class="eh kt ku kv kw b">babel-plugin-relay</code>包含到您的Babel配置文件的插件列表中(通常是<code class="eh kt ku kv kw b">.babelrc</code>或<code class="eh kt ku kv kw b">.babelrc.js</code>):</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="fa8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加将运行中继编译器的npm脚本。因此，项目根目录中的<code class="eh kt ku kv kw b">package.json</code>文件将包含以下条目:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="63a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您需要将GraphQL模式从您的数据API服务器复制并粘贴到您的项目中，方法是将其保存到<code class="eh kt ku kv kw b">src/schema.graphql</code>文件中(参见<a class="ae jp" href="https://reactstarter.com/graphql/schema" rel="noopener ugc nofollow" target="_blank">示例</a>)。这个文件将被中继编译器使用。此外，附带的好处是，将这种基于文本的模式(相对于JSON)置于源代码控制之下将允许您和您的前端团队轻松地看到您的GraphQL模型是如何随着时间的推移而发展的。如果需要的话，可以自动执行这项任务。</p><p id="0337" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在你可以尝试在你的代码中插入一些GraphQL查询(在<code class="eh kt ku kv kw b">src</code>文件夹中)并运行<code class="eh kt ku kv kw b">yarn run relay</code>命令将这些文本查询编译成<a class="ae jp" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/5be37d279d95c5ac04bd17959edbd5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/1*I7aSpqUxFRrh0QZl-gS20w.gif"/></div></figure><p id="5309" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，您可以在监视模式下运行中继编译器:</p><pre class="kx ky kz la fq ma kw mb mc aw md dt"><span id="eabd" class="me jr hu kw b fv mf mg l mh mi">yarn run relay -- --watch</span></pre><p id="d981" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，如果您试图在GraphQL查询中使用一些在<code class="eh kt ku kv kw b">src/schema.graphql</code>文件中丢失的字段，Relay Compiler会抛出一个错误。</p><p id="6b83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">GraphQL查询应该是什么样子？你需要从<code class="eh kt ku kv kw b">relay-runtime</code>或<code class="eh kt ku kv kw b">react-relay</code>模块导入<code class="eh kt ku kv kw b">graphql</code>对象。并使用<em class="le">标记的模板文字</em>。这里有一个例子:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="7598" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们假设您的<code class="eh kt ku kv kw b">src/schema.graphql</code>文件包含一个带有<code class="eh kt ku kv kw b">viewer</code>和<code class="eh kt ku kv kw b">posts</code>顶级字段的模式。然后，如果您运行<code class="eh kt ku kv kw b">yarn run relay</code>，它将在包含GraphQL查询的源文件所在的同一文件夹中生成<code class="eh kt ku kv kw b">__generated__/Example.graphql.js</code>文件。并且在你用Babel编译了你的原始源代码之后，上面带标签的模板文字字符串会被替换成<code class="eh kt ku kv kw b">const query = () =&gt; require('__generated__/Example.graphql')</code>。</p><p id="88d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">需要注意的重要一点是，如果你的代码包含匿名查询或者像<code class="eh kt ku kv kw b">query { viewer { email } }</code> vs <code class="eh kt ku kv kw b">query ExampleQuery { viewer { email } }</code>这样的片段，那么Relay编译器将无法工作。</p><p id="8dd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以通过片段的名称引用这些片段来构建顶级GraphQL查询。例如:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="75a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">即使这些完全相同的查询位于不同的文件中，Relay Compiler也足够智能来构建依赖树，编译和优化它们。这就是为什么它要求所有的查询和片段都有自己唯一的名字。</p><p id="54db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，为了获取上例中所有组件的数据(<code class="eh kt ku kv kw b">Layout</code>、<code class="eh kt ku kv kw b">Toolbar</code>、<code class="eh kt ku kv kw b">PostList</code>)，我们只需要获取顶级查询的数据，如以下代码所示:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="86bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不要太关注渲染函数，而是看看如何使用来自<code class="eh kt ku kv kw b">relay-runtime</code>模块的<code class="eh kt ku kv kw b">fetchQuery()</code>助手方法。</p><p id="ca50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会好奇，<code class="eh kt ku kv kw b">environment</code>变量是从哪里来的？为了使用中继，您需要初始化所谓的中继环境。幸运的是，<code class="eh kt ku kv kw b">relay-runtime</code>模块为此提供了所有必要的工具。根据您的代码是在浏览器还是Node.js环境中执行，这个“环境”会略有不同。</p><p id="927b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，在浏览器中，您可能希望将HTML Fetch API与<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/github/fetch" rel="noopener ugc nofollow" target="_blank">whatwg-fetch</a></code> polyfill结合使用，而在服务器上，您可以使用具有完全相同API但设计用于在Node中运行的<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/bitinn/node-fetch" rel="noopener ugc nofollow" target="_blank">node-fetch</a></code>模块。多亏了Webpack和<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/matthew-andrews/isomorphic-fetch" rel="noopener ugc nofollow" target="_blank">isomorphic-fetch</a></code>模块，你不用考虑太多如何将正确的库捆绑到你的生产代码中，就像做<code class="eh kt ku kv kw b">import fetch from 'isomorphic-fetch'</code>一样简单。</p><p id="c6f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有什么不同？GraphQL端点的基本URL。例如，在浏览器中，中继可能使用相对于网站域名的URL路径字符串从<code class="eh kt ku kv kw b">/graphql</code>端点获取数据。但是在服务器上，必须是完整的URL，类似于<code class="eh kt ku kv kw b">http://api:8080/graphql</code>。</p><p id="60a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您很可能希望创建一个工厂方法，该方法给定一个基本URL和几个其他选项，将初始化正确的React环境以及几个将在客户端或服务器端代码中使用的helper方法。下面是它可能的样子:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">See src/api.js in https://github.com/kriasoft/react-starter-kit</figcaption></figure><p id="50e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个工厂方法初始化中继环境，并将其绑定到<code class="eh kt ku kv kw b">fetchQuery()</code>、<code class="eh kt ku kv kw b">commitMutation()</code>方法，这样您就不需要在每次需要向服务器发送GraphQL查询时都传递它。下面是如何使用它的一个例子:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><h1 id="3024" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">继电器❤反应</h1><p id="2b41" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在让我们看看如何用GraphQL查询片段来修饰React组件，这样您就不需要手动将所有的属性传递到UI层次结构中，而是让Relay自动查找每个组件所需的数据。为此，您只需使用<code class="eh kt ku kv kw b">react-relay</code>模块中的三个助手方法之一:</p><ul class=""><li id="2076" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated"><code class="eh kt ku kv kw b"><strong class="it hv">createFragmentContainer()</strong></code> —组成一个React组件类，返回一个新的类(<code class="eh kt ku kv kw b"><a class="ae jp" href="https://facebook.github.io/relay/docs/fragment-container.html" rel="noopener ugc nofollow" target="_blank">FragmentContainer</a></code>)，该类拦截道具，用提供的片段解析它们并订阅更新。</li><li id="a661" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><code class="eh kt ku kv kw b"><strong class="it hv">createRefetchContainer()</strong></code> <strong class="it hv"> </strong> —将一个React组件类包装到<code class="eh kt ku kv kw b"><a class="ae jp" href="https://facebook.github.io/relay/docs/refetch-container.html" rel="noopener ugc nofollow" target="_blank">RefetchContainer</a></code>中，首先像常规的<code class="eh kt ku kv kw b">FragmentContainer </code>一样呈现，但是可以选择使用不同的变量执行新的查询，并在请求返回时呈现该查询的响应。</li><li id="f818" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated"><strong class="it hv">createPaginationContainer()</strong>—将一个React组件类包装到<code class="eh kt ku kv kw b"><a class="ae jp" href="https://facebook.github.io/relay/docs/pagination-container.html" rel="noopener ugc nofollow" target="_blank">PaginationContainer</a></code>中，这是为了简化在列表中加载更多项目的工作流程——在许多情况下，我们不想一次获取所有数据，而是缓慢地加载更多数据。它依赖于GraphQL服务器以标准化的方式公开连接。详细规格请查看本页。</li></ul><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="5cf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中<code class="eh kt ku kv kw b">Toolbar_viewer</code>是片段的名称，按照惯例，它使用文件名(工具栏)+下划线+属性名，数据必须通过<code class="eh kt ku kv kw b">this.props</code>在该属性下可用。</p><p id="20de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您初始化这个组件时，您需要传递包含记录ID的<code class="eh kt ku kv kw b">viewer={…}</code> prop，并且<code class="eh kt ku kv kw b">FragmentComponent</code>将通过该ID从本地中继存储中提取所有必需的字段(在这种情况下是<code class="eh kt ku kv kw b">email</code>和<code class="eh kt ku kv kw b">isAdmin</code>)。例如，在父<code class="eh kt ku kv kw b">Layout</code>组件中，您需要像这样实例化<code class="eh kt ku kv kw b">Toolbar</code>:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="47cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您将片段命名为<code class="eh kt ku kv kw b">Layout</code>，而不是<code class="eh kt ku kv kw b">Layout_viewer</code>，那么<code class="eh kt ku kv kw b">language</code>字段将通过<code class="eh kt ku kv kw b">this.props.data</code>可用(相对于<code class="eh kt ku kv kw b">this.props.viewer</code>)。</p><p id="8424" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，现在让我们看看如何将Relay与单页应用程序路由器集成。</p><h1 id="83e7" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">中继❤通用路由器</h1><p id="4b8f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如前所述，Relay附带了<code class="eh kt ku kv kw b"><a class="ae jp" href="https://facebook.github.io/relay/docs/query-renderer.html" rel="noopener ugc nofollow" target="_blank">QueryRenderer</a></code>顶级组件，其目的是将一些临时标记安装到DOM中，例如“Loading……”，给定一个顶级GraphQL查询，开始从服务器获取所需的数据，一旦数据获取完成，就呈现实际的应用程序屏幕(页面)。</p><p id="fe0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我敢肯定这个<code class="eh kt ku kv kw b">QueryRenderer</code>类并不适合所有类型的应用程序，很可能你会想要复制粘贴并为你的应用程序定制它，或者甚至使用一个替代的解决方案来达到类似的目的。</p><p id="76f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在同构应用程序的情况下，没有必要渲染一个临时的“加载”屏幕。此外，在用React呈现应用程序之前，预加载所有数据可能是一个更好的主意。让我们看看如何通过使用<code class="eh kt ku kv kw b"><a class="ae jp" href="https://github.com/kriasoft/universal-router" rel="noopener ugc nofollow" target="_blank">Universal Router</a></code>库来实现它——你可能已经通过<a class="ae jp" href="https://github.com/kriasoft/react-starter-kit" rel="noopener ugc nofollow" target="_blank"> React Starter Kit </a>项目熟悉了这个库。</p><p id="86fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你从未听说过Universal Router，它是一个简单的中间件风格的路由解决方案，与框架无关(与任何前端框架都可以很好地工作)，并且故意看起来非常类似于Express.js路由器，使其更容易在同构web应用中采用。</p><p id="70e5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您需要将一个路线列表编译成一个普通的JavaScript数组，其中每一项都有<code class="eh kt ku kv kw b">path</code>、<code class="eh kt ku kv kw b">action</code>和可选的<code class="eh kt ku kv kw b">children</code>属性。典型的路线可能如下所示:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><p id="af51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其中<code class="eh kt ku kv kw b">api</code>参数与我们在前面的一个例子中初始化的对象完全相同，它被作为上下文变量传递给路由处理程序(<code class="eh kt ku kv kw b">action()</code>)方法。</p><p id="cac2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过调用<code class="eh kt ku kv kw b">new Router(routes)</code>来初始化路由器，然后执行它的<code class="eh kt ku kv kw b">.resolve({ path, …context }</code>方法来查找并执行与所提供的URL路径字符串相匹配的路由。然后，您只需在客户端将返回的React组件呈现为DOM，或者在服务器端呈现为HTML字符串，如以下示例代码所示:</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="lc ld l"/></div></figure><h1 id="8e3e" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">摘要</h1><p id="7479" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">接力《摩登》真的很棒。上面的代码示例演示了它可以多么容易地集成到任何项目中(不一定是React)。即使您从使用它的基本特性开始，您仍然能够比不使用Relay更有效地编写与数据获取相关的代码。在以后的帖子中，我将尝试介绍更多高级的中继功能。敬请期待:)</p><p id="1924" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想看到React+Relay集成的工作示例，请访问GitHub上的<a class="ae jp" href="https://github.com/kriasoft/react-starter-kit" rel="noopener ugc nofollow" target="_blank"> React Starter Kit </a>项目。此外，还有一个兄弟repo — <a class="ae jp" href="https://github.com/kriasoft/nodejs-api-starter" rel="noopener ugc nofollow" target="_blank"> Node.js API Starter </a>可以帮助你构建一个GraphQL API后端。我在我所有的项目中非常成功地使用了这两个样板，所以如果你需要任何建议，不要犹豫，在Twitter上联系(<a class="ae jp" href="https://twitter.com/koistya" rel="noopener ugc nofollow" target="_blank"> @koistya </a>)。</p><div class="kx ky kz la fq ab cb"><figure class="mk lb ml mm mn mo mp paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mk lb ml mm mn mo mp paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mk lb ml mm mn mo mp paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mq mr ms"><p id="f922" class="ir is le it b iu iv iw ix iy iz ja jb mt jd je jf mu jh ji jj mv jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is le it b iu iv iw ix iy iz ja jb mt jd je jf mu jh ji jj mv jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff mw"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nb ld l"/></div></figure></div></div>    
</body>
</html>