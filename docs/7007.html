<html>
<head>
<title>Deploying PHP Apps with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker部署PHP应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/deploying-php-apps-with-docker-8bccae5a33f7?source=collection_archive---------3-----------------------#2017-10-13">https://medium.com/hackernoon/deploying-php-apps-with-docker-8bccae5a33f7?source=collection_archive---------3-----------------------#2017-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0874" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现代软件开发中的许多挑战之一是确保应用程序在所有环境中一致地执行。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/ccfb2e7ef7141c36e2c13b4d021b28e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MZSKK2laDg5xyAQs.jpg"/></div></figure><blockquote class="jx jy jz"><p id="1bad" class="ir is ka it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">最初发布于2017年8月1日<a class="ae ke" href="https://www.cloudways.com/blog/docker-php-application/" rel="noopener ugc nofollow" target="_blank">www.cloudways.com</a></p></blockquote><p id="6317" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是码头工人来救援的地方！它为任何所需的服务提供了构建和运行容器的统一方式。该平台确保无论目标环境如何，您的应用程序都执行相同的操作。</p><p id="b1b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了说明Dockerize PHP应用程序的过程，我将Dockerize一个博客网站，最初是在Laravel 5.4中开发的。</p><p id="bf1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为此，请确保您在机器上安装了Docker。我将使用docker-compose，它通过在单个文件中定义多容器应用程序并执行一个简单命令，使部署多容器应用程序变得容易。</p><p id="5559" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在项目的根目录下，创建一个文件并命名为<strong class="it hv"> docker-compose.yml </strong>。文件中的代码如下所示:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kf"><img src="../Images/901a6c9fbc874fca61e6e4e6f7cb0260.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*lH-gItWDNOZKrAur.png"/></div></figure><h1 id="96dc" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">Docker-compose.yml解释</h1><p id="34c8" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">在这段代码中，定义了两个名为<strong class="it hv"> php </strong>和<strong class="it hv"> db </strong>的服务，这两个服务将连接起来运行最终的应用程序。</p><p id="f24c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">‘build’</strong>定义相关服务的Dockerfile文件的位置。</p><p id="8c3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">“volume”将项目目录作为一个卷挂载到容器的<strong class="it hv"> /var/www/html </strong>中。日志目录也安装在相应的目录中。</p><p id="8409" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> php </strong>容器暴露机器的端口<strong class="it hv"> 8000 </strong>并绑定到容器的端口<strong class="it hv"> 80 </strong>。这将允许访问应用程序</p><p id="8b0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">环境</strong>用于注入环境变量。</p><p id="eb8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请记住，我可以通过指定depends on选项来强制Docker先构建一个容器，然后再构建另一个容器。然而，在这种情况下，将首先构建<strong class="it hv"> db </strong>容器，因为<strong class="it hv"> php </strong>容器依赖于它。</p><p id="f163" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦创建了docker-compose文件，接下来我将创建各自的docker文件，其中包含构建容器映像的所有指令。</p><p id="b653" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">转到Docker目录，为<strong class="it hv"> php </strong>和<strong class="it hv"> db </strong>容器创建两个文件夹。</p><p id="c6ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两个docker文件如下所示:</p><h1 id="2cb9" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">php Dockerfile</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lj"><img src="../Images/792146cfee2505cc36cb7857d2187f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B3p6_e8zDe5L1JIZ.png"/></div></div></figure><p id="6a2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该文件以基础映像的定义开始(在本例中，是一个PHP 5.6基础映像)。您可以根据应用程序的需要，轻松地设置您想要的基本映像。接下来，我将几个文件复制到容器中。</p><h1 id="adc5" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">数据库文档文件</h1><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lo"><img src="../Images/e0e7b29d8ef769102031a1829f671d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/0*yoSYLmsWzFsqSUPR.png"/></div></div></figure><p id="5b6d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个dockerfile文件中，我使用了MySQL 5.6作为基础映像。启动容器时，会创建一个具有指定名称的新数据库。我还包含了数据库SQL转储文件，该文件将在服务器创建后立即执行(因为它位于<strong class="it hv">/docker-entry point-initdb . d</strong>)。</p><p id="6474" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建完所有文件后，转到应用程序的根目录，运行以下命令:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="d896" class="lu kh hu lq b fv lv lw l lx ly">docker-compose up -d</span></pre><p id="5d74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该命令将在后台启动容器。第一次启动可能会很慢，因为必须下载所有的基本映像。然而，所有后续的发射都要快得多。</p><p id="6617" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我还复制了容器中的hosts文件(包含以下文本)。</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="c769" class="lu kh hu lq b fv lv lw l lx ly">127.0.0.1 blogsite.com</span></pre><p id="f22a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，您可以通过访问http://localhost:8000来访问该应用程序。因为我也在容器中复制了hosts文件，所以我也可以通过访问URL http://blogsite.com来访问应用程序。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff lz"><img src="../Images/d87789d1f51d844c7be069b559d272cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yfgkXuVPKD0wOGXV.png"/></div></div></figure><p id="36f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以通过以下命令查看活动容器:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="ef41" class="lu kh hu lq b fv lv lw l lx ly">docker ps</span></pre><p id="d4b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是一个输出示例:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="fe ff ma"><img src="../Images/bc7b8d8c40132d0721bf6517f55d04c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j7bLKt9ZfqQdvAAW.png"/></div></div></figure><p id="5d6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以通过以下方式访问容器</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="877c" class="lu kh hu lq b fv lv lw l lx ly">docker exec -it &lt;container_name&gt; bash</span></pre><p id="08be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">看吧！对PHP应用程序进行Dockerize是多么简单。由于其重量轻，它可以很容易地被摧毁，并在短短几分钟内再次创造。</p></div></div>    
</body>
</html>