<html>
<head>
<title>Ecto: Multiple Filters via URL Parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ecto:通过URL参数的多个过滤器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/ecto-multiple-filters-via-url-parameters-fd0e4a8b5074?source=collection_archive---------13-----------------------#2017-10-11">https://medium.com/hackernoon/ecto-multiple-filters-via-url-parameters-fd0e4a8b5074?source=collection_archive---------13-----------------------#2017-10-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/97d68f478573a0272999563ce6aa65d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_1UFQUi_ZaqPQuRGzfWNg.jpeg"/></div></div></figure><h2 id="17a2" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">概观</h2><p id="f87a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">昨天，在开发一个RESTful的API时，我遇到了一个棘手的问题。</p><blockquote class="kw kx ky"><p id="b050" class="ka kb kz kc b kd la kf kg kh lb kj kk lc ld km kn le lf kp kq lg lh ks kt ku hn dt translated">如何根据URL中传递的参数过滤一个<a class="ae kv" href="https://hackernoon.com/tagged/ecto" rel="noopener ugc nofollow" target="_blank"> Ecto </a>结果？</p></blockquote><p id="e1ac" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">在这个小教程中，我们将构建一个可重用的模块来处理过滤。</p></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h2 id="5fe4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">情况</h2><p id="ad1b" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">我们构建了一个API端点来获取所有用户的待办事项。<code class="eh lp lq lr ls b">todos</code>表有一个<code class="eh lp lq lr ls b">state</code>列，每个待办事项可以有一个状态<code class="eh lp lq lr ls b">done</code>、<code class="eh lp lq lr ls b">doing</code>或<code class="eh lp lq lr ls b">pending</code>。</p></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h2 id="4da1" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">我们努力实现的目标</h2><p id="c791" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">我们希望根据请求URL的参数过滤查询结果。例如，当用户调用此端点时，我们应该只包括具有正在进行或“完成”状态的todo项目:</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="09fe" class="jc jd hu ls b fv mb mc l md me"><a class="ae kv" href="https://https://my-cool-api.com/v1/todos?filter[state]=doing,done" rel="noopener ugc nofollow" target="_blank">https://</a>my-awesome-api.io/v1/todos?filter[state]=doing,done</span></pre></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h2 id="0251" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">样板文件</h2><p id="eb72" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">通常，为了获得所有用户的待办事项，我们在上下文文件中有这样的内容:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Todos Context Boilerplate</figcaption></figure><p id="0591" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">我们在控制器中这样调用这个函数:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek">Todos Controller Boilerplate</figcaption></figure></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h2 id="7075" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">解决办法</h2><p id="bbc7" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">由于过滤器参数将在URL中传递，我们需要将<code class="eh lp lq lr ls b">params</code>变量传递给上下文的<code class="eh lp lq lr ls b">list_todos/2</code>函数。我们需要这样修改我们的控制器:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="88c6" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">通过这样做，我们还需要在我们的上下文中调整我们的<code class="eh lp lq lr ls b">list_todos</code>函数的arity。我们现在还将准备使用过滤器模块的上下文，稍后我们将构建过滤器模块。</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="mh mi fg fe ff mj mk bd b be z ek"><strong class="ak">NOTE</strong>: FilterEx is the name of the module that we will building later.</figcaption></figure><p id="8978" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">在<strong class="kc hv">第7行</strong>中，我们只是检查过滤参数是否存在。如果存在，我们以列表形式返回<em class="kz">过滤器参数</em>，如果不存在，我们只返回一个空列表。</p><p id="6fda" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">我们现在将构建处理过滤的<strong class="kc hv"> FilterEx </strong>模块。</p></div><div class="ab cl li lj hc lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hn ho hp hq hr"><h2 id="cb7a" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">构建FilterEx模块</h2><p id="baf0" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">在构建这个模块时，我们将利用<strong class="kc hv">Ecto.Query.dynamic/2</strong>。如果你想了解更多，这里有<a class="ae kv" href="https://hexdocs.pm/ecto/Ecto.Query.html#dynamic/2" rel="noopener ugc nofollow" target="_blank">官方文档</a>。基本上，<code class="eh lp lq lr ls b">Ecto.Query.dynamic/2</code>让我们一点一点地构建查询表达式，然后在主查询中插入它。</p><p id="da14" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">"… <em class="kz">稍后在我们的主查询中插入</em></p><p id="f6f2" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">您可能想知道为什么我们不像这样在我们的上下文中添加对FilterEx的调用:<code class="eh lp lq lr ls b">where([t], t.user_id == ^user.id and ^FilterEx.filter(states, :state))</code></p><p id="0926" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">不过，有个问题。</p><blockquote class="kw kx ky"><p id="65f1" class="ka kb kz kc b kd la kf kg kh lb kj kk lc ld km kn le lf kp kq lg lh ks kt ku hn dt translated"><code class="eh lp lq lr ls b">dynamic</code>可以插在<code class="eh lp lq lr ls b">where</code>、<code class="eh lp lq lr ls b">having</code>或<code class="eh lp lq lr ls b">join</code>的<code class="eh lp lq lr ls b">on</code>的根上。</p></blockquote><p id="89c7" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">这就是为什么我们在第一个<code class="eh lp lq lr ls b">where</code>子句后添加了FilterEx调用，而不仅仅是对其进行插值。必须将其插入子句的根。</p><p id="f174" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">现在让我们定义模块并导入必要的Ecto模块。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="0402" class="jc jd hu ls b fv mb mc l md me">defmodule FilterEx do<br/>  import Ecto.Query</span><span id="31d5" class="jc jd hu ls b fv ml mc l md me">  # ...<br/>end</span></pre><p id="dc73" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated"><code class="eh lp lq lr ls b">FilterEx.filter/3</code>期望第一个参数是工作查询，第二个参数是过滤器列表，第三个参数是列名。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="6956" class="jc jd hu ls b fv mb mc l md me">defmodule FilterEx do<br/>  import Ecto.Query</span><span id="960e" class="jc jd hu ls b fv ml mc l md me">  @spec filter(Ecto.Query.t, list, atom) :: Ecto.Query.t  <br/>  def filter(query, [head | tail], fieldname) do<br/>    ...<br/>  end</span><span id="be2c" class="jc jd hu ls b fv ml mc l md me">  def filter(query, [], _), do: query</span><span id="2538" class="jc jd hu ls b fv ml mc l md me">end</span></pre><p id="69ef" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">在<code class="eh lp lq lr ls b">filter/3</code>函数中，我们将构建我们的初始动态查询，该查询将被传递给<code class="eh lp lq lr ls b">filter_field/3</code>函数以进一步构建动态查询。然后，我们将<code class="eh lp lq lr ls b">dynamic_query</code>插入到我们的主查询中，并将其返回给管道。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="4674" class="jc jd hu ls b fv mb mc l md me">...</span><span id="3cbc" class="jc jd hu ls b fv ml mc l md me">  def filter(query, [head | tail], fieldname) do<br/>    dynamic_query = <br/>      dynamic([q], field(q, ^fieldname) == ^head)<br/>      |&gt; filter_field(tail, field_name)</span><span id="b33e" class="jc jd hu ls b fv ml mc l md me">    query |&gt; where(^dynamic_query) <br/>  end</span><span id="0ea0" class="jc jd hu ls b fv ml mc l md me">...</span></pre><p id="1128" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">我们将在我们的<code class="eh lp lq lr ls b">filter_field/3</code>函数中使用递归方法。</p><pre class="lt lu lv lw fq lx ls ly lz aw ma dt"><span id="f4f1" class="jc jd hu ls b fv mb mc l md me">...</span><span id="a6cf" class="jc jd hu ls b fv ml mc l md me">  def filter_field(dynamic, [head | tail], fieldname) do<br/>    dynamic([q], field(q, ^fieldname) == ^head or ^dynamic)<br/>    |&gt; filter_field(tail, fieldname)<br/>  end</span><span id="878d" class="jc jd hu ls b fv ml mc l md me">...</span></pre><p id="0f33" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">我们现在已经完成了FilterEx模块的构建。</p><p id="e47d" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">以下是完整的版本:</p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="fdc5" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">感谢您的阅读。如果你有任何问题，可以随时在Twitter上跟我说<a class="ae kv" href="https://twitter.com/VinceUrag" rel="noopener ugc nofollow" target="_blank">@ Vince rug</a></p><p id="8f21" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">学到了有价值的东西？你可以随时给我买杯咖啡。❤</p><p id="20db" class="pw-post-body-paragraph ka kb hu kc b kd la kf kg kh lb kj kk jn ld km kn jr lf kp kq jv lh ks kt ku hn dt translated">在Github上与我联系:</p><div class="mm mn fm fo mo mp"><a href="https://github.com/vinceurag/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab ej"><div class="mr ab ms cl cj mt"><h2 class="bd hv fv z el mu eo ep mv er et ht dt translated">文斯·乌拉格</h2><div class="mw l"><h3 class="bd b fv z el mu eo ep mv er et ek translated">vinceurag有11个可用的存储库。在GitHub上关注他们的代码。</h3></div><div class="mx l"><p class="bd b gc z el mu eo ep mv er et ek translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ja mp"/></div></div></a></div><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="ne mg l"/></div></figure></div></div>    
</body>
</html>