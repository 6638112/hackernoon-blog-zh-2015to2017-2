<html>
<head>
<title>Understanding the IPFS White Paper part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解IPFS白皮书第二部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-the-ipfs-white-paper-part-2-df40511addbd?source=collection_archive---------5-----------------------#2017-09-22">https://medium.com/hackernoon/understanding-the-ipfs-white-paper-part-2-df40511addbd?source=collection_archive---------5-----------------------#2017-09-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6ff2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">本文是《区块链列车日志》的第5部分，从这里开始阅读:</strong> <a class="ae jp" href="https://hackernoon.com/catching-the-blockchain-train-9a0945aab958" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">搭上区块链列车</strong> </a> <strong class="it hv">。</strong></p><h1 id="5190" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">IPFS白皮书:IPFS设计</h1><p id="c745" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">IPFS堆栈如下所示:</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/6a52b62e52c44b72ea6b1cbdf7d2c9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3pjaONvymeTFFdRo.jpg"/></div></div></figure><p id="bc2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者更详细地说:</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lf"><img src="../Images/b8d2b8bf2dd47b66ce263ca5e2f8eb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vDF3h6bfp-Ir3F8g.jpg"/></div></div></figure><p id="ef1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lg">我从胡安·贝内(IPFS的BDFL)的演讲中借用了两张图片。</em></p><p id="4284" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">白皮书中的IPFS设计或多或少会自下而上地经过这些层:</p><blockquote class="lh li lj"><p id="916c" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">IPFS协议分为一系列负责不同功能的子协议:</p><p id="804b" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">1.身份—管理节点身份生成和验证。</p><p id="4775" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">2.网络—管理与其他对等方的连接，使用各种底层网络协议。可配置。</p><p id="f075" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">3.路由—维护信息以定位特定的对等点和对象。响应本地和远程查询。默认为DHT，但可交换。</p><p id="7233" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">4.交换—一种新颖的块交换协议(位交换),用于管理高效的块分发。作为市场模型，对数据复制的激励较弱。交易策略可交换。</p><p id="1afa" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">5.对象——带有链接的内容寻址的不可变对象的Merkle DAG。用于表示任意数据结构，例如文件层次结构和通信系统。</p><p id="eda0" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">6.文件——受Git启发的版本化文件系统层次结构。</p><p id="e16a" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">7.命名——一个自我证明的可变名称系统。</p></blockquote><p id="00ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是我对这些子协议的另一种命名:</p><ol class=""><li id="af6b" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo ls lt lu lv dt translated">身份:命名这些节点</li><li id="10a8" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">网络:与其他客户端交谈</li><li id="4332" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">路由:发布和查找内容</li><li id="5407" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">交换:给予和索取</li><li id="b63f" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">对象:组织数据</li><li id="52aa" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">档案:呃？</li><li id="a1a4" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo ls lt lu lv dt translated">命名:添加可变性</li></ol><p id="72e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们仔细阅读它们，看看我们能否增加对IPFS的了解。</p><h1 id="ca41" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">身份:命名这些节点</h1><p id="0c39" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">IPFS是一个P2P客户网络；没有中央服务器。这些客户端是网络的节点，需要一种方法来被其他节点识别。如果您只是将节点编号为1、2、3……任何人都可以添加一个具有现有ID的节点，并声称自己是该节点。为了防止这种情况，需要一些加密技术。IPFS是这样做的:</p><ul class=""><li id="3bcf" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated">生成一个<a class="ae jp" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank"> PKI </a>密钥对(公钥+私钥)</li><li id="20fe" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">散列公钥</li><li id="3bbb" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">产生的散列是NodeId</li></ul><p id="582d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些都是在节点的<code class="eh mc md me mf b">init</code>阶段完成的:<code class="eh mc md me mf b">ipfs init</code> &gt;产生的键存储在<code class="eh mc md me mf b">~/.ipfs/config</code>中并返回NodeId。</p><p id="bc56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当两个节点开始通信时，会发生以下情况:</p><ul class=""><li id="ef72" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated">交换公钥</li><li id="527a" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">检查是否:<code class="eh mc md me mf b">hash(other.PublicKey) == other.NodeId</code></li><li id="6dbd" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">如果是，我们已经识别了另一个节点，并且可以例如请求数据对象</li><li id="e6f0" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">如果没有，我们从“假”节点断开连接</li></ul><p id="adaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际的散列算法在白皮书中没有规定，请在此处阅读相关说明:</p><blockquote class="lh li lj"><p id="2d59" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">IPFS更喜欢自我描述的价值观，而不是将系统锁定在一组特定的功能选择上。哈希摘要值以multihash格式存储，该格式包括一个指定所用哈希函数的短标头，以及以字节为单位的摘要长度。</p><p id="14f9" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">示例:</p><p id="4c34" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated"><function code=""> <digest length=""> <digest bytes=""/></digest></function></p><p id="f142" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">这允许系统(a)为用例选择最佳功能(例如，更强的安全性与更快的性能)，以及(b)随着功能选择的改变而发展。自描述值允许兼容地使用不同的参数选择。</p></blockquote><p id="517f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些多重散列是自描述散列的整个家族的一部分，它非常棒，来看看:<a class="ae jp" href="https://github.com/multiformats/multiformats" rel="noopener ugc nofollow" target="_blank">多重格式</a>。</p><h1 id="0c8b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">网络:与其他客户端交谈</h1><p id="b8d5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">总结如下:IPFS可以在任何网络上工作(见上图)。</p><p id="0179" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里有趣的是连接到对等体的网络寻址。IPFS使用<a class="ae jp" href="https://github.com/multiformats/multiaddr" rel="noopener ugc nofollow" target="_blank">多地址</a>格式。您可以在启动节点时看到它的运行:</p><blockquote class="lh li lj"><p id="e499" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">群组监听/ip4/127.0.0.1/tcp/4001</p><p id="64a4" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">群组监听/ip4/172.17.0.1/tcp/4001</p><p id="450f" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">群组监听/ip4/185.24.123.123/tcp/4001</p><p id="791a" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">群组监听/ip6/2a 02:1234:9:0:21a:4 aff:fed 4:da32/TCP/4001</p><p id="9f06" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">/ip6/::1/tcp/4001上的群组监听</p><p id="313b" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">API服务器侦听/ip4/127.0.0.1/tcp/5001</p><p id="944a" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">网关(只读)服务器侦听/ip4/0.0.0.0/tcp/8080</p></blockquote><h1 id="e928" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">路由:发布和查找内容</h1><p id="2a89" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如<a class="ae jp" href="http://decentralized.blog/understanding-the-ipfs-white-paper-part-1.html" rel="noopener ugc nofollow" target="_blank">上一集</a>所述，路由层基于分布式哈希表，其目的是:</p><ul class=""><li id="0628" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated">宣布这个节点有一些数据(在下一章讨论的一个<code class="eh mc md me mf b">block</code>),或者</li><li id="7276" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">找到哪些节点有一些特定的数据(通过参考块的multihash)，以及</li><li id="a96f" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">如果数据足够小(=&lt; 1KB)，DHT将数据存储为其值。</li></ul><p id="c606" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">命令行接口和API没有公开白皮书中指定的完整路由接口。什么有效:</p><pre class="ku kv kw kx fq mg mf mh mi aw mj dt"><span id="f7df" class="mk jr hu mf b fv ml mm l mn mo"># tell the DHT we have this specific content:<br/>$ ipfs dht provide QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG</span><span id="5ef4" class="mk jr hu mf b fv mp mm l mn mo"># ask for peers who have the content:<br/>$ ipfs dht findprovs QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG<br/>QmYebHWdWStasXWZQiXuFacckKC33HTbicXPkdSi5Yfpz6<br/>QmczCvhy6unZEVC5ukR3BC3BPxYie4jBeRApTUKq97ZnEo<br/>QmPM3WzZ3q1SR3pzXuGPHD7e6z3eWEWCnAvrNw7Wegyc8o<br/>QmPKSqtkDmYsSxQbqNkZG1AmVnZSFyv5WF7fFE2YebNBFG<br/>QmPMJ3HLLLBtW53R2YixhVHmVb3pkR2bHni3qbqq23vBSv<br/>QmPNHJJphV1TB6Z99L6r9Y7bKaCBUQ67X17hicnEmsgWDJ<br/>QmPNhiqGg81o2Perk2i7VNvvVuuLLUMKDxMNwVauP8r5Yv<br/>QmPQJRgP3Vxi52Ho7HfnYdiCRJTRM1TXwgEnyjcwcLuKfb<br/>QmNNxr1ZoyPbwNe2CvYz1CVyvSNWsE8WNwDWQ9t9BDjnj5<br/>QmNT744VjtRFpDYB25EVLx7ha1zAVDKsd3qFjxfQLjPEXq<br/>QmNWwGRWTYeut6qvKDhJBuEJZnbqMPMfuF81MPvHvPBX89<br/>QmNZM5NmzZNPkvH2kPXDYNAB1cAeBNfxLyM9B1crgt3VeJ<br/>QmNZRDzSJybdf4rmt972SH4U9TF6sEK8q2NSEJpEt7SkTp<br/>QmNZdBUV9QXytVcPjcYM8i9AG22G2qwjZmh4ZwpJs9KvXi<br/>QmNbSJ9okrwMphfjudiXVeE7QWkJiEe4JHHiKT8L4Pv7z5<br/>QmNdqMkVqLTsJWj7Ja3oKwLNWcAYUkRjSZPg22B7rvKFMr<br/>QmNfyHTzAetJGBFTRkXXHe5om13Qj4LLjd9SDwJ87T6vCK<br/>QmNmrRTP5sJMUkobujpVXzzjpLACBTzf9weND6prUjdstW<br/>QmNkGG9EZrq699KnjbENARLUg3HwRBC7nkojnmYY8joBXL<br/>QmP6CHbxjvu5dxdJLGNmDZATdu3TizkRZ6cD9TUQsn4oxY</span><span id="f4eb" class="mk jr hu mf b fv mp mm l mn mo"># Get all multiaddr's for a peer<br/>$ ipfs dht findpeer QmYebHWdWStasXWZQiXuFacckKC33HTbicXPkdSi5Yfpz6<br/>/ip4/192.168.1.14/tcp/4001<br/>/ip6/::1/tcp/4001<br/>/ip4/127.0.0.1/tcp/4001<br/>/ip4/1.2.3.4/tcp/37665</span></pre><p id="a473" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mc md me mf b">ipfs put</code>和<code class="eh mc md me mf b">ipfs get</code>只对API中的ipns记录有效。也许在DHT上存储小数据本身还没有实现？</p><h1 id="2537" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">交换:给予和索取</h1><p id="836a" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">数据被分解成<code class="eh mc md me mf b">blocks</code>，交换层负责分配这些块。它看起来像BitTorrent，但它是不同的，所以该协议保证它自己的名字:BitSwap。</p><p id="ddba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主要区别在于，BitTorrent块与寻找相同文件的块的对等体进行交易(torrent swarm)，而BitSwap块是跨文件交易的。所以一大群IPFS数据。</p><p id="e159" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">BitSwap被建模为一个激励数据复制的市场。这种实现方式被称为比特交换策略，白皮书描述了一种可行的策略，并指出该策略可以被另一种策略取代。一个这样的物物交换系统可以基于虚拟货币，这就是FileCoin的用武之地。</p><p id="e633" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，每个节点可以决定自己的策略，因此通常使用的策略必须能够抵抗滥用。当大多数节点被设置为具有某种公平的物物交换方式时，它将像这样工作:</p><ul class=""><li id="573a" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated">当对等体连接时，它们交换它们拥有哪些块(<code class="eh mc md me mf b">have_list</code>)以及它们正在寻找哪些块(<code class="eh mc md me mf b">want_list</code>)</li><li id="b4b4" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">为了决定一个节点是否将真正共享数据，它将应用它的<code class="eh mc md me mf b">BitSwap Strategy</code></li><li id="bcaf" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">该策略基于这两个对等体之间先前的数据交换</li><li id="7a5e" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">当对等体交换块时，它们会跟踪它们共享的数据量(建立信用)和它们接收的数据量(建立债务)</li><li id="fd13" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">在<code class="eh mc md me mf b">BitSwap Ledger</code>中跟踪两个对等体之间的记账</li><li id="453e" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">如果一个对等体有信用(共享的多于接收的)，我们的节点将发送请求的块</li><li id="1171" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">如果一个节点有债务，我们的节点将共享或不共享，这取决于一个确定性函数，债务越大，共享的机会就越小</li><li id="9594" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">数据交换总是从分类帐的交换开始，如果分类帐不同，我们的节点就会断开连接</li></ul><p id="7ff7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为这是一个很酷的项目:博弈论在实践中！白皮书进一步描述了一些边缘情况，如如果我没有积木可以交换怎么办？答案很简单，收集你的同行正在寻找的区块，这样你就有东西可以交易了。</p><p id="cee2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，让我们来看看如何探究比特交换协议的内部结构。</p><p id="ce18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">命令行界面有一段<code class="eh mc md me mf b">blocks</code>和一段<code class="eh mc md me mf b">bitswap</code>；那些听起来相关的:)</p><p id="365b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了查看bitswap的运行情况，我将请求一个大文件<code class="eh mc md me mf b">Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t</code>，它是一个视频(下载它来查看什么视频！):</p><pre class="ku kv kw kx fq mg mf mh mi aw mj dt"><span id="ff81" class="mk jr hu mf b fv ml mm l mn mo"># ask for the file<br/>$ ipfs get Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t﻿</span><span id="7b62" class="mk jr hu mf b fv mp mm l mn mo"># in a seperate terminal, after requesting the file, I inspect the "bitswap wantlist"<br/>$ ipfs bitswap wantlist<br/>QmYEqofNsPNQEa7yNx93KgDycmrzbFkr5oc3NMKXMxx5ff<br/>QmUmDEBm9a8MYyqRdb3YQnoqPmqAo4cEWdKQErirFJdSWD<br/>QmY5VJPbsRZzFCTMrFBx2qtZiyyeLhsjBysyfC1fx2gE9S<br/>QmdbzYgyhqUNCNL8xU2HTSKwao1ck2Gmi5U1ygjQuJd92b<br/>QmbZDe5Dcv9mJr8fiqp5aJL2cbyu64tgzwCS2Vy4P3krCL<br/>QmRjzMzVeYRE5b6tDF3sTXMV1sTffno92uL3WwuFavBrWQ<br/>QmPavzEJQw8atvErXQis6C6GF7DRFbb95doAaFkHe9M38u<br/>QmY9fs1Pkr3nV7RkbGdfGh3q8HuKtMMCCUp22AAbwPYnrS<br/>QmUtxZkuJuyydd124Z2cfx6jXMAMpcXZRF96QMAsXc2y6c<br/>QmbYDTJkmLqMm6ojdL6pLP7C8mMVfVPnUxn3yp8HzXDcXf<br/>QmbW9MZ7cwn8svpixosAuC7GQmUXDTZRuxJ8dJp6HyJzCS<br/>QmdCLGWsYQFhi9y3BmkhUreX2S799iWGyJqvnbK9dzB55c<br/>Qmc7EvnBPf2mPCUCfvjcsaQGLEakBbUN9iycnyrLF3b2or<br/>Qmd1mNnDQPf1BAjFqDHjiLe4g4ZFPAheQCniYkbQPosjDE<br/>QmPip8XzQhJFd487WWw7D8aBuGLwXtohciPtUDSnxpvMFR<br/>QmZn5NAPEDtptMb3ybaMEdcVaoxWHs7rKQ4H5UBcyHiqTZ<br/>.<br/>.<br/>.</span><span id="448f" class="mk jr hu mf b fv mp mm l mn mo"># find a node where we have debt<br/>$ ipfs dht findprovs Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t<br/>QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3<br/>QmSoLnSGccFuZQJzRadHn95W2CrSFmZuTdDWP8HXaHca9z<br/>QmUh2KnjAvgEbJFSd5JZws4CNvt6LbC4C1sRpBgCbZQiqD<br/>Qmc9pBLfKSwWboKHMvmKx1P7Z738CojuUXkPA1dsPrvSw2<br/>QmZFhGyS2W833nKKkbqZAU2uSvBbWUytDJkKBHimwRmhd6<br/>QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic<br/>Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6</span><span id="069a" class="mk jr hu mf b fv mp mm l mn mo"># try one to see if we have downloaded from that node<br/>$ ipfs bitswap ledger QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3<br/>Ledger for &lt;peer.ID SoLMeW&gt;<br/>Debt ratio: 0.000000<br/>Exchanges:  11<br/>Bytes sent: 0<br/>Bytes received: 2883738</span></pre><p id="78ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">谢谢<code class="eh mc md me mf b">QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3</code>；你是一个多么慷慨的同伴啊！</p><p id="a8c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，看看<code class="eh mc md me mf b">block</code>命令:</p><pre class="ku kv kw kx fq mg mf mh mi aw mj dt"><span id="2f00" class="mk jr hu mf b fv ml mm l mn mo"># Let's pick a block from the wantlist above<br/>$ ipfs block stat QmYEqofNsPNQEa7yNx93KgDycmrzbFkr5oc3NMKXMxx5ff<br/>Key: QmYEqofNsPNQEa7yNx93KgDycmrzbFkr5oc3NMKXMxx5ff<br/>Size: 262158</span><span id="0455" class="mk jr hu mf b fv mp mm l mn mo">$ ipfs block get QmYEqofNsPNQEa7yNx93KgDycmrzbFkr5oc3NMKXMxx5ff &gt; slice_of_a_movie<br/># results in a binary file of 262 KB</span></pre><p id="35af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在下一章再看看块是如何适应的。</p><p id="0068" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止我们描述的栈的三层(网络、路由、交换)都是在<a class="ae jp" href="https://libp2p.io/" rel="noopener ugc nofollow" target="_blank"> libp2p </a>中实现的。</p><p id="10df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们沿着烟囱爬上IPFS的核心…</p><h1 id="90c4" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">对象:组织数据</h1><p id="9d2e" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">现在变得有趣了。您可以将IPFS总结为:分布式的、经过认证的、散列链接的数据结构。这些散列链接的数据结构就是Merkle DAG的用武之地(还记得我们上一集吗？).</p><p id="4f05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了创建任何数据结构，IPFS提供了一个灵活而强大的解决方案:</p><ul class=""><li id="dfea" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated">在图中组织数据，我们称图的节点为<code class="eh mc md me mf b">objects</code></li><li id="90de" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">这些对象可以包含数据(任何种类的数据，对IPFS透明)和/或到其他对象的链接</li><li id="572b" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">这些链接——<code class="eh mc md me mf b">Merkle Links</code>——仅仅是目标对象的加密散列</li></ul><p id="7126" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种组织数据的方式有几个有用的特性(引用自白皮书):</p><blockquote class="lh li lj"><p id="688d" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">1.内容寻址:所有内容都由它的多重哈希校验和唯一标识，包括链接。</p><p id="4549" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">2.防篡改:所有内容都用其校验和进行验证。如果数据被篡改或损坏，IPFS会检测出来。</p><p id="8b79" class="ir is lg it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">3.重复数据删除:保存完全相同内容的所有对象都是平等的，并且只存储一次。这对于索引对象特别有用，比如git树和提交，或者数据的公共部分。</p></blockquote><p id="d8f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了感受一下IPFS的物体，看看这个<a class="ae jp" href="https://ipfs.io/ipfs/QmNZiPk974vDsPmQii3YbrMKfi12KTSNM7XMiYyiea4VYZ/example#/ipfs/QmP8WUPq2braGQ8iZjJ6w9di6mzgoTWyRLayrMRjjDoyGr/graphmd/README.md" rel="noopener ugc nofollow" target="_blank">物体可视化</a>的例子。</p><p id="8f0b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另一个漂亮的特性是使用unix风格的路径，Merkle DAG的结构如下:</p><p id="55b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mc md me mf b">/ipfs/&lt;hash-of-object&gt;/&lt;named-path-to-object</code></p><p id="8da1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将在下面看到一个例子。</p><p id="6030" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这真的是全部了。让我们通过回放<a class="ae jp" href="https://gateway.ipfs.io/ipfs/QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/quick-start" rel="noopener ugc nofollow" target="_blank">快速入门</a>中的一些例子来看看它的实际应用:</p><pre class="ku kv kw kx fq mg mf mh mi aw mj dt"><span id="7b77" class="mk jr hu mf b fv ml mm l mn mo">$ mkdir foo<br/>$ mkdir foo/bar<br/>$ echo "baz" &gt; foo/baz<br/>$ echo "baz" &gt; foo/bar/baz<br/>$ tree foo/<br/>foo/<br/>├── bar<br/>│   └── baz<br/>└── baz<br/>$ ipfs add -r foo<br/>added QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR foo/bar/baz<br/>added QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR foo/baz<br/>added QmeBpzHngbHes9hoPjfDCmpNHGztkmZFRX4Yp9ftKcXZDN foo/bar<br/>added QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm foo</span><span id="d609" class="mk jr hu mf b fv mp mm l mn mo"># the last hash is the root-node, we can access objects through their path starting at the root, like:<br/>$ ipfs cat /ipfs/QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm/bar/baz<br/>baz</span><span id="0aa9" class="mk jr hu mf b fv mp mm l mn mo"># To inspect an object identified by a hash, we do<br/>$ ipfs object get /ipfs/QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm<br/>{  <br/>  "Links":[  <br/>    {  <br/>      "Name":"bar",<br/>      "Hash":"QmeBpzHngbHes9hoPjfDCmpNHGztkmZFRX4Yp9ftKcXZDN",<br/>      "Size":61<br/>    },<br/>    {  <br/>      "Name":"baz",<br/>      "Hash":"QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR",<br/>      "Size":12<br/>    }<br/>  ],<br/>  "Data":"\u0008\u0001"<br/>}</span><span id="3327" class="mk jr hu mf b fv mp mm l mn mo"># The above object has no data (except the mysterious \u0008\u0001) and two links</span><span id="7f6d" class="mk jr hu mf b fv mp mm l mn mo"># If you're just interested in the links, use "refs":<br/>$ ipfs refs QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm<br/>QmeBpzHngbHes9hoPjfDCmpNHGztkmZFRX4Yp9ftKcXZDN<br/>QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR</span><span id="19f4" class="mk jr hu mf b fv mp mm l mn mo"># Now a leaf object without links<br/>$ ipfs object get /ipfs/QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm/bar/baz<br/>{  <br/>  "Links":[  </span><span id="5379" class="mk jr hu mf b fv mp mm l mn mo">  ],<br/>  "Data":"\u0008\u0002\u0012\u0004baz\n\u0018\u0004"<br/>}</span><span id="2cf5" class="mk jr hu mf b fv mp mm l mn mo"># The string 'baz' is somewhere in there :)</span></pre><p id="fc65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">数据字段中显示的Unicode字符是数据序列化的结果。我认为IPFS使用了<a class="ae jp" href="https://github.com/google/protobuf" rel="noopener ugc nofollow" target="_blank"> protobuf </a>。如果我说错了请纠正我:)</p><p id="41c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我写这篇文章的时候，有一个实验性的<code class="eh mc md me mf b">ipfs object</code>命令的替代品:<code class="eh mc md me mf b">ipfs dag</code>:</p><pre class="ku kv kw kx fq mg mf mh mi aw mj dt"><span id="1fc6" class="mk jr hu mf b fv ml mm l mn mo">$ ipfs dag get QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm<br/>{  <br/>  "data":"CAE=",<br/>  "links":[  <br/>    {  <br/>      "Cid":{  <br/>        "/":"QmeBpzHngbHes9hoPjfDCmpNHGztkmZFRX4Yp9ftKcXZDN"<br/>      },<br/>      "Name":"bar",<br/>      "Size":61<br/>    },<br/>    {  <br/>      "Cid":{  <br/>        "/":"QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR"<br/>      },<br/>      "Name":"baz",<br/>      "Size":12<br/>    }<br/>  ]<br/>}</span><span id="f4ea" class="mk jr hu mf b fv mp mm l mn mo">$ ipfs dag get /ipfs/QmdcYvbv8FSBfbq1VVSfbjLokVaBYRLKHShpnXu3crd3Gm/bar/baz<br/>{  <br/>  "data":"CAISBGJhegoYBA==",<br/>  "links":[  </span><span id="a4c7" class="mk jr hu mf b fv mp mm l mn mo">  ]<br/>}</span></pre><p id="8b3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们看到了一些不同之处，但我们不要深入探讨。两种输出都遵循白皮书中的IPFS对象格式。一个有趣的部分是出现的“Cid ”;这是指较新的<a class="ae jp" href="https://github.com/ipld/cid" rel="noopener ugc nofollow" target="_blank">内容标识符</a>。</p><p id="a18a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">提到的另一个特性是<code class="eh mc md me mf b">pin</code>对象的可能性，这导致这些对象存储在本地节点的文件系统中。ipfs的当前go实现将其存储在<code class="eh mc md me mf b">~/.ipfs/datastore</code>目录下的<a class="ae jp" href="https://github.com/google/leveldb" rel="noopener ugc nofollow" target="_blank"> leveldb </a>数据库中。我们已经在之前的帖子中看到了pinning的作用。</p><p id="7d49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本章的最后一部分提到了对象级加密的可用性。这个还没有实现:<code class="eh mc md me mf b">status wip</code>(工作进行中；我也必须查找它)。项目页面在这里:<a class="ae jp" href="https://github.com/ipfs/specs/tree/master/keystore" rel="noopener ugc nofollow" target="_blank"> ipfs密钥库提案</a>。</p><p id="2cd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh mc md me mf b">ipfs dag</code>命令暗示了一些新的东西...</p><h1 id="b9a9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">中场休息:IPLD</h1><p id="cc6f" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如果你仔细研究了这篇文章开头的图片，你可能会想，什么是IPLD，它是如何融入其中的？根据白皮书，它不适合，因为它根本没有提到！</p><p id="dfca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的猜测是，IPLD没有被提及，因为它是后来才被介绍的，但它或多或少地映射到论文中的对象一章。IPLD比白皮书规定的范围更广，更全面。嘿，胡安，更新白皮书吧！:-)</p><p id="c8f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你不想等待更新的白皮书，看看这里:IPLD网站<a class="ae jp" href="https://ipld.io/" rel="noopener ugc nofollow" target="_blank">(行星间关联数据)</a>、<a class="ae jp" href="https://github.com/ipld/specs/tree/master/ipld" rel="noopener ugc nofollow" target="_blank"> IPLD规范</a>和<a class="ae jp" href="https://github.com/ipld/ipld#implementations" rel="noopener ugc nofollow" target="_blank"> IPLD实施</a>。</p><p id="c305" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而这个视频就是一个极好的介绍:<a class="ae jp" href="https://www.youtube.com/watch?v=Bqs_LzBjQyk" rel="noopener ugc nofollow" target="_blank">胡安·贝内:进入默克森林</a>。</p><p id="5bff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是如果你不想多读/看:IPLD和这里的“对象”和“文件”章节描述的差不多。</p><p id="cf06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">进入白皮书的下一章…</p><h1 id="8ea9" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">档案:呃？</h1><p id="aa02" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Merkle DAG对象之上，IPFS定义了一个具有版本控制的类似Git的文件系统，包含以下元素:</p><ul class=""><li id="ca96" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated"><code class="eh mc md me mf b">blob</code>:在IPFS，blobs中只有数据，它代表一个文件的概念。blobs中没有链接</li><li id="d786" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated"><code class="eh mc md me mf b">list</code>:列表也是一个IPFS文件的表示，但是由多个blobs和/或列表组成</li><li id="ed29" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated"><code class="eh mc md me mf b">tree</code>:blob、列表和/或树的集合:充当目录</li><li id="c9dd" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated"><code class="eh mc md me mf b">commit</code>:树中历史的快照(就像git提交一样)。</li></ul><p id="f112" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我听到你在想:这些斑点、列表和树不就是我们在Mergle DAG看到的东西吗？我们在那里有带数据的对象，有或没有链接，以及漂亮的类似Unix的文件路径。</p><p id="8529" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我听到你这样想，因为当我读到这一章时，我也是这样想的。搜索了一会儿后，我开始觉得这一层被抛弃了，IPLD在“对象”层停止了，在这一层之上的一切都是开放的，无论是什么实现。如果一位专家正在阅读这篇文章，并认为我完全错了:请告诉我，我会用新的见解来纠正它。</p><p id="32dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，<code class="eh mc md me mf b">commit</code>文件类型呢？白皮书的标题是“IPFS -内容寻址、版本化、P2P文件系统”，但是版本化还没有实现<a class="ae jp" href="https://github.com/ipfs/notes/issues/23" rel="noopener ugc nofollow" target="_blank">好像是</a>。</p><p id="4cbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">关于版本控制<a class="ae jp" href="https://gist.github.com/flyingzumwalt/a6821e843366d606aeb1ba53525b8669" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae jp" href="https://github.com/oduwsdl/ipwb/issues/61" rel="noopener ugc nofollow" target="_blank">这里</a>有一些头脑风暴正在进行。</p><p id="5358" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就剩下一层了…</p><h1 id="10fc" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">命名:添加可变性</h1><p id="a8e9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">由于IPFS中的链接是内容可寻址的(内容上的加密哈希表示内容的块或对象)，数据根据定义是不可变的。它只能被内容的另一个版本替换，因此它获得了一个新的“地址”。</p><p id="f1a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决方案是创建不可变内容的“标签”或“指针”(就像git分支和标签一样)。这些标签可用于表示对象(或对象图)的最新版本。</p><p id="eaa4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在IPFS，可以使用我在上一篇文章中描述的自我认证的文件系统来创建这个指针。它被命名为IPNS，工作原理是这样的:</p><ul class=""><li id="4cc4" class="ln lo hu it b iu iv iy iz jc lp jg lq jk lr jo mb lt lu lv dt translated">一个节点的根地址是<code class="eh mc md me mf b">/ipns/&lt;NodeId&gt;</code></li><li id="fcd0" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">它指向的内容可以通过向该地址发布一个IPFS对象来更改</li><li id="95d0" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">通过发布，节点的所有者(知道用<code class="eh mc md me mf b">ipfs init</code>生成的密钥的人)加密地签署这个“指针”。</li><li id="5039" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">这使得其他用户能够验证所有者发布的对象的真实性。</li><li id="24ca" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">就像IPFS路径一样，IPNS路径也是以哈希开头，后面跟一个类似Unix的路径。</li><li id="766e" class="ln lo hu it b iu lw iy lx jc ly jg lz jk ma jo mb lt lu lv dt translated">IPNS记录通过DHT公布和解决。</li></ul><p id="b885" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经在<a class="ae jp" href="http://decentralized.blog/getting-to-know-ipfs.html" rel="noopener ugc nofollow" target="_blank">了解IPFS </a>一文中展示了<code class="eh mc md me mf b">ipfs publish</code>命令的实际执行。</p><p id="ae26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">白皮书中的这一章还介绍了一些使地址更人性化的方法，但我将把这些留到下一集再动手操作。我们必须去掉地址中的这些散列，让它在我们的老式浏览器中很好地工作:<a class="ae jp" href="http://decentralized.blog/ten-terrible-attempts-to-make-ipfs-human-friendly.html" rel="noopener ugc nofollow" target="_blank">让IPFS变得对人类友好的十个可怕尝试</a>。</p><p id="e287" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">给我发推特<a class="ae jp" href="https://twitter.com/pors" rel="noopener ugc nofollow" target="_blank"> @pors </a>或者在下面留言，让我知道你对这篇文章的看法！</p></div></div>    
</body>
</html>