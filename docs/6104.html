<html>
<head>
<title>Empower the cloud to scale applications with ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持云轻松扩展应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/empower-the-cloud-to-scale-applications-with-ease-c1a47d05cf88?source=collection_archive---------10-----------------------#2017-09-03">https://medium.com/hackernoon/empower-the-cloud-to-scale-applications-with-ease-c1a47d05cf88?source=collection_archive---------10-----------------------#2017-09-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4ec0e2364d626745495669b6551f1c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l05xzhykj3iSJdLtbikdJg.jpeg"/></div></div></figure><p id="0a71" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一名开发者，我想不断地构建和发布特性。如果出现问题，那么我希望能够<strong class="je hv">回滚</strong>。另外<strong class="je hv">中央日志</strong>应该开箱即用。最重要的是，应该有类似于<strong class="je hv">自我修复</strong>的机制来避免24/7的感知。当我创建具有可伸缩性的应用程序时，我希望能够自动伸缩。如果有人在社交网络上分享我的应用程序，这可以让我降低成本，并处理大量的访问者。</p><p id="0dc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">自过去十年以来，情况发生了变化。存储非常便宜。云变得可支付，并减少了处理应用程序不断变化的流量峰值所需的工作量。此外，还有生产就绪的方法来隔离运行应用程序，如<a class="ae ka" href="https://hackernoon.com/tagged/docker" rel="noopener ugc nofollow" target="_blank"> docker </a>。</p><p id="b97f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将向您展示如何将应用程序开发的最佳实践与云解决方案结合起来。</p><h1 id="4da1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.容器化应用</h1><p id="7763" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="http://blog.aquasec.com/a-brief-history-of-containers-from-1970s-chroot-to-docker-2016" rel="noopener ugc nofollow" target="_blank">集装箱很旧，docker也没什么新的。但是改变的是容器周围的工具。如果我把我的应用程序放在一个容器中，那么我将获得很大的灵活性，并避免</a><a class="ae ka" href="https://en.wikipedia.org/wiki/Vendor_lock-in" rel="noopener ugc nofollow" target="_blank">供应商锁定</a>。</p><p id="b6cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，AWS (Lambda)的无服务器产品就是一个很好的例子。我可以将一些小功能部署到云上，并将它们连接起来，形成一个高度可扩展的系统。在这种情况下，我不需要管理任何东西。但是，如果我想换成另一种产品会怎么样呢？通常这很难。通常建议使用他们的数据库。在这种情况下，数据库也是完全托管的，并且高度可扩展。如果我同意使用他们有益的工具，他们就会抓住我。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="99a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，他们可以按照自己的意愿改变价格和报价。</p><p id="12e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">将我的代码隔离起来</strong>保护我免受这样的牢狱之灾。我还尝试在开发、测试和生产环境中运行相同的应用程序，以降低复杂性。通过使用环境变量，我可以控制调试设置和其他环境细节。我将演示这有多简单。</p><p id="f066" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过使用正确的Docker映像，可以将NodeJs应用程序容器化。我创建了一个包含一些应用程序代码的简单文件:</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="d091" class="lp kc hu ll b fv lq lr l ls lt">// server.js<br/>var http = require('http'); <br/>var ifaces = require('os').networkInterfaces();<br/><br/>http.createServer((req, res) =&gt; {<br/>    // simulate some io like a db access<br/>    setTimeout(() =&gt; {<br/>        res.end('Hello it\'s '+ new Date())<br/>    }, 50)<br/>}).listen(8080)</span></pre><p id="c14d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要拥有有效的NodeJs应用程序，需要初始化NodeJs项目。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="94ed" class="lp kc hu ll b fv lq lr l ls lt"><strong class="ll hv">$ npm init</strong></span><span id="b3cf" class="lp kc hu ll b fv lu lr l ls lt">(...)</span><span id="1b59" class="lp kc hu ll b fv lu lr l ls lt">{<br/>  "name": "gcloud",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "server.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "node server.js"<br/>  },<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span><span id="87f8" class="lp kc hu ll b fv lu lr l ls lt">Is this ok? (yes) <strong class="ll hv">yes</strong></span></pre><p id="c11f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步是创建Dockerfile文件，将应用程序放入容器中。我使用包含启动应用程序所需的每个步骤的<a class="ae ka" href="https://github.com/nodejs/docker-node/blob/master/8.3/onbuild/Dockerfile" rel="noopener ugc nofollow" target="_blank"> node:onbuild image </a>。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="c440" class="lp kc hu ll b fv lq lr l ls lt"># Dockerfile<br/>FROM node:onbuild<br/>EXPOSE 8080</span></pre><p id="5f36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样！现在容器可以在本地构建和运行了。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="f8e3" class="lp kc hu ll b fv lq lr l ls lt">$ docker build -t my-app:v1 .<br/>$ docker run -p 80:8080 my-app:v1</span></pre><p id="a927" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">之后应用程序运行:<a class="ae ka" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a></p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="lv lj l"/></div></figure><p id="504b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着我现在可以:</p><ul class=""><li id="bf9b" class="lw lx hu je b jf jg jj jk jn ly jr lz jv ma jz mb mc md me dt translated">在每个环境中运行这个容器(Windows、MacOS、Linux等等)，</li><li id="6d44" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">多次启动它(使用不同的端口:-p 81:8080，-p 82:8080，…)，</li><li id="9674" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">暂停、运行和更新它，</li><li id="8ac2" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">与他人共享此容器，</li><li id="9c94" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">运行它不会对系统产生任何副作用。</li></ul><p id="d548" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种灵活性允许我为我的应用程序自由选择最佳环境。请随意尝试。把它放在AWS，谷歌云，Azure或者老式的裸机服务器上。</p><h1 id="5397" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">2.创建无状态应用程序</h1><p id="5c16" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">伸缩的基础是能够将流量分配给运行我的应用程序的多台机器。当然，我可以用一个更强大的服务器替换我现在的服务器。但是这样做的成本更高，并且会达到无法再进行扩展的程度。</p><p id="5fa8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">云有现成的工作负载均衡器，将流量分配给多台机器。<strong class="je hv">将状态保存在数据库或客户端使伸缩成为可能</strong>。什么机器处理特定访问者的什么请求并不重要。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/d01969e313e7edd5cae42dd70eb19072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*niGginG20q3DU_FzmuMHsw.jpeg"/></div></figure><p id="6c92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了演示如何设置这样一个环境，我使用了谷歌云引擎。我也可以通过使用AWS等其他提供者来获得类似的结果。</p><p id="1dd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">按照我的指示，你需要<a class="ae ka" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">创建一个谷歌云账户</a>。有一个免费的流量，你可以使用1年。因此你可以随便玩玩。但是要小心，总是关闭所有实例。否则会有意想不到的成本。为了安全起见，在你开始玩之前，定义一些限制。对我来说，这是一个恼人的负担，因为我害怕有意想不到的成本。</p><p id="4a44" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">体验云环境</strong>非常重要。就这么做吧，探索如何托管当今的现代应用程序。它并不像你的直觉告诉你的那样危险:)。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="ml lj l"/></div></figure><p id="c89c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">特别是在Google Cloud上，有很棒的互动教程，总是关注清理使用过的资源。</p><p id="0cb2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">安装完<a class="ae ka" href="https://cloud.google.com/sdk/docs/" rel="noopener ugc nofollow" target="_blank"> Google cloud sdk </a>之后，你应该准备好了。我会用Google App Engine的<a class="ae ka" href="https://cloud.google.com/appengine/docs/flexible/" rel="noopener ugc nofollow" target="_blank">灵活变种</a>。这是他们产品的完全管理的变体。如果我需要更多的控制，我使用他们的容器引擎。</p><p id="2de2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我可以上传一个docker容器，我将有一个运行设置。有一个小助手工具，为我准备云的应用。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="dd54" class="lp kc hu ll b fv lq lr l ls lt">$ gcloud beta app gen-config --custom</span></pre><p id="ee8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将创建一个<em class="mm"> app.yaml </em>文件并更新我的<em class="mm">docker文件</em>。现在，我准备将我的应用程序部署到Google App Engine。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="fb74" class="lp kc hu ll b fv lq lr l ls lt">$ gcloud app deploy</span></pre><p id="0f9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是这样。这将需要一段时间，因为这是我的第一次部署。之后，我有2个运行实例。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="eefc" class="lp kc hu ll b fv lq lr l ls lt">$ gcloud app instances list</span><span id="710e" class="lp kc hu ll b fv lu lr l ls lt">SERVICE  VERSION       ID                                VM_STATUS <br/>default  20170813t112  aef-default-20170813t112927-cgvs  RUNNING<br/>default  20170813t112  aef-default-20170813t112927-k4qg  RUNNING</span></pre><p id="f904" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我有了一个基于我的容器的高度可伸缩的环境，它给了我很多很酷的功能。仅举几个例子:</p><ul class=""><li id="9241" class="lw lx hu je b jf jg jj jk jn ly jr lz jv ma jz mb mc md me dt translated">当流量增加时自动放大和缩小，</li><li id="8dbe" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">无需停机即可重新部署我的应用程序，</li><li id="cefc" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">将流量分流到不同版本以测试新功能，</li><li id="823f" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">出错时回滚到旧版本，</li><li id="bd01" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">中央日志记录和</li><li id="2318" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">运行状况检查，并在出现问题时自动重启。</li></ul><p id="6093" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我已经应用了很多有益的工具，甚至在我考虑如果我的应用程序发展，这些东西在将来会很重要之前。</p><h1 id="e8d6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.将CDN用于静态内容</h1><p id="9ee2" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">除了与容器相关的特性，云还提供了更多。其中一个有用的特性是简单集成了一个<a class="ae ka" href="https://en.wikipedia.org/wiki/Content_delivery_network" rel="noopener ugc nofollow" target="_blank">内容交付网络(CDN) </a>。<a class="ae ka" href="https://cloud.google.com/storage/" rel="noopener ugc nofollow" target="_blank">云存储</a>不是真正的CDN，但具有类似的优势，并且非常易于使用。通常，cdn用于提供静态内容。这些文件将存储在许多位置，以缩短请求的响应时间。将自动选择最近的可用位置来处理资源请求。尤其是现代应用程序有很多这样的问题:</p><ul class=""><li id="0188" class="lw lx hu je b jf jg jj jk jn ly jr lz jv ma jz mb mc md me dt translated">图片，</li><li id="d67e" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">Css，</li><li id="8b49" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">字体和</li><li id="fb0e" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated">动态客户端脚本(JavaScript)。</li></ul><p id="d733" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">IO(数据库访问，文件访问)一直是web应用的瓶颈。因此，努力减少真正的请求总是好的。所有可以缓存的静态文件都应该被缓存。这大大减少了应用程序的工作量。我尽可能将简单的工作外包给高度专业化的系统。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="mn lj l"/></div></figure><p id="3afe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我打开任何复杂的网站，比如亚马逊，我会看到大量的请求。他们的比例是这样的:</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="3b78" class="lp kc hu ll b fv lq lr l ls lt">287 requests, 5.8 MB transferred, Finished after 1.4 seconds</span><span id="5bed" class="lp kc hu ll b fv lu lr l ls lt">initial request is about 103 KB</span><span id="e3ab" class="lp kc hu ll b fv lu lr l ls lt">~99% cachable</span></pre><p id="afd2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们计算一下创建一个可以处理100万用户的页面:</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="23f8" class="lp kc hu ll b fv lq lr l ls lt">198 / 200 requests are static<br/>1,000,000 users</span><span id="03a4" class="lp kc hu ll b fv lu lr l ls lt"># a user will go from page to page every 10 seconds<br/>1,000,000 users / 10 s = 100,000 full page loads / s<br/>20,000,000 requests per seconds without a CDN</span><span id="b622" class="lp kc hu ll b fv lu lr l ls lt">200,000 requests per second with a CDN</span></pre><p id="ce18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从<em class="mm"> 20，000，000 rq / s </em>到200，000听起来可以实现。没有CDN这个目标似乎很重。这只是交通高峰时的负荷。但特别是我想乘着人群的浪潮。可能发生的最糟糕的事情是我的应用程序在如此激动人心的时刻崩溃。</p><p id="c141" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到我的例子，我添加了一个JavaScript和CSS到我的基本站点。因此，必要的请求增加了两倍。我可以使用谷歌云存储来外包我的静态文件。首先，我创建一个存储，允许公共读取访问，并同步我的静态资源文件夹:</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="868e" class="lp kc hu ll b fv lq lr l ls lt">$ gsutil mb gs://medium-example<br/>$ gsutil defacl set public-read gs://medium-example<br/>$ gsutil -m rsync -r ./public gs://medium-example/public</span></pre><p id="733b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我打开谷歌云存储概述就能看到确切位置。</p><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/8754aaf07fdd520462902ebefec6180e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lyUDIaFOF5knjac95RUEUw.png"/></div></div></figure><p id="d6f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我可能只想访问生产环境中的存储托管资源。因此，我需要在我的应用程序中调整一些资源路径，如下所示:</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="b1a1" class="lp kc hu ll b fv lq lr l ls lt"><strong class="ll hv">const resourcePath = process.env.ENVIRONMENT === "production" ? 'https://storage.googleapis.com/medium-example' : '.'</strong></span><span id="717f" class="lp kc hu ll b fv lu lr l ls lt">const simulateSomeWorkToDo = (pathname, res) =&gt; {<br/>  // simulate some io like a db access<br/>  setTimeout(() =&gt; {<br/>    res.end(`<br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>        &lt;link rel="stylesheet" type="text/css"   <br/>        href="${resourcePath}/public/general.css"&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        Hello,<br/>        it's ${new Date()}.<br/>      &lt;/body&gt;<br/>    &lt;script src="${resourcePath}/public/general.js"&gt;&lt;/script&gt;<br/>    &lt;/html&gt;`)<br/>  }, 50)<br/>}</span></pre><p id="1e8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了在我的生产应用程序中设置变量，我可以修改app.yaml文件。</p><pre class="le lf lg lh fq lk ll lm ln aw lo dt"><span id="bb27" class="lp kc hu ll b fv lq lr l ls lt">env: flex<br/>runtime: custom</span><span id="a7af" class="lp kc hu ll b fv lu lr l ls lt">env_variables:<br/>  ENVIRONMENT: 'production'</span></pre><p id="3e1f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我如何使用当今的云来专注于应用程序开发而不是运营。我使用容器在任何我想去的地方运行我的应用程序。通过使用像Google App Engine这样的容器管理解决方案，我有了一个预配置的集群，它有很多功能。通过将静态内容放入CDN，我缩短了响应时间，节省了成本，并进一步提高了可扩展性。</p><p id="e937" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">能够快速<strong class="je hv">更新应用</strong>真是太有趣了。或者通过执行单个命令<strong class="je hv">将它们发送到生产就绪环境</strong>。我可以利用<a class="ae ka" href="https://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank">金丝雀释放</a>或回滚，如果出了问题。我什么也没做就把HTTPS从盒子里拿了出来。<strong class="je hv">中央日志</strong>，s <strong class="je hv"> elf修复机制，自动缩放</strong>等等。最好的一点是:你不需要管理你的服务器。没有更新，没有重新启动，你的服务器没有问题。如果出现问题，云会自动用一个新的实例替换缺陷实例。</p><p id="cf84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有云提供商都在自动化运营方面花费了大量时间。这不是devs的主要业务。因此，我使用现有的解决方案。此外，我可以花更多的时间做对我的生意重要的事情。</p><p id="1f88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想看得更多，享受阅读的乐趣，那么请随意点击小按钮。如果你今天过得很好<a class="ae ka" href="https://twitter.com/Journerist" rel="noopener ugc nofollow" target="_blank">，请在twitter上关注我</a>。</p><h1 id="b91f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">参考资料:</h1><ul class=""><li id="13fa" class="lw lx hu je b jf kz jj la jn mp jr mq jv mr jz mb mc md me dt translated"><a class="ae ka" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">https://12factor.net/</a></li><li id="eafb" class="lw lx hu je b jf mf jj mg jn mh jr mi jv mj jz mb mc md me dt translated"><a class="ae ka" href="https://cloud.google.com/sdk/docs/" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/</a></li></ul><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="ms lj l"/></div></figure></div></div>    
</body>
</html>