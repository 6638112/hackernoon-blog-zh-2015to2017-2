<html>
<head>
<title>Are Ethereum Contracts Vulnerable to Hash Table Poisoning Attacks?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊合约容易受到哈希表中毒攻击吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/are-ethereum-contracts-vulnerable-to-hash-table-poisoning-attacks-a4d9241e16c4?source=collection_archive---------10-----------------------#2017-06-05">https://medium.com/hackernoon/are-ethereum-contracts-vulnerable-to-hash-table-poisoning-attacks-a4d9241e16c4?source=collection_archive---------10-----------------------#2017-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8ee4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">TL；博士</strong>:没有。但是理解其中的原因很好，说服自己也教会了我更多关于以太坊的知识。</p><p id="19c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的前雇主<a class="ae jp" href="https://www.twosigma.com/" rel="noopener ugc nofollow" target="_blank">有一个长期流传的笑话。在某些时候，一些新员工会抱怨Java的HashMap类是不确定的，而我的同事会笑着附和说“是的，很抱歉，这是我的错”，我们都会开心地笑。笑话是我的同事</a><a class="ae jp" href="http://taz.newffr.com/TAZ/Reseaux/Techniques_Attaques/dos/CrosbyWallach_UsenixSec2003.pdf" rel="noopener ugc nofollow" target="_blank">在读博士期间开创了针对哈希表之类的DoS攻击</a>，这导致Sun对Java的实现进行了修改(其副作用是使HashMap上的迭代变得不确定)。</p><p id="8262" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是尽管这个发现已经有15年了，它仍然有点神秘。(正如插科打诨的频率所证明的那样，很少有公司能像TS一样对新员工如此挑剔。)所以当我看到<a class="ae jp" href="https://solidity.readthedocs.io/en/develop/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>(最常用于编写<a class="ae jp" href="https://hackernoon.com/tagged/ethereum" rel="noopener ugc nofollow" target="_blank">以太坊</a>契约的脚本语言)有一个内置映射类型的<a class="ae jp" href="http://solidity.readthedocs.io/en/develop/types.html?#mappings" rel="noopener ugc nofollow" target="_blank">，却没有提到实现细节时，我想知道“使用映射的Solidity契约容易受到这种中毒攻击吗？”谷歌返回了关于这个话题的bupkis，所以我在儿子看</a><a class="ae jp" href="http://pbskids.org/naturecat/" rel="noopener ugc nofollow" target="_blank">自然猫</a>的时候深入研究了一下。</p><h2 id="89d3" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">什么是哈希表中毒攻击？</h2><p id="4d18" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">众所周知，哈希表的平均查找时间为O(1+ε)，但哈希表冲突会将性能降低到O(n)。如果您知道哈希算法，您可以向它输入会导致其性能下降的特定输入。这在以太坊合同中是非常危险的。从一个天真的观察者的角度来看，你可能会导致合同过早地达到气体限制，可能会永久地影响合同中使用地图的任何行为，或者如果气体限制没有考虑到地图查找的真实成本，则影响采矿本身。</p><p id="6d57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，语言在映射实现中使用非常弱的哈希算法，通常围绕梅森素数2–1。(和固定精度的整数一样，质数总是在循环集内乘法生成。)这是速度所必需的。语言实现通常通过为哈希算法随机化一个salt来保护自己免受这种影响(因此Java的HashMap类具有不确定性)。但是这怎么能在以太坊工作呢？合同的执行必须是完全确定的。</p><p id="687c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们可以想象以太坊试图通过使用更好的哈希算法(比如SHA3)来解决这个问题，但代价是执行速度。但这仍然是可利用的。几乎所有的哈希表实现都采用哈希值模数(内部存储数组的大小)来获取内部位置。即使使用SHA3，如果有一个默认容量或者说16，您也有1/16的机会生成一个SHA3散列，将一个实体放入一个特定的桶中。虽然难度随着容量的增加而增加，但几乎可以肯定的是，容量大小与散列成本之间存在一个最佳平衡点，以完成一份在经济上仍然可行的合同。让我们保守地说，在一个8字节的nonce ( <a class="ae jp" href="https://bench.cr.yp.to/results-sha3.html" rel="noopener ugc nofollow" target="_blank"> src </a>)上计算SHA3需要每字节200个CPU周期。在我的普通桌面上，这仍然是～2M SHA3/s。这将允许我创建一个100，000条目的哈希表，其中所有条目都在大约100，000秒的时间内处于同一槽中。1小时。当然，让以太坊合约在预期为O(1)的地方进行O(100，000)运算是可以利用的！是时候找到Solidity的哈希表实现了。</p><h2 id="5d47" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">“映射”在Solidity中是如何工作的？</h2><p id="1438" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">文档什么也没给你。让我们看看代码:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="06f0" class="jq jr hu kv b fv kz la l lb lc">$ git clone https://github.com/ethereum/solidity<br/>$ grep -Ri mapping solidity</span></pre><p id="1cd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该死，没那么容易。；)我就不赘述细节了，但是根本不清楚Solidity是在Solidity代码库的什么地方(或者是否)实现哈希表。相反，让我们来看看由一个小契约生成的程序集:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="8b9f" class="jq jr hu kv b fv kz la l lb lc">pragma solidity ^0.4.0;<br/>contract TestMapping {<br/>  mapping(uint =&gt; uint) aMap;<br/>  function doit() { aMap[10] = 20; }<br/>}</span></pre><p id="fadf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">给你:</p><pre class="kq kr ks kt fq ku kv kw kx aw ky dt"><span id="d458" class="jq jr hu kv b fv kz la l lb lc">JUMPDEST 		function doit() { aMap[10] = 2...<br/>PUSH 14			20<br/>PUSH 0			aMap<br/>PUSH 0			aMap[10]<br/>PUSH A			10<br/>DUP2 			aMap[10]<br/>MSTORE 			aMap[10]<br/>PUSH 20			aMap[10]<br/>ADD 			aMap[10]<br/>SWAP1 			aMap[10]<br/>DUP2 			aMap[10]<br/>MSTORE 			aMap[10]<br/>PUSH 20			aMap[10]<br/>ADD 			aMap[10]<br/>PUSH 0			aMap[10]<br/>SHA3 			aMap[10]<br/>DUP2 			aMap[10] = 20<br/>SWAP1 			aMap[10] = 20<br/>SSTORE 			aMap[10] = 20<br/>POP</span></pre><p id="e8f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这看起来一点也不像哈希表存储操作！这是怎么回事？看起来我们用SHA3散列密钥，但是没有做任何查找，只是依赖SSTORE。EVM在做什么？</p><p id="4b6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这之前，我没有考虑过EVM内存管理。在某种程度上，我想我只是假设它像任何其他VM中的任何其他类一样工作。一个struct + function表在一个很小但可增长的地址空间里。可变大小的结构，如列表或映射，有一个默认的固定大小，并以某种幂函数自动增长，其ε成本被挖掘代码平均或吞噬。但那完全不是真的。你的合同可以访问一个巨大的2 ⁵⁶位虚拟地址空间。SSTORE获取您的密钥的SHA3，将其附加到您的契约的SHA3，并获取其中的SHA3，然后它成为您的值的内存存储位置。这太神奇了，因为这是我见过的第一个映射实现，它通过牺牲几乎无限的内存地址空间，在所有情况下都提供了真正的O(1)查找(从EVM字节码的角度来看)。整个EVM内存空间变成了一个极其稀疏(并且全局共享)的哈希表数组！</p><p id="d936" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这也解释了关于实度映射的其他奇怪之处。例如，你不能在Solidity中迭代一个映射，根据Google/StackExchange的判断，这是一个常见的混淆点。对哈希表的迭代通常包括对其内部数组的迭代，跳过空单元格。当您的表只有大约25–75%满时，这种方法很有效；当你有对象时，你最多迭代4倍的内存位置。但是迭代2个⁵⁶地址显然是不可行的。同样，假设结构映射总是让结构初始化，这一事实使得<em class="ld">在这个上下文中更有意义。EVM不会将指向某个堆的指针保存在某个连续的地址空间中——该结构只是覆盖在一个全为零的地址上，其大小无关紧要。</em></p><h2 id="f266" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">那么EVM如何给你一个2 ⁵⁶的内存空间呢？</h2><p id="2308" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">很明显这不是malloc it。；)我在这里没有做太深入的研究，只知道EVM使用自己的内部关联数组跟踪内存就够了。这是有意义的，并且是存储大型/稀疏矩阵的一种非常常见的技术，EVM的存储空间可以被认为是一个巨大的256 x 2 ⁵⁶位矩阵。</p><p id="b703" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一切让我相信，个人以太坊合约是不容易受到哈希表中毒DoS攻击的。通过使用安全散列函数，而不是将散列空间减少到固定的数组大小，在散列表中查找冲突与在SHA3本身中查找冲突的难度相同。</p><h2 id="a4ef" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">EVM的内部关联数组可以被利用吗？</h2><p id="f63b" class="pw-post-body-paragraph ir is hu it b iu kl iw ix iy km ja jb jc kn je jf jg ko ji jj jk kp jm jn jo hn dt translated">这个我不确定。我不知道EVM是否在使用它自己的内部哈希表，在它自己的内部映射中的那个巨大的地址空间中存储数据。但即使是，在实践中也会非常困难。显然，2 ⁵⁶位内存空间正在缩小到你的电脑内部。我找不到任何关于全球以太坊国家规模的统计数据，但它显然足够大，以至于花费足够多的气体来写足够多的数据来毒害它将是成本过高的。可能不是——我可以在这里看到一个基数树的强有力的例子。但是那不在这次调查的范围之内。</p><p id="2b14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">反正就是这样！</p><figure class="kq kr ks kt fq lf fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff le"><img src="../Images/a8bdc83f4face05331e5486315eb45ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*PUKXGRN_04kmelO3.png"/></div></div></figure><div class="kq kr ks kt fq ab cb"><figure class="lm lf ln lo lp lq lr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lm lf ln lo lp lq lr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lm lf ln lo lp lq lr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ls lt lu"><p id="f922" class="ir is ld it b iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is ld it b iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kq kr ks kt fq lf fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff ly"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kq kr ks kt fq lf"><div class="bz el l di"><div class="lz ma l"/></div></figure></div></div>    
</body>
</html>