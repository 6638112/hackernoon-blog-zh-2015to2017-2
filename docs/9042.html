<html>
<head>
<title>Consistently bad parsing of YAML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对YAML的解析一直很糟糕</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/consistently-bad-parsing-of-yaml-ae23eb3676a1?source=collection_archive---------11-----------------------#2017-12-23">https://medium.com/hackernoon/consistently-bad-parsing-of-yaml-ae23eb3676a1?source=collection_archive---------11-----------------------#2017-12-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8bf9feeaa62750828cc97fc637c0199a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*po99Up3sDz_WqlWCfCLyqA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://upload.wikimedia.org/wikipedia/commons/4/4d/Cdsan-Samples-CppParseTree-01-HiRes.jpg" rel="noopener ugc nofollow" target="_blank">Credit</a></figcaption></figure><p id="05ac" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">解析器不容易做对。<code class="eh kf kg kh ki b">libyaml</code>，<a class="ae jg" href="https://hackernoon.com/tagged/yaml" rel="noopener ugc nofollow" target="_blank"> YAML </a>的引用解析器，做了大多数正确的事情。然而，有一件小事它做错了，但是因为它做的其他事情都很好，这件小事被忽略了。更糟糕的是，其他解析器实现故意做错了，因为“这就是<code class="eh kf kg kh ki b">libyaml</code>的工作方式”。尽管还有希望，继续读下去。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="35f0" class="ky kz hu ki b fv la lb l lc ld">Found unexpected ‘:’ </span></pre><p id="e5ad" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您正在<a class="ae jg" href="https://hackernoon.com/tagged/parsing" rel="noopener ugc nofollow" target="_blank">解析</a>YAML——您很可能是这样或那样的人——您可能会在解析以下内容时发现这个错误:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="86b9" class="ky kz hu ki b fv la lb l lc ld">urls: [<a class="ae jg" rel="noopener" href="/">https://medium.com</a>]</span></pre><p id="a421" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">(即流程顺序)</p><p id="f333" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">或者:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="9a24" class="ky kz hu ki b fv la lb l lc ld">location: {url: <a class="ae jg" rel="noopener" href="/">https://medium.com</a>}</span></pre><p id="044f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">(即流映射)</p><p id="5b04" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尽管YAML规范明确地说它是有效的:</p><blockquote class="le lf lg"><p id="6d45" class="jh ji lh jj b jk jl jm jn jo jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ke hn dt translated">通常情况下，YAML坚持将<em class="hu"/><code class="eh kf kg kh ki b"><strong class="jj hv"><em class="hu">:</em></strong></code><em class="hu">”映射值指示器</em>与值用空格隔开。这种限制的一个好处是“<code class="eh kf kg kh ki b"><strong class="jj hv">:</strong></code>”字符可以在普通标量中使用，只要它后面没有空格。这允许无引号的URL和时间戳。</p></blockquote><h1 id="f805" class="ll kz hu bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh dt translated">发生什么事了？</h1><p id="56fa" class="pw-post-body-paragraph jh ji hu jj b jk mi jm jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke hn dt translated">这是因为您的用于<insert_your_language_here>的YAML解析器要么依赖于<code class="eh kf kg kh ki b">libyaml</code>(作为共享库加载并提供到它的绑定)，要么使用<code class="eh kf kg kh ki b">libyaml</code>作为它们的引用解析器，换句话说，作为“所有YAML解析器之母”并镜像其行为，而不是严格遵循YAML规范。这没什么大不了的，但我是在转述事实。</insert_your_language_here></p><p id="9770" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">T21的好消息是有一个简单的解决方法。在流上下文中引用包含冒号的字符串也可以(即<code class="eh kf kg kh ki b">'https://medium.com'</code>)。</p><p id="dfd1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">坏消息是，似乎不同语言的解析器处理这个问题的方式不一致:</p><ul class=""><li id="a5b3" class="mn mo hu jj b jk jl jo jp js mp jw mq ka mr ke ms mt mu mv dt translated">Python <code class="eh kf kg kh ki b">pyyaml</code>抛出了一个错误，一个<a class="ae jg" href="https://github.com/yaml/pyyaml/pull/45" rel="noopener ugc nofollow" target="_blank"> PR </a>修复了这个错误，已经被合并但是还没有发布</li><li id="1f14" class="mn mo hu jj b jk mw jo mx js my jw mz ka na ke ms mt mu mv dt translated">Ruby <code class="eh kf kg kh ki b">psych</code>抛出一个错误</li><li id="3151" class="mn mo hu jj b jk mw jo mx js my jw mz ka na ke ms mt mu mv dt translated">Golang <code class="eh kf kg kh ki b">go-yaml</code>抛出错误，问题提交<a class="ae jg" href="https://github.com/go-yaml/yaml/issues/295" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="9667" class="mn mo hu jj b jk mw jo mx js my jw mz ka na ke ms mt mu mv dt translated">Java <code class="eh kf kg kh ki b">snakeyaml</code>抛出错误，问题提交<a class="ae jg" href="https://bitbucket.org/asomov/snakeyaml/issues/397" rel="noopener ugc nofollow" target="_blank">此处</a></li><li id="5569" class="mn mo hu jj b jk mw jo mx js my jw mz ka na ke ms mt mu mv dt translated">JavaScript <code class="eh kf kg kh ki b">JS-YAML</code>很好地处理了这个问题</li></ul><p id="5b02" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">并且:</p><ul class=""><li id="bf1c" class="mn mo hu jj b jk jl jo jp js mp jw mq ka mr ke ms mt mu mv dt translated"><code class="eh kf kg kh ki b">libyaml</code>抛出了一个错误，但是<strong class="jj hv">另一个好消息</strong>是有一个<a class="ae jg" href="https://github.com/yaml/libyaml/pull/28" rel="noopener ugc nofollow" target="_blank"> PR </a>解决了这个问题</li></ul></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="e264" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总而言之，到目前为止，唯一能正确处理这个问题的解析器是JavaScript解析器。的问题是，如果你的堆栈由JavaScript和任何其他语言组成，并且你正在全面解析YAML，这可能会导致不一致的解析行为，这不是很好。</p><figure class="kq kr ks kt fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure></div></div>    
</body>
</html>