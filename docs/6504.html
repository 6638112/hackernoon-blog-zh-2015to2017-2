<html>
<head>
<title>Pointless? Programming Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">毫无意义？编程问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/pointless-programming-problems-59427ea6f8b6?source=collection_archive---------12-----------------------#2017-09-21">https://medium.com/hackernoon/pointless-programming-problems-59427ea6f8b6?source=collection_archive---------12-----------------------#2017-09-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/729905b2b23db41e6e54377a4f915ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlK8EM50ioqzaOJqmy1rkQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Pointless or Perfect? That is the war I wage in my head about these types of problems.</figcaption></figure><p id="f8b4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="ae ke" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>挑战，面试问题，编程脑筋急转弯。为了个人的<a class="ae ke" href="https://hackernoon.com/tagged/growth" rel="noopener ugc nofollow" target="_blank">成长</a>或洞察为什么这些被如此频繁地使用，尤其是对于面试问题，我将从hackerrank.com、谷歌搜索、甚至可能从你的建议中做一些挑战。</p><p id="ac07" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先让我表达一下我对这类问题的一些纯粹的想法。像这样的编程挑战经常在面试中以一种神秘的方式使用，以了解某人是如何编程的。当处理这些类型的问题时，我经常发现自己陷入个人的斗争中，大多数时候我担心它们是没有意义的，在现实世界的编程中是看不到的。我还发现，在做这些事情的时候，我学到了很多关于问题的某些方面和我的编程风格的东西。通常这类问题也会在白板前提出，<a class="ae ke" rel="noopener" href="/javascript-scene/tech-hiring-has-always-been-broken-heres-how-i-survived-it-for-decades-b7ac33088de6">对于这一点，我听从Eric Elliot的意见，“白板是用来绘图的，不是用来编码的。”</a></p><p id="6d82" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于你们这些招聘经理来说，不要只是把这类问题写在白板上让他们去解决，而是提出一个你希望如何解决的建议。在我看来，透明度是最好的，不要在问题中隐藏你真正想要的东西。"你能用算术代替字符串比较来解决这个问题吗？"或者“你能告诉我如何使用正则表达式和模式匹配来解决这个问题吗？”让它敞开着会在你的嘴里留下酸味，因为这可能不是你在日常工作中最终得到最终解决方案的方式。话虽如此，也要理解<em class="kf">受访者</em>解决你面前的问题可能是对问题的快速第一想法，而<strong class="ji hv">不是</strong>他们在生产环境中处理事情的方式。</p><figure class="kh ki kj kk fq iv fe ff paragraph-image"><div class="fe ff kg"><img src="../Images/d96cab966f2db835e2ee7a6220355495.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*w-dHEwdZbMhi4hjEGmhaIw.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">This will be my diagnosis one day.</figcaption></figure><p id="b8fa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我为什么要重新做这些题？我已经解决了像fizz-buzz这样的问题，反转数组，寻找和替换值，为什么要浪费时间呢？简而言之，答案是我的好奇心。我不仅想解决问题，还想进行基准测试，并应用测试驱动的方法来解决这些问题。我不仅是在以面试的方式挑战自己，也是在看看哪些解决方案更好，好到什么程度。我还在构建一个清单，以便将来我需要做各种类型的数学比较、字符串比较或模式匹配时，我知道当给定某一类型的问题时，应该立即采取哪种方法。</p><h1 id="179e" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">反向元音问题</h1><p id="b20e" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">这个问题需要你取一个输入字符串，把元音反过来。起初我在JavaScript中这样做，但是我并不真正喜欢它，也没有真正的理由继续在JS <em class="kf">(不是说我对JS有问题)</em>中这样做，所以在本文中我把它移到了Ruby中。尽管最初的尝试是将JavaScript解决方案移植到Ruby上。</p><h2 id="17b0" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第一次尝试</h2><p id="e639" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">这是我对这个问题的第一次尝试，看起来像是我的JavaScript解决方案的精确移植，但在Ruby <em class="kf">(这很难看，不是一个很好的解决方案)</em>中，通过从字符串的两端而不是单向工作，做得稍微好一点。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="671c" class="lo km hu md b fv mh mi l mj mk">class ReverseVowels<br/>  # the string that gets reversed<br/>  attr_accessor :string_to_reverse</span><span id="e964" class="lo km hu md b fv ml mi l mj mk">  # init method that sets the string to an instance variable<br/>  def initialize(string_to_reverse)<br/>    @string_to_reverse = string_to_reverse<br/>  end<br/><br/>  # method that does all the work <br/>  def reverse_vowels<br/>    # temp arrays<br/>    vowels = []<br/>    indexes = [] <br/>  <br/>    # iterators for while <br/>    i = 0 <br/>    j = string_to_reverse.length - 1<br/>    half_way = (j/2.to_f).ceil<br/><br/>    # shorten var name temporarily, maybe more in the future<br/>    str = string_to_reverse <br/>    <br/>    # iterate stuff <br/>    while i &lt;= half_way &amp;&amp; j &gt;= half_way<br/>      if is_vowel?(str[i])<br/>        indexes &lt;&lt; i <br/>        vowels &lt;&lt; str[i]<br/>      end <br/>      <br/>      if is_vowel?(str[j]) <br/>        indexes &lt;&lt; j<br/>        vowels &lt;&lt; str[j]<br/>      end<br/>        <br/>      i += 1<br/>      j -= 1<br/>    end<br/><br/>    indexes = indexes.map(&amp;:to_i).sort<br/>    vowels.reverse! <br/>    <br/>    vowels.each_with_index do |v,i|<br/>      str[indexes[i]] = v<br/>    end <br/>    <br/>    return str<br/>  end<br/>  <br/>  # checks the vowels except y<br/>  def is_vowel?(character)<br/>    vowels = ['a', 'e', 'i', 'o', 'u']<br/>    vowels.include? character.to_s.downcase <br/>  end <br/>end</span></pre><h2 id="dfc0" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第二次尝试</h2><p id="6524" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">这是我明显的重构，并试图消除循环的数量。测试没有改变，所以重构简单且易于测试。唯一真正有效的方法是颠倒元音字母。这是一个思维过程，通过使用一个在中间相遇的循环可以做得更好，并在运行中进行调整。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="ae78" class="lo km hu md b fv mh mi l mj mk"> def reverse_vowels<br/>    # iterators for while <br/>    i = 0 <br/>    j = string_to_reverse.length - 1<br/>    str = string_to_reverse <br/>    <br/>    # iterate stuff <br/>    while i &lt; j<br/>      if !is_vowel?(str[i])<br/>        i += 1 <br/>        next <br/>      end <br/>      if !is_vowel?(str[j])<br/>        j -= 1 <br/>        next <br/>      end <br/><br/>      str[i], str[j] = str[j], str[i]<br/><br/>      i += 1<br/>      j -= 1<br/>    end<br/>    <br/>    str<br/>  end</span></pre><h2 id="d876" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第三次尝试</h2><p id="80e3" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">这是迄今为止最短的尝试，并且不需要使用is _元音方法。我希望这是我自己想出来的，但是我是在查看ruby api文档中的<a class="ae ke" href="https://ruby-doc.org/core-2.2.0/String.html#method-i-scan" rel="noopener ugc nofollow" target="_blank">扫描方法时发现的。试图弄清楚如何使用扫描方法，反元音问题实际上出现了。这个解决方案非常出色，属于StefanPochmann </a>。scan方法查找模式，并将项目转换为数组中的索引项目。然后，它使用gsub regex模式将数组中的最后一项放入第一个找到的元音中。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="5adf" class="lo km hu md b fv mh mi l mj mk">def reverse_vowels    <br/>  vowels = @string_to_reverse.scan(/[aeiou]/i)     <br/>  @string_to_reverse.gsub(/[aeiou]/i) { vowels.pop }  <br/>end</span></pre><h2 id="cb8f" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">绩效结果</h2><p id="4092" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">每个性能测试都是在1000次尝试的迭代中完成的，每次运行三次。每个平均值是通过对该对象进行3000次尝试而得到的。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="51c0" class="lo km hu md b fv mh mi l mj mk"># First Attempt<br/># Realtime per 1000 attempts <br/># ----------------------------------<br/>0.02257158898282796<br/>0.011442353017628193<br/>0.010828958998899907<br/>Average Time: 0.01494763366645202</span><span id="bf6c" class="lo km hu md b fv ml mi l mj mk"># Second Attempt<br/># Realtime per 1000 attempts <br/># ----------------------------------<br/>0.01959512199391611ms<br/>0.00883392000105232ms<br/>0.008858179993694648ms<br/>Average Time: 0.012429073996221026ms</span><span id="f16f" class="lo km hu md b fv ml mi l mj mk"># Third Attempt<br/># Realtime per 1000 Attempts <br/># -----------------------------------<br/>0.017268108000280336ms <br/>0.007276029995409772ms <br/>0.007084235025104135ms<br/>Average Time: 0.010542791006931415ms</span></pre><p id="0741" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">表现结果很有趣，每个人可以用不同的方式来解释。从大的方面来看，我不认为这些结果对速度有显著的影响，但是最容易保持的结果也是最快的。</p><h1 id="e6e5" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">求和问题</h1><p id="b1e1" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">问题是取一个大数字，对它的每个数字求和，然后返回值。虽然，一开始我完全不知道如何分解这个数字。我对所有这些问题的无干预解决方案是扩展到一个数组，然后迭代这些数字并求和。我后来被告知，数学编程将是更好的方法，并显示出严重的性能收益。</p><h2 id="e2e6" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第一次尝试</h2><p id="41fc" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">非严格类型化的奇妙之处在于，我可以将它分解成许多不同类型的解决方案。第一种方法是使用字符串比较将对象分成一个数组，然后将它们相加，最后返回总和。它看起来既不优雅也不时髦，所以明确的重构是合适的，但是数学上的重构呢？</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="530a" class="lo km hu md b fv mh mi l mj mk">class Sum<br/>  attr_accessor :input</span><span id="d167" class="lo km hu md b fv ml mi l mj mk">  def initialize(input_num)<br/>    @input = input_num<br/>  end<br/><br/>  def sum_input<br/>    digits = @input.to_s.split('')<br/>    sum = 0<br/>    digits.each do |digit|<br/>      sum += digit.to_i<br/>    end <br/>    sum<br/>  end<br/>end</span></pre><h2 id="a593" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第二次尝试</h2><p id="50cd" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">第二次尝试是我尝试用数学方法来做。我知道我们的数字系统是十进制的，所以我可以通过除以10来取出数字，我还知道模运算符返回余数。使用模操作符，我能够得到第一个数字的数值，然后除法帮助我把它从临时迭代器中移除。这种方法很容易用微妙的线索弄清楚，当思考数字问题时，我希望在未来记住和思考。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="e58e" class="lo km hu md b fv mh mi l mj mk">class Sum<br/>  attr_accessor :input</span><span id="65d8" class="lo km hu md b fv ml mi l mj mk">  def initialize(input_num)<br/>    @input = input_num<br/>  end<br/>  <br/>  def sum_input<br/>    i = @input<br/>    sum = 0<br/>    while i &gt; 0<br/>      sum += (i % 10)<br/>      i = (i / 10)<br/>    end<br/>    sum<br/>  end<br/>end</span></pre><h2 id="41ae" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第三次尝试</h2><p id="cd4b" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">这次尝试是想看看我能创建多小的方法来解决仍然通过测试的问题。在这之前有许多4/5衬垫和一些实验，但这是我决定进行最小尝试的一个。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="9996" class="lo km hu md b fv mh mi l mj mk">class Sum<br/>  attr_accessor :input</span><span id="fb1d" class="lo km hu md b fv ml mi l mj mk">  def initialize(input_num)<br/>    @input = input_num<br/>  end<br/><br/>  def sum_input<br/>    digits = @input.to_s.split('')<br/>    sum = eval digits.join '+'<br/>  end<br/>end</span></pre><h2 id="2bab" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">第三次尝试重构</h2><p id="e2e9" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">第三次尝试在性能测试中被评为很差，以至于我运行了几次测试，并检查了一些类型的bug。我以为会和第一次尝试一样，但结果却是迄今为止最慢的一次。我发现eval是一个缓慢的过程，在深入研究之后，我被指向了<a class="ae ke" href="https://apidock.com/ruby/Enumerable/inject" rel="noopener ugc nofollow" target="_blank"> inject方法</a>，它基本上是对一个数组的内容求和，假设它们是整数。重构之后，第三种方法能够获得与第一种方法相似的性能结果，并通过所有测试。</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="f700" class="lo km hu md b fv mh mi l mj mk">class Sum<br/>  attr_accessor :input<br/>  <br/>  def initialize(input_num)<br/>    @input = input_num<br/>  end</span><span id="709e" class="lo km hu md b fv ml mi l mj mk">  def sum_input<br/>    digits = @input.to_s.split('').map(&amp;:to_i)<br/>    sum = digits.inject(0, :+)<br/>  end<br/>end</span></pre><h2 id="6b5e" class="lo km hu bd kn lp lq lr kr ls lt lu kv jr lv lw kz jv lx ly ld jz lz ma lh mb dt translated">绩效结果</h2><p id="a2df" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">这真是令人大开眼界。这些测试中的每一个都以毫秒为单位，总共进行了3000次以上的平均尝试，并使用了从1到9999999的随机数。数学表达式快得惊人，不像我预期的那样只有几毫秒。更糟糕的是聪明的速记方法</p><pre class="kh ki kj kk fq mc md me mf aw mg dt"><span id="7e21" class="lo km hu md b fv mh mi l mj mk"># First Attempt<br/># Realtime per 1000 attempts <br/># ----------------------------------<br/>0.007490240968763828<br/>0.006662635016255081<br/>0.0066195380059070885<br/>Average Time: 0.0069241379969753325</span><span id="381a" class="lo km hu md b fv ml mi l mj mk"># Second Attempt<br/># Realtime per 1000 attempts <br/># ----------------------------------<br/>0.0007742019952274859<br/>0.0007528960122726858<br/>0.0007553229806944728<br/>Average Time: 0.0007608069960648814</span><span id="2b16" class="lo km hu md b fv ml mi l mj mk"># Third Attempt<br/># Realtime per 1000 Attempts <br/># -----------------------------------<br/>0.01474869396770373<br/>0.014116039033979177<br/>0.01710168702993542<br/>Average Time: 0.015322140010539442</span><span id="01d9" class="lo km hu md b fv ml mi l mj mk"># Third Attempt (Refactor) <br/># Realtime per 1000 Attempts <br/># -----------------------------------<br/>0.007556420983746648<br/>0.00706747395452112<br/>0.006896736973430961<br/>Average Time: 0.007173543970566243</span></pre><h1 id="9da6" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结论</h1><p id="3dae" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">结束这个过程可能是我最难以接受的，因为我已经说过我觉得这些问题是没有意义的。尽管看起来毫无意义，但它们让我思考、学习，并给了我一些在面临类似问题时可以使用的答案。如果它是基于文本的，正则表达式可能被证明是最快和最容易维护的。如果这是一个数字问题，我应该尝试找出一个数学方法来解决这个问题。</p><h1 id="8318" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="b1b2" class="pw-post-body-paragraph jg jh hu ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hn dt translated">我对AF很好奇，不得不更深入地研究一些编码挑战，并且可能会做得更多。</p><figure class="kh ki kj kk fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>