<html>
<head>
<title>Golang &amp; Docker — Microservices (RESTful API) for Enterprise Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang &amp; Docker —面向企业模型的微服务(RESTful API)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/golang-docker-microservices-for-enterprise-model-5c79addfa811?source=collection_archive---------2-----------------------#2017-09-05">https://medium.com/hackernoon/golang-docker-microservices-for-enterprise-model-5c79addfa811?source=collection_archive---------2-----------------------#2017-09-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/d29727270c73130a5f14a3b27f46e124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bnyJ9a-DxAKV-qJXKDAZkQ.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Beauty And The Beast :)</figcaption></figure><p id="0c55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">“Golang”这种由谷歌创造的语言为需要并发的应用程序提供了无可挑剔的性能，已经在技术社区中占据了一席之地，采用这种语言的知名公司包括脸书、网飞、Dropbox等。当Go API被dockerized化时，它为部署在云上的应用程序提供了更多的灵活性和控制。甚至Docker软件也是在Go上编写的，这表明了它在行业中的突出地位</p><p id="2539" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将演练构建一个包含Go API的alpine图像，实现它的步骤分为如下几个部分</p><ul class=""><li id="2ca6" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">用echo框架构建Go Restful API</li><li id="5e3b" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">用Docker在golang基础映像上构建Go二进制文件</li><li id="7544" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">构建轻量级映像(Alpine)保存Go二进制文件</li><li id="6f49" class="ka kb hu je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">用Docker创建容器</li></ul><h2 id="1fa8" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">用echo框架构建Go Restful API</h2><p id="da59" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">将该文件命名为<strong class="je hv"> main.go </strong>，其中包含依赖项——echo、logrus和net/http。我们有多个第三方框架，如Gradle、Martini、Revel等，为构建RESTful API提供了定制功能。选择一个满足你需求的服务完全是你自己的选择，你也可以只依赖golang lib "net/http "来创建一个RESTful服务。</p><p id="e87f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码片段</p><pre class="lo lp lq lr fq ls lt lu lv aw lw dt"><span id="8922" class="ko kp hu lt b fv lx ly l lz ma"><strong class="lt hv">package </strong>main<br/><br/><strong class="lt hv">import </strong>(<br/>   "fmt"<br/>   "github.com/labstack/echo"<br/>   "github.com/labstack/echo/middleware"<br/>   "github.com/sirupsen/logrus"<br/>   "net/http"<br/>)<br/><strong class="lt hv">var </strong>log =logrus.New()<br/><br/><strong class="lt hv">func </strong>init() {<br/>   log.Formatter = new(logrus.JSONFormatter)<br/>   log.Formatter = new(logrus.TextFormatter) // default<br/>   log.Level = logrus.<em class="mb">DebugLevel<br/></em>}<br/><br/><strong class="lt hv">func </strong>main() {<br/>   fmt.Println("Main function :")<br/>   e := echo.New()<br/>   e.Use(middleware.Logger())<br/>   e.Use(middleware.Recover())<br/>   // Routes<br/>   e.GET("/go-docker",  goWithDocker)<br/>   e.Logger.Fatal(e.Start(":8080"))<br/>}<br/><br/><strong class="lt hv">func </strong>goWithDocker(c echo.Context)error{<br/> <strong class="lt hv">return </strong>c.JSON(http.<em class="mb">StatusOK</em>, "Go with Docker Container")<br/>}</span></pre><p id="540d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该服务可通过HTTP端点获得</p><p id="34f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">【T2<strong class="je hv">http://localhost:8080/go-docker</strong>T5】</p><p id="0ef2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">市场上有多种IDE可供选择，其中一些是Sublime、Atom、Gogland等。我一直在使用Gogland，因为它有多种功能，并且有早期构建，请尝试一下！！</p><p id="4d32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们来谈谈这个程序，我们已经公开了一个简单的GET操作，它在HTTP协议<strong class="je hv">上公开了配置的路由<strong class="je hv"> /go-docker </strong>。</strong>日志是使用logrus框架编写的，用于跟踪请求和响应。</p><p id="ebdf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于构建管理，您可以使用安装了Docker插件的Jenkins，使其与Docker CLI交互。</p><h2 id="15a1" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated"><strong class="ak">用Docker在golang基础映像上构建Go二进制文件</strong></h2><p id="6ffc" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">根据你的需要使用docker hub中的任何golang图片<a class="ae mc" href="https://hub.docker.com/_/golang/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/golang/</a>，我们将在这个博客中使用golang:1.8</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff md"><img src="../Images/d6b183c75fd8b647a6f5f21aaaac3b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jT1zgJ6o_4Vqh0GU9mWaKA.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Ref A: Image containing the go binary</figcaption></figure><p id="eb6e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从docker hub中拉出镜像，并创建一个文件夹结构模式<strong class="je hv"> /go/src </strong>(如go所料)来编译文件。第5–7行连接了多个命令，在Github repo中提取所需的源代码和供应商依赖项(假设您的repo在/vendor dir中有第三方)。第6行&amp; 7指定生成的构建将特定于linux环境。最佳实践是始终将多个运行语句合并成一个语句，以避免在创建映像时创建多个层。</p><p id="2800" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生成的Docker构建将在/bin文件夹下有一个二进制文件<strong class="je hv"> go_docker.exe </strong></p><h2 id="4c87" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated"><strong class="ak">构建轻量级映像(Alpine)持有Go二进制文件</strong></h2><p id="ca48" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">让我们在这个演示中使用alpine 3.6基础，因为它是一个非常轻量级的映像，作为linux基础只有最低的先决条件。</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mi"><img src="../Images/8b4dad07107de90e62a298f8424726aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gflQEMOepI3br7gsCbSN-A.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Ref B : Alpine built with binary</figcaption></figure><p id="4f98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在映像中安装bash，使其在容器启动并通过docker运行后具有交互性。在第14行中，我们使用了docker新版本中发布的多阶段构建特性。<strong class="je hv"> — from </strong>标签将允许您通过提及源和目标目录，从先前创建的映像中获取并引用其内容。参考前面的<strong class="je hv">参考一个</strong>图像行1，指定<strong class="je hv"> goimage </strong>，这有助于在第14行参考它</p><p id="ce56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ENTRYPOINT命令指示容器启动应该执行。exe文件即<strong class="je hv"> go_docker </strong>文件</p><p id="c821" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有上述内容将放在一个名为<strong class="je hv"> Dockerfile </strong>的文件中，以便一次性执行。构建docker映像，并使用标签-t将其标记在某个版本下，以避免在未来的构建中发生冲突，否则docker将默认分配一个标签“最新”</p><p id="cc63" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">代码片段</p><blockquote class="mj mk ml"><p id="9962" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><em class="hu">FROM golang:1.8 as goimage<br/>ENV SRC =/go/SRC/<br/>运行mkdir-p/go/SRC/<br/>work dir/go/SRC/go _ docker<br/>运行git clone-b&lt;Specify-branch name&gt;—单分支&lt;Github HTTP Url&gt;/go/SRC/go _ docker/\<br/>&amp;&amp;CGO _ ENABLED = 0 GOOS = 1</em></p><p id="4770" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><em class="hu">FROM alpine:3.6 as base imagealp<br/>运行apk add —无缓存bash<br/>ENV WORK _ DIR =/docker/bin<br/>WORKDIR＄WORK _ DIR<br/>COPY—FROM = go image/go/src/go _ docker/bin/。/<br/>entry point/docker/bin/go _ docker<br/>EXPOSE 8080</em></p></blockquote><p id="bc54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:—表示双连字符</p><p id="c8eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可以通过发出以下命令来构建和查看映像。</p><blockquote class="mj mk ml"><p id="fab8" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><strong class="je hv"> docker build -t go_docker:1.0。</strong></p><p id="267e" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><strong class="je hv"> docker图像</strong></p></blockquote><p id="0f18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有什么我们遗漏的吗！！集装箱？我们将在下一节介绍它</p><h2 id="0ee9" class="ko kp hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">用Docker创建容器</h2><p id="d76d" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">从映像创建容器，并通过提及一个端口来公开它。您可以指定所需的端口范围，并将容器暴露给外界。在AWS中，您可以通过ECS将图像作为任务推送到EC2服务。</p><blockquote class="mj mk ml"><p id="2014" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><strong class="je hv"> docker运行— rm -p 8080:8080 go_docker </strong></p></blockquote><p id="89a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:—表示双连字符</p><p id="eb93" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦容器启动，您可以在终端上看到类似下面的内容</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mp"><img src="../Images/f1c81fbde331582e67c1f50de7343bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxk7CqupVR8ca6_TfcdcAg.png"/></div></div></figure><p id="ede9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过提及所需的URL，可以将图像推送到docker repo。映像创建和推送的步骤可以通过Shell实现自动化</p><blockquote class="mj mk ml"><p id="185e" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><strong class="je hv"> docker登录-u= &lt;用户名&gt;-p =&lt;PWD&gt;&lt;Docker回购网址&gt; </strong></p><p id="56c4" class="jc jd mb je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated"><strong class="je hv"><em class="hu">docker push-t&lt;Imagename&gt;:&lt;版本&gt; </em> </strong></p></blockquote><h1 id="2caa" class="mq kp hu bd kq mr ms mt ku mu mv mw ky mx my mz lb na nb nc le nd ne nf lh ng dt translated">结论</h1><p id="e833" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">选择Go是一个明智的决定，它为您的应用程序提供了可伸缩性和并发性，选择alpine这样的轻量级映像将使映像更快地推入和拉出注册表，并且小尺寸的基础为您提供了最少的操作功能来构建功能容器，您可以在将来添加/安装必要的依赖项。使用Docker已经获得了更广泛的认可，因为它有效地利用了磁盘空间，最有效地利用了资源。</p><h1 id="bc8e" class="mq kp hu bd kq mr ms mt ku mu mv mw ky mx my mz lb na nb nc le nd ne nf lh ng dt translated"><strong class="ak">干脆跟Docker走！！！</strong></h1></div></div>    
</body>
</html>