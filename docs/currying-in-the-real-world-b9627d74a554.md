# 真实世界中的谄媚

> 原文：<https://medium.com/hackernoon/currying-in-the-real-world-b9627d74a554>

![](img/1e5730e507ad9248073b54a4e92b631d.png)

当我开始学习函数式[编程](https://hackernoon.com/tagged/programming)的时候，我学到了很多有趣的概念。但是我想知道在现实世界中我可以在哪里使用它们。事实上，大多数教程都用简单代码给出了这些概念的例子:

不错，这是可行的，但是我很少在代码中写加法。我可以用这个来增加一个`addOne()`函数。但是大多数语言都有一个简单的方法来实现这个`i++`或`i += 1`。何必呢？

不管怎样，让我们回顾一下这段代码。第一行创建一个接受一个参数的函数`add()`，它返回另一个也接受一个参数的函数。返回的[函数](https://hackernoon.com/tagged/function)已经有一个`a`值，并且正在等待一个`b`值。第二个函数将第一个和第二个参数相加，并返回结果。为了清楚起见，第一行可以这样写:

你可以清楚地看到不太冗长的 ES6 语法的好处…你可以用两种方式调用这个函数:我刚刚展示给你的那个:`const addTwo = add(2)`和`const result = add(2)(2)`。第一个例子是一个 currying 的例子，它或多或少是你将在许多教程中看到的例子。第二个其实是给你一个结果(4)。

谄媚是:

> *将带有多个参数(或一组参数)的函数的求值转化为带有单个参数的函数序列的求值的技术。*

好的…我已经创建了一个函数`addTwo()`，它总是给你给的任何`int`加二。如果你给它一个字符串，把它连接成两个…

好吧…我该怎么处理这个。在现实世界中，奉承在哪里有用。让我们做一些重构:

这是一个小库中的方法，帮助我解析来自 API first CMS ( [Cloud CMS](https://www.cloudcms.com/) )的数据。我需要按照公司指南将日期格式化为*，解析降价，创建文档和图像 url。这是解析这些 URL 的方法。*

这个方法映射所有从 API 返回的对象，然后映射每个属性并解析适当的属性。让我们应用现有的关于 currying 的知识来重构这个方法。注意，在第 8、15、20 和 24 行，我们一次又一次地调用同一个函数，只是参数略有变化:`self.attachementUrl()`。这个函数有三个参数和两个可选参数。首先是一个`baseUrl`，然后是一个`type`附件和`attachement`对象。(attachement 是一个云 CMS 概念，其中文档被附加到一个节点，并通过一个可以被跟踪的关系进行链接。云 CMS 使用图形数据库)。可选参数是`size`和`mimetype`。

这是我们获得一些功能的机会！我们可以做的是创建一个类似于`add()`的函数，我们已经看到了，还有两个部分应用的函数，我们将在代码中使用:

函数`parse()`首先接受`baseUrl`，然后接受`type`(预览或静态)，然后接受两个参数`attachement`和`size`。我们可以将它们一起传递，因为我们知道我们用特定的大小来格式化每个案例的图像。当我们调用`self.attachementUrl()`时，我们做实际的工作，这是基本例子的`a + b`。

然后我们可以创建两个部分应用的函数:`parsePreview()`和`parseStatic()`。这两个函数对应的是我们之前看到的`addTwo()`函数。我们部分地应用了两个不会改变的参数，而将另外两个参数专门用于代码中。

因此，我们可以用下面的代码替换前面的代码:

在第 12，19，24，28 行，我们给出了部分应用函数的最后一个参数。在这个例子中，我们没有减少行数，但是通过使用 curried 函数，我们提高了代码的可维护性，因为我们减少了重复。我认为这是函数式编程的目标之一:通过使用小函数，拥有一个更易维护的代码，它做一件事，但是可靠地做这件事。

这段代码介于两者之间，因为这是我第一次看到在代码中加入函数的机会。但是现在我尝试尽可能多地应用函数式编程，即使是在面向对象的项目中。

最后，你有没有想过为什么阿谀奉承被称为阿谀奉承？实际上这与印度无关。它只是指数学家和逻辑学家哈斯凯尔·布鲁克斯·加里。

感谢 [apy](https://lobste.rs/s/siaj6w/currying_real_world#c_ut9atg) 的评论。