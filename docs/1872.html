<html>
<head>
<title>Bye 2k16 and Bye Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再见2k16，再见Angular</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/bye-2k16-and-bye-angular-ca627861839?source=collection_archive---------2-----------------------#2016-12-16">https://medium.com/hackernoon/bye-2k16-and-bye-angular-ca627861839?source=collection_archive---------2-----------------------#2016-12-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/f619711f99abfc68f5874dbfe4a5cfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRP6iXRVCQDwlguZbecpIw.jpeg"/></div></div></figure><div class=""/><p id="bc40" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是的，我们度过了一段美好的时光，有一小段时间我认为Angular是最好的，但大约在3月左右，我开始学习React，它混淆了，它挑战了(或改变了)我对软件的看法，但当我开始理解它时，我认为Angular已经结束了，并了解了为什么React js赢得了开发社区的心，为什么它将在可预见的未来继续存在。以下是我和Angular关系结束的原因。</p><ol class=""><li id="6f79" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">组件架构</li><li id="8362" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">JSX</li><li id="7e12" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">单向数据流</li><li id="f5f6" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">虚拟DOM</li><li id="bfa0" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">流量</li><li id="1249" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">函数式编程</li></ol><p id="5137" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">组件架构:</strong></p><p id="cfc4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为前端设备的状态。随着Angular 2仅转换为组件，it看到了组件架构是一种发展方向。为什么你应该在你的应用中只使用无状态组件，这有很多好处。看看这个</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="101e" class="kx ky if kt b fv kz la l lb lc">var ButtonApp = React.createClass({<br/>    render: function(){<br/>        return (<br/>            &lt;input type="submit" /&gt;<br/>        );<br/>    }<br/>});</span></pre><p id="3d1c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是React中组件的一个例子，看看理解这里发生的事情有多容易，但是如果你不得不在Angular中做同样的事情，你将不得不制定一个指令，尽管Angular团队在指令的可用性方面做了出色的工作，但他们也使学习、阅读和维护指令变得非常复杂。</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="ee20" class="kx ky if kt b fv kz la l lb lc">angular.module('foo').directive('bar', ['$rootScope', function ($rootScope) {<br/>  return {<br/>   restrict: 'E',<br/>   replace: true,<br/>   templateUrl: 'path of my button's template',<br/>//or if you have a simple template<br/>   template:'&lt;input type="submit" /&gt;',<br/>   controller : function ($rootScope,$scope) {<br/>    <br/>   },<br/>   link: function (scope, elements, attrs) {<br/>    <br/>   }<br/>  };<br/> }]);</span></pre><p id="3287" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很明显，我需要知道一个完全不同的API，以便用Angular制作一个组件，而这个API有如此多的选项，以至于大多数时候你会忘记自己真正想做什么，因为你会迷失在指令所创造的复杂性中。</p><p id="b39e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想用组件做出有用的东西</p><figure class="ko kp kq kr fq hw"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="5876" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">任何一个对<a class="ae lf" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>有一些基础知识的<a class="ae lf" href="https://hackernoon.com/tagged/programmer" rel="noopener ugc nofollow" target="_blank">程序员</a>都能够理解这里发生了什么，但是如果你看看Angular中的等价代码，你可能需要先学习几十个其他概念或语法，这样你才能理解它。</p><p id="9b72" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">组件的优势很少:</p><ol class=""><li id="b863" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">很容易知道一个组件是如何渲染的，只要看看渲染函数就知道了</li><li id="81aa" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">它确保可读性，并使可维护性更容易。</li><li id="b153" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">这很容易测试。</li><li id="6f0a" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">您可以构建可重用的组件，使我们能够与您的本地客户端共享代码。</li></ol><h1 id="69a2" class="lg ky if bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated"><strong class="ak"> JSX: </strong></h1><p id="3fd1" class="pw-post-body-paragraph jc jd if je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">JSX是一种内联标记，看起来像HTML，并被转换成JavaScript。</p><p id="1409" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这非常困难，因为就我所写的代码而言，我们将Javascript、CSS和HTML保存在不同的文件中，要理解这一点非常困难，我需要从我看到的多个教程和视频中获得更多的说服力，但现在我想知道“为什么我以前不使用它”。</p><p id="adf6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看一下这个片段:</p><figure class="ko kp kq kr fq hw"><div class="bz el l di"><div class="ld le l"/></div></figure><ol class=""><li id="3800" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">你拥有JavaScript的全部能力来描述你的UI——循环、函数、范围、组合、模块——而不是模板语言。</li><li id="73af" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">JSX事件处理程序不像HTML。JSX事件get <strong class="je ig">自动将</strong>委托给<strong class="je ig">根React节点</strong>。实际上，它更进一步。它在根节点上设置了一个<strong class="je ig">单一事件处理程序</strong>，处理<strong class="je ig">你的所有事件。</strong>这是什么意思？通常，当您将事件侦听器直接附加到用户与之交互的元素时，最终可能会在内存中为单个页面存储许多事件侦听器。React会自动创建一个监听器，这样你就再也不用考虑事件委托了。这对于像无限滚动这样的事情来说真的很棒，因为你不必担心无限增长的内存消耗(内存泄漏)。</li><li id="7201" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">将HTML和JS保存在同一个文件中有一个很大的优势，你可以看到一个单独的组件，你可以看到它将如何呈现，它将如何表现以及它的样式，这是<strong class="je ig">关注点分离</strong>做得对。</li></ol><h1 id="a8a1" class="lg ky if bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">单向数据流</h1><p id="9449" class="pw-post-body-paragraph jc jd if je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">数据绑定对于小例子非常有效。然而，随着应用程序的增长，你可能会面临这些问题。</p><h2 id="d0d7" class="kx ky if bd lh mj mk ml ll mm mn mo lp jn mp mq lt jr mr ms lx jv mt mu mb mv dt translated">声明依赖关系会很快引入循环</h2><p id="dffb" class="pw-post-body-paragraph jc jd if je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">最常见的问题是不得不应对你状态变化的副作用</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mw"><img src="../Images/ae08a9963f5b23832d9b7efa5c0775fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6Nl0Kpo50qBe-675YypMA.png"/></div></div><figcaption class="mx my fg fe ff mz na bd b be z ek">The mess MVC creates</figcaption></figure><p id="9367" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个场景中，<strong class="je ig">你能预测当<em class="mi">一个</em>变化发生在<em class="mi">单个</em>模型上时</strong>会发生什么变化吗？当任何依赖关系改变时，很难<strong class="je ig"/>推理出可以完全任意顺序执行的代码。</p><p id="c7bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">视图的作用是什么？将数据呈现给用户。视图模型的作用是什么？将数据呈现给用户。有什么区别？没有！</p><blockquote class="nb nc nd"><p id="a2a8" class="jc jd mi je b jf jg jh ji jj jk jl jm ne jo jp jq nf js jt ju ng jw jx jy jz hn dt translated"><em class="if">模板分离技术，而不是关注点~皮特·亨特</em></p></blockquote><p id="47a4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这正是我每天在工作中面临的问题，我们的整个web应用程序都是用Angular 1.x编写的，这个问题的解决方案需要我们，</p><h1 id="605e" class="lg ky if bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">虚拟DOM</h1><p id="5731" class="pw-post-body-paragraph jc jd if je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">这大概就是为什么大部分开发者如此被吸引反应的原因。React在内存中管理自己的DOM。大多数web应用程序遭受的最昂贵的操作是改变DOM。React的方法是维护DOM的虚拟表示，这允许它计算DOM中的差异，以便它只改变DOM中实际需要更新的部分。这是一个巨大的好处！</p><p id="ead0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React可以区分两个DOM树，并发现它需要执行的最小操作集。这意味着两件事:</p><ol class=""><li id="e985" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">如果带有文本的输入被重新呈现，并且React期望它具有该内容，那么它<strong class="je ig">不会接触</strong>该输入。不再有国家损失！</li><li id="cf29" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">区分虚拟DOM一点也不昂贵，所以我们可以随心所欲地区分它。当它准备好真正改变DOM时，它将只执行最少的操作。不再有缓慢的布局抖动！</li></ol><p id="3307" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于不知道Angular如何发生这种情况的人，让我告诉你，</p><p id="76b6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Digest cycle是Angular中数据绑定的魔酱，它的工作方式是这样的，</p><p id="e1ec" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当浏览器事件或某个AJAX请求(可能有很多情况下会被调用)触发digest cycle时，所有绑定到view或任何其他watches或任何附加到scope(另一个角度术语)的函数的变量都将被重新评估，不仅针对该组件，还针对整个应用程序(是的！！)</p><p id="5a2f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总之，它导致了太多的函数调用和DOM操作，从而转化为神经过敏的体验。(如果你有一个对棱角和前端很有经验的人，那么只有你能逃脱这个)。</p><p id="c8f8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，如果你用React消化循环的话所有的问题噗<strong class="je ig">没了</strong>！</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/3881fa5ac06d588de91094ff35162fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*rj6d7AuCGp8O0S1FzJ--8g.gif"/></div></figure><h1 id="6884" class="lg ky if bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">流量</h1><p id="7028" class="pw-post-body-paragraph jc jd if je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">Flux是脸书的<strong class="je ig">模式</strong>，用于关注单向数据流的React应用。通量的基本概念是一切都朝一个方向发生。动作的结果是数据流入。动作触发存储(数据模型)更新，然后触发change事件，导致React视图在需要时更新。随着应用程序中数据的变化，这种循环会不断重复。</p><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/6001628e1fda0be10b81efd8f601ff63.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*V2v0rwfGi3B_pZPw2lrtyQ.jpeg"/></div></figure><p id="095c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">优势:</p><ol class=""><li id="a2b2" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">存储和动作只是纯粹的函数。它们很容易单独测试。</li><li id="85ba" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">轻松交易。调度程序拥有状态，<strong class="je ig">有权将应用程序恢复到任何先前的状态</strong>，而无需程序员实现类似<em class="mi"> serialize() </em>或<em class="mi"> deserialize() </em>的东西。这与热重装相结合，使<a class="ae lf" href="https://github.com/gaearon/redux-devtools" rel="noopener ugc nofollow" target="_blank">非常强大的开发工具</a></li><li id="b654" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki dt translated">您可以在商店级别订阅更改，但是<strong class="je ig">dispatcher也可以为需要更细粒度更新的高级用户提供类似光标的功能</strong>。</li></ol><p id="22eb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在React中维护状态不仅简单，而且更有效，可读性更好，至于如何在Angular中做同样的事情，我花了一段时间才弄明白，它仍然没有这样有效。</p><h1 id="715f" class="lg ky if bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc dt translated">函数式编程</h1><p id="49b7" class="pw-post-body-paragraph jc jd if je b jf md jh ji jj me jl jm jn mf jp jq jr mg jt ju jv mh jx jy jz hn dt translated">作为一名程序员，我应该知道函数式编程非常有用，尽管我仍然怀疑函数式编程在后端/API上的可用性，但在前端，我可以这么说</p><blockquote class="nj"><p id="7ad1" class="nk nl if bd nm nn no np nq nr ns jz ek translated">“我遇到的50%的问题都是因为没有使用纯函数或变异状态”</p></blockquote><p id="1c37" class="pw-post-body-paragraph jc jd if je b jf nt jh ji jj nu jl jm jn nv jp jq jr nw jt ju jv nx jx jy jz hn dt translated">优点是:</p><ul class=""><li id="28ce" class="ka kb if je b jf jg jj jk jn kc jr kd jv ke jz ny kg kh ki dt translated">通过应用程序简化数据流。</li><li id="2fb1" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz ny kg kh ki dt translated">删除了对数据的防御性复制的要求。</li><li id="f7f3" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz ny kg kh ki dt translated">通过数据变化检测进行优化。</li><li id="7f75" class="ka kb if je b jf kj jj kk jn kl jr km jv kn jz ny kg kh ki dt translated">通过<a class="ae lf" href="https://wiki.haskell.org/Memoization" rel="noopener ugc nofollow" target="_blank">记忆增强性能</a></li></ul><p id="2f35" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么为什么有些人害怕不变性呢？</p><p id="93d4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为他们认为总是创造一个新的国家是缓慢的<strong class="je ig">但是</strong>他们不知道的是</p><blockquote class="nb nc nd"><p id="27f4" class="jc jd mi je b jf jg jh ji jj jk jl jm ne jo jp jq nf js jt ju ng jw jx jy jz hn dt translated">为了避免昂贵的克隆，只存储与先前数据结构的差异，而交集在它们之间共享。这种策略被称为结构共享。</p></blockquote><p id="9648" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更多信息请点击<a class="ae lf" href="https://www.youtube.com/watch?v=I7IdS-PbEgI" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="442d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">TLDR；</strong></p><p id="a7fe" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我和Angular度过的时光很美好，但那不会回来了，虽然我会在工作中继续Angular，但那只是因为我不喜欢重写，否则我就不干了。React及其引入的方法学起初听起来可能很可怕(非常规)，但它是值得的，因为React方法提供的优势很难忽视，如果你正在从一些新的东西开始，让2016年过去，使用<a class="ae lf" href="https://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwivgrvQqubQAhXJU7wKHXivDn0QFggmMAA&amp;url=https%3A%2F%2Ffacebook.github.io%2Freact%2F&amp;usg=AFQjCNHa_1d2VQ9XLEwLkZFQYYmqt39aoQ" rel="noopener ugc nofollow" target="_blank"> React </a>。</p><p id="5815" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">觉得这个帖子有用？请点击下面的❤按钮！:)</strong></p><p id="7be9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">干杯，</p><p id="a7dd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">沙希瓦特·巴特，</p><p id="f42e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">软件工程。<a class="ae lf" href="https://gridle.io" rel="noopener ugc nofollow" target="_blank">网格</a></p><div class="ko kp kq kr fq ab cb"><figure class="nz hw oa ob oc od oe paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nz hw oa ob oc od oe paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nz hw oa ob oc od oe paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="jc jd mi je b jf jg jh ji jj jk jl jm ne jo jp jq nf js jt ju ng jw jx jy jz hn dt translated"><a class="ae lf" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae lf" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lf" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>的机会。</p><p id="708a" class="jc jd mi je b jf jg jh ji jj jk jl jm ne jo jp jq nf js jt ju ng jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lf" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lf" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ko kp kq kr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff of"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ko kp kq kr fq hw"><div class="bz el l di"><div class="og le l"/></div></figure></div></div>    
</body>
</html>