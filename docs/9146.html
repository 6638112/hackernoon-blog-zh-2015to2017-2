<html>
<head>
<title>A Space Themed Intro to Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang的空间主题介绍</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/golang-the-highest-paying-technology-to-know-9c6089d7081d?source=collection_archive---------5-----------------------#2017-12-28">https://medium.com/hackernoon/golang-the-highest-paying-technology-to-know-9c6089d7081d?source=collection_archive---------5-----------------------#2017-12-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="46aa" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">一篇关于Golang的短文，目标读者是新开发人员或那些没有花太多时间研究这种语言的人，他们想要一个简短、简洁、经过深思熟虑的原创介绍。所有编写的代码都在repl中。</p></blockquote><p id="1b3c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">Go非常酷，更酷的是，根据Stack Overflows 2017数据集，它是报酬最高的技术。Go开发者的平均年薪是~ <strong class="ix hv"> 11万</strong> : <a class="ae jw" href="https://insights.stackoverflow.com/survey/2017" rel="noopener ugc nofollow" target="_blank">链接在这里！</a></p><p id="204e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">(技术-&gt;侧栏上用于验证的顶级付费技术)</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/83200250245b219269ddb297880e04f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7Jb0bgW3wwTRqPo9adQ-Q.jpeg"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">Hot damn!</figcaption></figure><p id="a6ab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">但是，这只是学习围棋的一部分原因。主要原因是这样的:<em class="iw">学习它只会加快你对基础计算机科学主题的理解。</em>为什么？嗯，<a class="ae jw" href="https://hackernoon.com/tagged/golang" rel="noopener ugc nofollow" target="_blank"> Golang </a>是一种经过深思熟虑的现代语言，它利用了在它之前创建的<a class="ae jw" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言的许多最佳实践。</p><p id="d98a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">它也是一种由谷歌开发的语言，用来处理大量的数据和与处理几乎每个人都使用的搜索引擎相关的问题。</p><p id="ecd7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">另一方面，要完全学会围棋，就要学会如何构建软件，为低级问题提供答案。另一种说法是为其他软件提供服务的软件。<em class="iw">在某种程度上，如果你了解Golang，那么你就知道如何构建触及该领域根本的程序。</em></p><p id="c5dd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">让我们深入研究一些代码。故事是这样开始的:</p><blockquote class="kn"><p id="c698" class="ko kp hu bd kq kr ks kt ku kv kw js ek translated">这一次是在2018年。但是时间突然跳到了240年前。好像你一直是奥斯汀·鲍尔斯。这取决于你突然拯救宇宙。结尾有点曲折。</p></blockquote><p id="8f7a" class="pw-post-body-paragraph iu iv hu ix b iy kx ja jb jc ky je jf jt kz ji jj ju la jm jn jv lb jq jr js hn dt translated">我写了一段代码，大约150行，完整地讲述了这个非常短的故事(大量打印)，我将把它放在最后。我将从头到尾检查一遍代码。开始很简单，然后变得有点复杂。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="f73d" class="lh li hu ld b fv lj lk l ll lm">package main</span><span id="03d3" class="lh li hu ld b fv ln lk l ll lm">import (<br/> "fmt"<br/> "time"<br/> "strconv"<br/> "io"<br/> "strings"<br/>)</span></pre><p id="fe39" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">包主</strong>？所有Go源代码都是包的一部分，每个文件都需要一个package语句。<code class="eh lo lp lq ld b">package main</code>是代码运行的文件。其他程序包文件是导入到主程序包中的模块。模块是可重用的代码片段，可以在<code class="eh lo lp lq ld b">package main</code>中使用或实现。</p><p id="b8b2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因此，导入的模块包含我将在这个文件中使用的源代码。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="60d5" class="lh li hu ld b fv lj lk l ll lm">type Aliens struct {<br/>  species int<br/>}</span><span id="f227" class="lh li hu ld b fv ln lk l ll lm">type NotEarthling struct {<br/>  total int<br/>  century string<br/>  thingamajig string<br/>}</span><span id="11e5" class="lh li hu ld b fv ln lk l ll lm">type Earthling struct {<br/>  total int<br/>  century string<br/>  name string<br/>  age int64<br/>}</span><span id="cce2" class="lh li hu ld b fv ln lk l ll lm">type WordSpaceship struct {<br/>  health string<br/>  weapon string<br/>}</span><span id="3ecf" class="lh li hu ld b fv ln lk l ll lm">type NumberSpaceship struct {<br/>  health int<br/>  weapon int<br/>}</span></pre><p id="9faf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">具有不同用法的多个结构。</p><p id="8b2c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">什么是结构？这是如何创建一个对象，可以有不同类型的每个值。关键是写的字，一串。尽管每个键必须有指定的类型，但它不是动态的。</p><p id="2bd9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">创建对象的另一个主要方法是使用<strong class="ix hv">地图</strong>。但是，在这种情况下，每个键以及值都必须是单一类型:</p><ul class=""><li id="a434" class="lr ls hu ix b iy iz jc jd jt lt ju lu jv lv js lw lx ly lz dt translated"><strong class="ix hv"> make(map[string]int) </strong>所有键都必须是string，所有值都必须是int</li></ul><p id="8fb9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">因此，在映射中，每个键必须是一种类型，每个值必须是一种类型。在结构中，每个值允许不同的类型。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="17c1" class="lh li hu ld b fv lj lk l ll lm">var you = Earthling{century: "21st", name: "you", age: 24}</span><span id="bd62" class="lh li hu ld b fv ln lk l ll lm">func main() {<br/>    defer fmt.Println("Is this all a dream?")</span><span id="a670" class="lh li hu ld b fv ln lk l ll lm">    now := time.Now()<br/>    nanos := now.UnixNano()<br/>    fmt.Printf("Right now it is: %v! \nPop! AHHHHH\n\n", now)</span></pre><p id="7f1a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">变量声明</strong>出现在全局范围内，所以必须用<code class="eh lo lp lq ld b">var</code>关键字初始化。这是<em class="iw">初始化结构的一种方式</em>。请注意，我指定了键，并将其值设置为结构定义中编写的相应类型。注意我没有初始化每个键/值(你不需要)。</p><p id="6b04" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">延期</strong>？这创建了一个后进先出的函数调用堆栈，在完成<code class="eh lo lp lq ld b">func main() {...}</code>的之后调用<em class="iw">。我说像<code class="eh lo lp lq ld b">defer</code>这样的堆栈可以被多次调用，每次调用时，最后一个推入堆栈的函数会被首先调用。</em></p><p id="7d56" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> :=，这是什么？</strong>这就是说类型会被编译器动态的计算出来。就像在中一样，当以这种方式初始化变量的值时，您不需要指定类型，这是唯一的方法。</p><p id="75f2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">时间。Now() </strong>返回此值:2017–12–28 01:41:05.240081928+0000 UTC</p><p id="69f7" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">现在。UnixNano() </strong>返回这个:1514425756675856179，这是自8年前创建Golang以来发生的纳秒量。</p><p id="4e02" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> Printf </strong>允许以不同的形式记录数值:</p><p id="c6e1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> %v </strong>给出默认值</p><p id="c231" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> %T </strong>给出数值的类型</p><p id="98c8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">是两种主要的形式。</p><p id="98ab" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">还是在下面的函数main里。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="03be" class="lh li hu ld b fv lj lk l ll lm">    nanos = nanos + 7600000000000000000<br/> <br/>    years := (nanos - now.UnixNano())/1000000000/31622400<br/> <br/>    now = time.Unix(0, nanos)</span><span id="7acb" class="lh li hu ld b fv ln lk l ll lm">    fmt.Printf("And now it is: %v!\nOh hell!\n\n", now)</span></pre><p id="3135" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">开始时，一个人走了76000000000000000纳秒，来到未来，也就是大约240年。</p><p id="9616" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">年</strong>是一种计算，先换算成秒再换算成年。</p><p id="bacc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv">时间。Unix(秒，毫微秒)</strong>会将纳秒转换为:2258–10–29 00:55:56.675856179+0000 UTC</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="8797" class="lh li hu ld b fv lj lk l ll lm">    var e []Earthling<br/>    var ne []NotEarthling</span><span id="a14a" class="lh li hu ld b fv ln lk l ll lm">    for i := 0; i &lt; 70000; i++ {<br/>        e = append(e, Earthling{})<br/>    }<br/>  <br/>    for i := 0; i &lt; 44; i++ {<br/>        ne = append(ne, NotEarthling{})<br/>    }<br/>  <br/>    aliens := Aliens{2}</span><span id="e2ee" class="lh li hu ld b fv ln lk l ll lm">    futureEarthling := Earthling{len(e), "22nd", "The Future", 32141}<br/>  <br/>    futureNotEarthling := NotEarthling{len(ne), "99th", "Grok grok grok"}</span></pre><p id="41b1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> var </strong>关键字调用设置一个<em class="iw">零值</em>数组(空数组)，该数组只能用指定的类型填充。不能添加整数、字符串等。到这个数组。</p><p id="1857" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在下面的<strong class="ix hv"> for循环</strong>中，我<em class="iw">将指定类型的空结构</em>追加到数组中。</p><p id="006c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这种情况下只有两种外来物种。<strong class="ix hv">地球人</strong>和<strong class="ix hv">非地球人</strong>。</p><p id="2011" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">注意，<strong class="ix hv"> futureEarthling </strong>是如何被设置为struct <strong class="ix hv"> Earthlings </strong>而没有指定键的，这是一个简写，只要你按照struct中定义的相应顺序放置值，在这个例子中:<strong class="ix hv"> {int，string，string，int64} </strong>，那么字段就可以这样填写。</p><p id="ebd8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">现在有一个名为<strong class="ix hv"> Greet </strong>的函数附加到每个<strong class="ix hv">earthing</strong>对象上…让我们来看看这个独立的函数，而不是主函数。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="cf5b" class="lh li hu ld b fv lj lk l ll lm">func (e *Earthling) Greet(y int64) string {</span><span id="f956" class="lh li hu ld b fv ln lk l ll lm">    century, _ := strconv.ParseInt(e.century[0:2], 0, 64)</span><span id="8efe" class="lh li hu ld b fv ln lk l ll lm">    if century &gt; 21 &amp;&amp; century &lt; 30 {</span><span id="9fa3" class="lh li hu ld b fv ln lk l ll lm">      age := strconv.FormatInt(you.age, 10)</span><span id="7f9e" class="lh li hu ld b fv ln lk l ll lm">      str := "Welcome to the future young Padawan, you are in the: " + e.century + " century. And I am: " + e.name + ". You are now... " + age + "years old. The world is under attack, and you have been revived to defend it! Big scary invader has something to say..."</span><span id="43f5" class="lh li hu ld b fv ln lk l ll lm">      return str</span><span id="f06e" class="lh li hu ld b fv ln lk l ll lm">    } else {<br/>      e.age = e.age + y<br/>      return "Where am I???"<br/>    }<br/>}</span></pre><p id="b315" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">好的，这对应于这个人正在经历的存在主义危机，在遥远的未来醒来，某个随机的未来人有话要说！</p><p id="40fe" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">嗯……看上面:<strong class="ix hv"> (e *Earthling) </strong>。这是什么？嗯，<strong class="ix hv"> e </strong>将成为调用该方法的<strong class="ix hv"> Earthling </strong>对象的实例。还有那个<strong class="ix hv"> * </strong>？<em class="iw">这是一个指针</em>。我邀请你打开下面的repl，删除那个<strong class="ix hv"> * </strong>，看看会发生什么。</p><p id="ef1d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">意思是这样的:<strong class="ix hv">你。Greet(year) </strong> <em class="iw">正在创建</em> <code class="eh lo lp lq ld b"><em class="iw">you</em></code> <em class="iw">的副本，除非你指向它的内存地址</em>。如果不这样做，你在<code class="eh lo lp lq ld b">you</code>上做的任何事情都不会改变主函数中的对象。指针确保对象可以被改变。</p><p id="74fe" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在这个代码片段中，我们还有一个新的库… <strong class="ix hv"> strconv </strong>。当你想把一个整型数转换成一个字符串，反之亦然，或者许多其他类型时，可以使用这个库。Go有如此多的数据类型… int，int8，int16，int32，int64。我命名的是int，换句话说，你可以一直输入下去。</p><p id="4fb0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你仔细观察，我使用指针的全部原因是为了改变年轻学徒的年龄。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="e9cc" class="lh li hu ld b fv lj lk l ll lm">numberShip := NumberSpaceship{100, 3}<br/>wordShip := WordSpaceship{"Read this to defeat me.", "Powerful words!"}<br/>  <br/>wordAttack := make(chan int)<br/>finished := make(chan int)</span><span id="69d0" class="lh li hu ld b fv ln lk l ll lm">go func() {<br/>    for {<br/>        numberShip.health = numberShip.health - &lt;-wordAttack<br/>        if numberShip.health &lt;= 0 {<br/>            Extinction(&amp;aliens)<br/>            finished &lt;- 0<br/>        }<br/>    }<br/>}()<br/> <br/>fmt.Println(Fight(&amp;numberShip, &amp;wordShip, wordAttack, finished))</span></pre><p id="1586" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">好的，首先，两个结构体的第一个参数是它们的健康状况。所以，对于数字船来说健康是100，而对于单词船来说健康是一句话……<code class="eh lo lp lq ld b">"Read this to defeat me"</code>……？我将在底部的函数中深入讨论这个问题，<strong class="ix hv">对抗</strong>，它使用的是所谓的<strong class="ix hv">阅读器</strong>。</p><p id="3146" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> make(chan int) </strong>创建所谓的通道。发送/接收值的管道。发送是这样:<strong class="ix hv">&lt;-文字攻击</strong>，接收是:<strong class="ix hv">完成&lt; - 0 </strong>。</p><p id="8889" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated"><strong class="ix hv"> go func() {…}() </strong>是一个<em class="iw"> goroutine的创造。</em>当协调使用通道和goroutine时，要记住的主要事情是，只要通道向go routine发送值，它就会继续<em class="iw">。</em>那么，让我们看看它是从哪里得到它的值的，<strong class="ix hv"> Fight </strong>函数。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="0336" class="lh li hu ld b fv lj lk l ll lm">func Fight(ns *NumberSpaceship, ws *WordSpaceship, c, f chan int) string {<br/>    x := len(ws.weapon)<br/>    r := strings.NewReader(ws.health)<br/>    b := make([]byte, ns.weapon)<br/>    for {<br/>        select {<br/>            case c &lt;- x:<br/>                fmt.Println("Hit it!")<br/>            case &lt;-f:<br/>                fmt.Println("He's finished!")<br/>                return "\nYou saved time, space, eternity, everything!\n"<br/>        }<br/>        _, err := r.Read(b)<br/>        if err == io.EOF {<br/>            return "You failed, the universe is to end."<br/>        }<br/>    }<br/>}</span></pre><p id="bf0d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先，检查函数签名。此函数由<em class="iw">引用</em>变量的内存地址调用(与<strong class="ix hv"> &amp; </strong>)。在签名中，函数期望一个<em class="iw">指针</em>(即。一个<em class="iw">引用了</em>变量)作为<strong class="ix hv">数字空间</strong>和<strong class="ix hv">文字空间</strong>的参数。</p><p id="f307" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">此外，检查如何两个<strong class="ix hv">陈ints </strong>类型只写一次。如果参数类型彼此相邻并且类型完全相同，则可以对它们进行分组。</p><p id="3f25" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">首先是<strong class="ix hv">字符串</strong>库，这“实现了简单的函数来操作UTF-8编码的字符串”在这个函数中，将创建一个<em class="iw">阅读器</em>来读取一个字符串。</p><p id="d35d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">好了，字符串阅读器的实现:</p><ul class=""><li id="0e18" class="lr ls hu ix b iy iz jc jd jt lt ju lu jv lv js lw lx ly lz dt translated">r :=字符串。NewReader(ws.health) 返回一个新的<em class="iw">阅读器</em>，它将从s: <code class="eh lo lp lq ld b">"Read this to defeat me"</code>中读取数据。</li><li id="4b05" class="lr ls hu ix b iy ma jc mb jt mc ju md jv me js lw lx ly lz dt translated"><strong class="ix hv"> b := make([]byte，ns.weapon) </strong>返回指定长度的字节片。<strong class="ix hv"> ws.weapon </strong>是数值3。</li><li id="5a45" class="lr ls hu ix b iy ma jc mb jt mc ju md jv me js lw lx ly lz dt translated"><strong class="ix hv"> _，err := r.Read(b) </strong>更细致入微。<strong class="ix hv"> _ </strong>也可以是变量名，姑且称之为<strong class="ix hv"> n </strong>。如果<strong class="ix hv"> n </strong>存在，意味着<strong class="ix hv"> Read </strong>读取的字节数要返回给<strong class="ix hv"> n </strong>。但是如果保持原样，则不必使用返回值。否则，你必须这么做，也就是说<em class="iw"> Go不允许不使用声明的变量。</em>因此，首先，<strong class="ix hv"> Read </strong>返回读取的字节数，其次，当且仅当整个字符串被读取时，它返回一个错误，在这种情况下是一个<strong class="ix hv"> io。返回EOF </strong>(文件结束)错误。否则，它的值为:<strong class="ix hv"> &lt; nil &gt; </strong>。</li><li id="fab1" class="lr ls hu ix b iy ma jc mb jt mc ju md jv me js lw lx ly lz dt translated">所以，<strong class="ix hv"> r </strong>就是读者。<strong class="ix hv"> b </strong>是字符串的读数被放入的内容。<strong class="ix hv">读作</strong>是被调用来使之发生的函数。</li></ul><p id="ae4f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">所以，总结一下<strong class="ix hv">阅读器</strong>以及它被使用的原因，一旦字符串被读取，NumberSpaceship 获胜，而WordSpaceship】失败。非常激烈的战斗。</p><p id="9065" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一个快速的旁注:{…} 的<strong class="ix hv">就是说，做一个无限循环，直到函数返回。</strong></p><p id="779d" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">至于对<strong class="ix hv">号飞船</strong>的攻击。</p><ul class=""><li id="484a" class="lr ls hu ix b iy iz jc jd jt lt ju lu jv lv js lw lx ly lz dt translated"><strong class="ix hv">选择</strong>正在等待多个通信操作，两个通道<strong class="ix hv"> c </strong>和<strong class="ix hv"> f </strong>。当准备好发送或接收数据时，只要函数不返回，它就会继续发送或接收数据。</li><li id="1f70" class="lr ls hu ix b iy ma jc mb jt mc ju md jv me js lw lx ly lz dt translated"><strong class="ix hv">情况&lt; - x </strong>就是说，不断的向这个通道发送x的值。然后，回到<strong class="ix hv"> func main </strong>的goroutine，这样做:<strong class="ix hv">number ship . health = number ship . health—&lt;-word attack</strong>对船造成伤害。因此，通道清空了它刚刚接收到的x。<em class="iw">通道接收一个值，并在相应的goroutine中将其发送出去</em></li><li id="f3f3" class="lr ls hu ix b iy ma jc mb jt mc ju md jv me js lw lx ly lz dt translated"><strong class="ix hv"> case &lt; - f </strong>仅在f有相关值时运行，并且这仅发生在if语句后的<strong class="ix hv">main</strong>:<strong class="ix hv">finished&lt;-0</strong>中。</li></ul><p id="82d6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这就是战斗！战斗结束后，无论谁输了，他们的整个物种都灭绝了…这是怎么写的，逻辑并没有结合到真正的代码中。</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="3d27" class="lh li hu ld b fv lj lk l ll lm">type Aliens struct {<br/>    species int<br/>}</span><span id="feec" class="lh li hu ld b fv ln lk l ll lm">func Extinction(a *Aliens) {<br/>    a.species = a.species - 1<br/>}</span><span id="87b8" class="lh li hu ld b fv ln lk l ll lm">func main() {<br/>    aliens := Aliens{2}<br/>    Extinction(&amp;aliens)<br/>}</span></pre><p id="c13b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">很强的逻辑性。</p><p id="e4e6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">以及从真实代码中注销的全部内容！</p><pre class="jy jz ka kb fq lc ld le lf aw lg dt"><span id="c950" class="lh li hu ld b fv lj lk l ll lm">Right now it is: 2017-12-28 21:40:35.066259304 +0000 UTC! <br/>Pop! AHHHHH<br/><br/>And now it is: 2258-10-29 20:47:15.066259304 +0000 UTC!<br/>Oh hell!<br/><br/>Where am I??? <br/><br/>Welcome to the future young Padawan, you are in the: 22nd century. And I am: The Future. You are now... 264 years old. The Universe is under attack, and you have been revived to defend it! Big scary invader has something to say... <br/><br/>Tord thaz geck hild quemp 240! <br/><br/>He challenged you! You're the chosen one, so you must save the Universe! Jump on this spaceship.<br/><br/>VRRRROOOOOOOOOOOOMMMMMMMM BOOM BOP BOOM BOP<br/><br/>Hit it!<br/>Hit it!<br/>Hit it!<br/>Hit it!<br/>Hit it!<br/>Hit it!<br/>Hit it!<br/>He's finished!<br/><br/>You saved time, space, eternity, everything!<br/><br/>AHHH, the aliens left a bomb, the Universe is to disintegrate into nothingness!<br/><br/>Some higher being sort of thing says: There are  0  sentient beings left alive.<br/><br/>Was that all a dream?</span></pre><p id="32d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">和回复:</p><div class="mf mg fm fo mh mi"><a href="https://repl.it/@jerrymuzsik/GolangArticleFrozenSpaceGuy" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab ej"><div class="mk ab ml cl cj mm"><h2 class="bd hv fv z el mn eo ep mo er et ht dt translated">@jerrymuzsik的repl . it-golangarticlefrozenspace guy</h2><div class="mp l"><h3 class="bd b fv z el mn eo ep mo er et ek translated">强大而简单的在线编译器，IDE，解释器和REPL。用JavaScript、Python…编写、编译和运行代码</h3></div><div class="mq l"><p class="bd b gc z el mn eo ep mo er et ek translated">回复它</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw kh mi"/></div></div></a></div><p id="b3e1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你有兴趣学习更多的围棋，伟大的入门文档/练习题，我强烈推荐这本书！</p><div class="mf mg fm fo mh mi"><a href="https://tour.golang.org/welcome/1" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab ej"><div class="mk ab ml cl cj mm"><h2 class="bd hv fv z el mn eo ep mo er et ht dt translated">围棋之旅</h2><div class="mq l"><p class="bd b gc z el mn eo ep mo er et ek translated">tour.golang.org</p></div></div></div></a></div><blockquote class="ir is it"><p id="8b81" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">非常感谢！你是最棒的！Golang先生也有话要说。</p></blockquote><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mx"><img src="../Images/d4efc59c214bec94c296c70c8f8f62ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmggWfHAc6_fXW64llUBKw.jpeg"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">I thanky thee muchee for readee thisee thingee, cheerees mee buddy</figcaption></figure><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="my mz l"/></div></figure></div></div>    
</body>
</html>