<html>
<head>
<title>Using Channels as Futures in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中使用渠道作为未来</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-channels-as-futures-in-golang-e085c4adbc04?source=collection_archive---------4-----------------------#2017-02-12">https://medium.com/hackernoon/using-channels-as-futures-in-golang-e085c4adbc04?source=collection_archive---------4-----------------------#2017-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="401f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近，我在Go中的<a class="ae jp" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> AWS ECS </a>之上构建了一个轻量级任务调度器。该应用程序通过AWS ECS(一个构建在EC2和Docker之上的orchestrator)将带有自定义参数和调度的批处理作业作为单个容器进行调度。调度器的一个关键需求是监控正在运行的任务的状态。为此，我选择使用AWS ECS的<a class="ae jp" href="http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTasks.html" rel="noopener ugc nofollow" target="_blank"> DescribeTasks </a>端点，它获取ECS任务ID并返回它们的状态、完成时的退出代码、停止的原因等。</p><p id="ae4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于速率限制，我不得不批处理API调用。最初，我认为我的代码应该是这样的—</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="b378" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">似乎很合理，对吧？调度程序只需创建一个监视器，通过<code class="eh jx jy jz ka b">Watch</code>提交任务，并轮询<code class="eh jx jy jz ka b">GetStatus</code>直到目标任务完成。</p><p id="e610" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">…算是吧。<code class="eh jx jy jz ka b">GetStatus</code>的第一个问题是调度程序必须知道监视器是批处理的，因为它返回所有任务的状态图。在API中公开实现细节通常是抽象漏洞的标志。</p><p id="8b47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">举第二个例子—</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="4bc0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">太好了！现在，<code class="eh jx jy jz ka b">GetStatus</code>返回给定任务的状态。虽然只是一些额外的字符，但这是一个巨大的可用性改进，因为调度程序不再需要批处理任务。</p><p id="815d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这段代码仍然存在一个问题。调度应该什么时候调用<code class="eh jx jy jz ka b">GetStatus</code>？当然是循环了！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="b0e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是可行的，但是它并不优雅，对于更昂贵的操作来说也不够理想。我们可以做得更好。</p><p id="1aef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你从JavaScript、Scala、C#或其他有前途的语言开始，你可能会想“这些怎么翻译成Go？”。好吧，围棋本身没有“期货”，但它也不需要<em class="kb">它们，因为渠道是如此强大。让我们来看一看！</em></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="e14e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kb">嘣！</em>这是一种美丽、高效、简单的方式。<em class="kb">监视器。Watch(task) </em>返回一个可“等待”的通道。</p><p id="e5bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在围棋中用渠道作为<a class="ae jp" href="https://hackernoon.com/tagged/futures" rel="noopener ugc nofollow" target="_blank">期货</a>并不完美。首先，不可能在它们周围创建一个像<a class="ae jp" href="http://bluebirdjs.com/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">蓝鸟</a>那样的带有帮助函数的库，例如，由于Go缺乏泛型。此外，为每个<a class="ae jp" href="https://hackernoon.com/tagged/function" rel="noopener ugc nofollow" target="_blank">函数</a>调用创建一个通道并不节省空间，因为每个通道都有自己的互斥体、缓冲区等。因此，如果您正在处理性能密集型应用程序中的大量调用，这不是正确的决定。在这些情况下，您应该使用单一通道和阅读器，例如</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="5ace" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">…但这带来了更多的间接性，所以尽可能(大多数用例)尝试将通道作为一个可读、直接的API的未来！</p></div><div class="ab cl kc kd hc ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hn ho hp hq hr"><p id="65e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你觉得这很有趣，可以考虑在Twitter上关注我，在那里我分享了我的围棋经验。</p><blockquote class="kj kk kl"><p id="c1ad" class="ir is kb it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kb it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上给我们点赞/发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kb it b iu iv iw ix iy iz ja jb km jd je jf kn jh ji jj ko jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kp jw l"/></div></figure></div></div>    
</body>
</html>