<html>
<head>
<title>reduce() — 10% faster with no start value.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">reduce() —速度提高10%，没有起始值。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reduce-faster-with-no-starting-value-3d697c9464f9?source=collection_archive---------13-----------------------#2017-07-14">https://medium.com/hackernoon/reduce-faster-with-no-starting-value-3d697c9464f9?source=collection_archive---------13-----------------------#2017-07-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/408d9a2a447ec639b34e17a1ae547c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MonzHfqI7c1k2lL2pwR5EQ.png"/></div></div></figure><div class=""/><p id="d031" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">围绕这个方法，我注意到如果你不给它一个起始值，它就从数组的第二个索引开始迭代。</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="6d6b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于第一次迭代，<code class="eh kg kh ki kj b">a</code>(累加器)被赋予<code class="eh kg kh ki kj b">array</code> : <code class="eh kg kh ki kj b">1</code>的第一个<code class="eh kg kh ki kj b">index</code>；<code class="eh kg kh ki kj b">b</code>(当前值)被赋予第二个<code class="eh kg kh ki kj b">index</code> : <code class="eh kg kh ki kj b">2</code>。因此，这个例子只有3次迭代。</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="63c7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是有道理的，首先你加上<code class="eh kg kh ki kj b">1+2</code>然后<code class="eh kg kh ki kj b">3+3</code>最后<code class="eh kg kh ki kj b">6+4</code>。</p><p id="635f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，如果你给reducer <code class="eh kg kh ki kj b">a</code>一个初始值，迭代将从第一个键开始，因此它将迭代4次:</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="ea5e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这激起了我的好奇心:我想知道迭代次数少的实现是否真的更快。我没有本机代码性能测试的经验。但是我决定使用一个我看到正在使用的<a class="ae kk" href="https://hackernoon.com/tagged/tool" rel="noopener ugc nofollow" target="_blank">工具</a>: JsPerf。</p><p id="f9f2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae kk" href="https://jsperf.com/array-reduce-with-start-value" rel="noopener ugc nofollow" target="_blank"> JsPerf </a>上，没有起始值的测试运行速度大约快10%(根据浏览器的不同有很大的差异)。这些结果是针对小型阵列的。</p><p id="0827" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用更大的阵列(比如10k个项目)测试相同的代码并没有显示出显著的差异。有几个操作每秒钟的差异，不是很多。这很可能是由于两种实现的调度(开始)时间不同。这种差异在多次迭代后变得不明显。纯粹假设如果调度时间也是2纳秒，每次迭代4纳秒，那么4次迭代2纳秒就代表2 / 4 * 4 + 2 ~11.11%。但是对于100次迭代，2 / 4 * 100 = 0.5 %</p><p id="1890" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，这种巨大的差异只对小数组有效。对于一个<code class="eh kg kh ki kj b">array.map(i =&gt; i.reduce())</code>来说，这可能很有趣，因为您知道每次缩减都将发生在一个小阵列上。</p><p id="05a8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是等等，<a class="ae kk" href="https://hackernoon.com/tagged/jsperf" rel="noopener ugc nofollow" target="_blank"> JsPerf </a>在浏览器上测试，node.js呢？惊喜，惊喜…反过来了。我写了一个小脚本来测试:</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="76c5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我测试了node.js的不同版本，计算了没有开始值的实现和有开始值的实现之间的时间增长百分比。负数表示具有起始值的变量实际上更快。我给了你最快和最慢的测试。我已经做了很多介于这两个数字之间的测试。</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="ke kf l"/></div></figure><p id="1a14" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以看到，在较小的阵列上，具有起始值的节点实际上更快，但是在较大的阵列上，没有起始值的实现更快，在节点8上，具有起始值的实现比其他实现快很多倍。</p><p id="ec45" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们这里说的是毫秒和毫微秒…例如，在节点8上表现最好的大阵列测试实际上要快大约<code class="eh kg kh ki kj b">0.076ms</code>…</p><p id="424d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些数字很小，我想这没有什么意义，除非你收到大量的请求。但这是一个有趣的实验。让我知道你的想法！</p><figure class="ka kb kc kd fq hw"><div class="bz el l di"><div class="kl kf l"/></div></figure></div></div>    
</body>
</html>