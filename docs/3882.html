<html>
<head>
<title>All you need to know about prefetching in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Django中的预取，您只需要知道</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/all-you-need-to-know-about-prefetching-in-django-f9068ebe1e60?source=collection_archive---------0-----------------------#2017-04-29">https://medium.com/hackernoon/all-you-need-to-know-about-prefetching-in-django-f9068ebe1e60?source=collection_archive---------0-----------------------#2017-04-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="2177" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了更好的阅读体验，请在我的网站上查看<a class="ae jw" href="https://hakibenita.com/all-you-need-to-know-about-prefetching-in-django" rel="noopener ugc nofollow" target="_blank">这篇文章。</a></p></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><p id="af83" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我最近在为一个会议开发一个订票系统。对于客户来说，查看订单表非常重要，其中包含一个列，其中列出了每个订单中的程序名称:</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/8eee715c75955b8f284e179b189132bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xu_3zwEwz8TV-BO9."/></div></div></figure><p id="4199" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">模型看起来(大致)是这样的:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="c176" class="ko kp hu kk b fv kq kr l ks kt">class <strong class="kk hv">Program</strong>(models.Model):<br/>    name = models.CharField(max_length=20)<br/></span><span id="2c56" class="ko kp hu kk b fv ku kr l ks kt">class <strong class="kk hv">Price</strong>(models.Model):<br/>    program = models.ForeignKey(Program)<br/>    from_date = models.DateTimeField()<br/>    to_date = models.DateTimeField()<br/></span><span id="450d" class="ko kp hu kk b fv ku kr l ks kt">class <strong class="kk hv">Order</strong>(models.Model):<br/>    state = models.CharField(max_length=20)<br/>    items = models.ManyToManyField(Price)</span></pre><ul class=""><li id="d8d2" class="kv kw hu ja b jb jc jf jg jj kx jn ky jr kz jv la lb lc ld dt translated"><strong class="ja hv">计划</strong>是一个会议、讲座或研讨会日。</li><li id="a478" class="kv kw hu ja b jb le jf lf jj lg jn lh jr li jv la lb lc ld dt translated">价格会随着时间的推移而变化，因此我们使用了一个名为<strong class="ja hv"> Price </strong>，<strong class="ja hv"> </strong>的模型，该模型被建模为一个<a class="ae jw" href="https://en.wikipedia.org/wiki/Slowly_changing_dimension#Type_2:_add_new_row" rel="noopener ugc nofollow" target="_blank"> type 2渐变维度</a> (SCD ),它表示某个时间某个节目的价格。</li><li id="76a5" class="kv kw hu ja b jb le jf lf jj lg jn lh jr li jv la lb lc ld dt translated">用户可以注册一个或多个程序。<strong class="ja hv">订单</strong>中的每一项都是订单生成时的计划价格。</li></ul><h1 id="fa1b" class="lj kp hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">开始之前</h1><p id="307a" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">在本文中，我们将监控Django执行的查询。要记录查询，将以下内容添加到<code class="eh ml mm mn kk b">settings.py</code>中的<code class="eh ml mm mn kk b">LOGGING</code>设置:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="ef31" class="ko kp hu kk b fv kq kr l ks kt">LOGGING = {<br/>    <br/>    ...   <br/>    <br/>    'loggers': {<br/><strong class="kk hv">        'django.db.backends': {<br/>            'level': 'DEBUG',<br/>        },</strong><br/>    },<br/>}</span></pre><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff mo"><img src="../Images/780dca2354d21a4f951e6e805430004d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2p7KTk1KzOHNuZ-td-9HA.jpeg"/></div></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Let’s see you trying to find an image related to prefetching…</figcaption></figure></div><div class="ab cl ir is hc it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hn ho hp hq hr"><h1 id="7c6c" class="lj kp hu bd lk ll mt ln lo lp mu lr ls lt mv lv lw lx mw lz ma mb mx md me mf dt translated">有什么问题？</h1><p id="fc3e" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">让我们尝试获取单个订单的程序名:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="35e1" class="ko kp hu kk b fv kq kr l ks kt">&gt; <strong class="kk hv">o = Order.objects.filter(state=’completed’).first()</strong></span><span id="73cb" class="ko kp hu kk b fv ku kr l ks kt">(0.002) SELECT … FROM “orders_order” WHERE “orders_order”.”state” = ‘completed’ ORDER BY “orders_order”.”id” ASC LIMIT 1;</span><span id="a7a1" class="ko kp hu kk b fv ku kr l ks kt">&gt; <strong class="kk hv">[p.program.name for p in o.items.all()]</strong></span><span id="44c1" class="ko kp hu kk b fv ku kr l ks kt">(0.002) SELECT … FROM “events_price” INNER JOIN “orders_order_items” ON (“events_price”.”id” = “orders_order_items”.”price_id”) WHERE “orders_order_items”.”order_id” = 29; args=(29,)</span><span id="d55c" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT … FROM “events_program” WHERE “events_program”.”id” = 8; args=(8,)</span><span id="0744" class="ko kp hu kk b fv ku kr l ks kt">[‘Day 1 Pass’]</span></pre><ul class=""><li id="4b83" class="kv kw hu ja b jb jc jf jg jj kx jn ky jr kz jv la lb lc ld dt translated">为了获取完成的订单，我们需要<strong class="ja hv">一个查询。</strong></li><li id="4e0f" class="kv kw hu ja b jb le jf lf jj lg jn lh jr li jv la lb lc ld dt translated">为了获取每个订单的程序名，我们需要再进行两次查询。</li></ul><p id="2e60" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我之前<a class="ae jw" rel="noopener" href="/@hakibenita/things-you-must-know-about-django-admin-as-your-app-gets-bigger-6be0b0ee9614">写过N+1问题</a>，这是一个经典案例。如果我们每个订单需要两个查询，<strong class="ja hv">100个订单的查询数将是1 + 100 * 2 = 201个查询——太多了！</strong></p><p id="7a0d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们使用Django来减少查询量:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="0371" class="ko kp hu kk b fv kq kr l ks kt">&gt; <strong class="kk hv">o.items.values_list(‘program__name’)</strong></span><span id="5b53" class="ko kp hu kk b fv ku kr l ks kt">(0.003) SELECT “events_program”.”name” FROM “events_price” INNER JOIN <strong class="kk hv">“orders_order_items”</strong> ON (“events_price”.”id” = “orders_order_items”.”price_id”) <strong class="kk hv">INNER JOIN</strong> <strong class="kk hv">“events_program”</strong> ON (“events_price”.”program_id” = “events_program”.”id”) WHERE “orders_order_items”.”order_id” = 29 LIMIT 21;</span><span id="5f54" class="ko kp hu kk b fv ku kr l ks kt">[‘Day 1 Pass’]</span></pre><p id="9279" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">太好了！Django在<code class="eh ml mm mn kk b">Price</code>和<code class="eh ml mm mn kk b">Program</code>之间执行了一个连接，并将查询数量减少到每个订单一个。</strong></p><p id="b275" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此时，对于100个订单，我们只需要101个查询，而不是201个查询。</p><p id="fa98" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们能做得更好吗？</p><h1 id="4e06" class="lj kp hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">为什么不能加入？</h1><p id="2ee9" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">应该想到的第一个问题是<em class="my">“为什么我们不能加入牌桌？”</em></p><p id="2739" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果我们有一个外键，我们可以使用<code class="eh ml mm mn kk b">select_related</code>或者像上面一样使用snake case在一个查询中获取相关字段。</p><p id="444e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，我们使用<code class="eh ml mm mn kk b"><strong class="ja hv">values_list(‘program__name’)</strong></code> <strong class="ja hv">在单个查询中获取价格列表的程序名。我们之所以能够做到这一点，是因为每个价格都与一个项目相关。</strong></p><p id="31a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果两个模型之间的关系是多对多，我们就不能这样做。每个订单都有一个或多个相关的价格—如果我们连接两个表，就会得到重复的订单:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="6651" class="ko kp hu kk b fv kq kr l ks kt">SELECT<br/>    o.id AS order_id,<br/>    p.id AS price_id<br/>FROM <br/>    orders_order o <br/>    JOIN orders_order_items op ON (o.id = op.order_id) <br/>    JOIN events_price p ON (op.price_id = p.id) <br/>ORDER BY <br/>    1,<br/>    2;</span><span id="d26c" class="ko kp hu kk b fv ku kr l ks kt"><strong class="kk hv">order_id</strong> | price_id <br/>----------+----------<br/>       <strong class="kk hv">45</strong> |       38<br/>       <strong class="kk hv">45</strong> |       56<br/>       <strong class="kk hv">70</strong> |       38<br/>       <strong class="kk hv">70</strong> |       50<br/>       <strong class="kk hv">70</strong> |       77<br/>       71 |       38</span></pre><p id="379e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">订单70和订单45有多个商品，所以它们在结果中出现不止一次— <strong class="ja hv"> Django无法处理这个问题。</strong></p><h1 id="ac2a" class="lj kp hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">输入预取相关</h1><p id="30d5" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">Django有一个很好的内置方法来处理这个问题，叫做<a class="ae jw" href="https://docs.djangoproject.com/en/1.10/ref/models/querysets/#prefetch-related" rel="noopener ugc nofollow" target="_blank"> prefetch_related </a>:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="74f3" class="ko kp hu kk b fv kq kr l ks kt">&gt; o = Order.objects.filter(<br/>    state='completed',<br/>)<strong class="kk hv">.prefetch_related(<br/>    'items__program',<br/>)</strong>.first()</span><span id="cbb0" class="ko kp hu kk b fv ku kr l ks kt">(0.002) SELECT ... FROM "orders_order" WHERE "orders_order"."state" = 'completed' ORDER BY "orders_order"."id" ASC LIMIT 1;</span><span id="dbd1" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT ("orders_order_items"."order_id") AS "_prefetch_related_val_order_id", "events_price"... FROM "events_price" INNER JOIN "orders_order_items" ON ("events_price"."id" = "orders_order_items"."price_id") WHERE "orders_order_items"."order_id" IN (29);</span><span id="4eba" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT "events_program"."id", "events_program"."name" FROM "events_program" WHERE "events_program"."id" IN (8);</span></pre><p id="dd39" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们告诉Django我们打算从结果集中获取<code class="eh ml mm mn kk b">items__program</code>。在第二个和第三个查询中，我们可以看到Django从<code class="eh ml mm mn kk b">events_program</code>获取了直通表<code class="eh ml mm mn kk b">orders_order_items</code>和相关程序。<strong class="ja hv">预取的结果缓存在对象上</strong>。</p><p id="08b7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当我们试图从结果中获取程序名时会发生什么？</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="8927" class="ko kp hu kk b fv kq kr l ks kt">&gt; <strong class="kk hv">[p.program.name for p in o.items.all()]</strong></span><span id="d614" class="ko kp hu kk b fv ku kr l ks kt">[‘Day 1 Pass’]</span></pre><p id="a20a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">没有额外的查询</strong> —这正是我们想要的！</p><p id="6255" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当使用预取时，重要的是<strong class="ja hv">处理对象而不是查询</strong>。尝试用一个查询获取程序名会产生相同的结果，但会导致一个额外的查询:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="4051" class="ko kp hu kk b fv kq kr l ks kt"><strong class="kk hv">&gt; o.items.values_list(‘program__name’)</strong></span><span id="6b79" class="ko kp hu kk b fv ku kr l ks kt">(0.002) SELECT “events_program”.”name” FROM “events_price” INNER JOIN “orders_order_items” ON (“events_price”.”id” = “orders_order_items”.”price_id”) INNER JOIN “events_program” ON (“events_price”.”program_id” = “events_program”.”id”) WHERE “orders_order_items”.”order_id” = 29 LIMIT 21;</span><span id="3329" class="ko kp hu kk b fv ku kr l ks kt">[‘Day 1 Pass’]</span></pre><p id="2d99" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此时，<strong class="ja hv">获取100个订单只需要3次查询。</strong></p><p id="4414" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们能做得更好吗？</p><h1 id="58a5" class="lj kp hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">引入预取</h1><p id="ec1d" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">在1.7版本中，Django引入了一个新的<code class="eh ml mm mn kk b"><a class="ae jw" href="https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.Prefetch" rel="noopener ugc nofollow" target="_blank">Prefetch</a></code> <a class="ae jw" href="https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.Prefetch" rel="noopener ugc nofollow" target="_blank">对象</a>，扩展了<code class="eh ml mm mn kk b">prefetch_related</code>的功能。</p><p id="8a43" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">新对象允许开发人员覆盖Django用来预取相关对象的查询。</p><p id="75f7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们之前的例子中，Django使用了两个预取查询——一个针对直通表，一个针对程序表。如果我们能告诉姜戈把这两个人结合在一起会怎么样？</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="47ea" class="ko kp hu kk b fv kq kr l ks kt"><strong class="kk hv">&gt; prices_and_programs = Price.objects.select_related(‘program’)</strong></span><span id="13aa" class="ko kp hu kk b fv ku kr l ks kt">&gt; o = Order.objects.filter(<br/>    state='completed'<br/>).prefetch_related(<br/><strong class="kk hv">    Prefetch('items', queryset=prices_and_programs)</strong><br/>).first()</span><span id="615f" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT … FROM “orders_order” WHERE “orders_order”.”state” = ‘completed’ ORDER BY “orders_order”.”id” ASC LIMIT 1;</span><span id="9bfa" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT (“orders_order_items”.”order_id”) AS “_prefetch_related_val_order_id”, “events_price”…., “events_program”…. INNER JOIN “events_program” ON (“events_price”.”program_id” = “events_program”.”id”) WHERE “orders_order_items”.”order_id” IN (29);</span></pre><p id="200b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们创建了一个将价格与程序联系起来的查询。然后我们告诉Django使用这个查询来预取值。这就像告诉Django您打算为每个订单获取项目和程序。</p><p id="3e49" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">获取订单的程序名称:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="28cc" class="ko kp hu kk b fv kq kr l ks kt">&gt; <strong class="kk hv">[p.program.name for p in o.items.all()]</strong></span><span id="c0ae" class="ko kp hu kk b fv ku kr l ks kt">[‘Day 1 Pass’]</span></pre><p id="e0de" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">没有额外的查询, —成功了！</p><h1 id="8b2e" class="lj kp hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">更上一层楼</h1><p id="4b7c" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">当我们之前谈到模型时，我们提到价格被建模为SCD表。这意味着我们可能只想查询特定日期的有效价格。</p><p id="208b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果价格在<code class="eh ml mm mn kk b">from_date</code>和<code class="eh ml mm mn kk b">end_date</code>之间，则价格在某一日期有效:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="ac61" class="ko kp hu kk b fv kq kr l ks kt">&gt; now = timezone.now()</span><span id="5b63" class="ko kp hu kk b fv ku kr l ks kt">&gt; active_prices = Price.objects.filter(<br/>    from_date__lte=now,<br/>    to_date__gt=now,<br/>)</span></pre><p id="a471" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用预取对象，我们可以告诉Django将预取的对象存储在结果集的一个新属性中:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="4ef8" class="ko kp hu kk b fv kq kr l ks kt">&gt; <strong class="kk hv">active_prices_and_programs = (<br/>    Price.objects.filter(<br/>        from_date__lte=now,<br/>        to_date__gt=now,<br/>    ).select_related('program')<br/>)</strong></span><span id="c195" class="ko kp hu kk b fv ku kr l ks kt">&gt; o = Order.objects.filter(<br/>    state='completed'<br/>).prefetch_related(<br/><strong class="kk hv">    Prefetch(<br/>        'items',<br/>        queryset=active_prices_and_programs,<br/>        to_attr='active_prices',<br/>    ),</strong><br/>).first()</span><span id="4081" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT … FROM “orders_order” WHERE “orders_order”.”state” = ‘completed’ ORDER BY “orders_order”.”id” ASC LIMIT 1;</span><span id="8a5f" class="ko kp hu kk b fv ku kr l ks kt">(0.001) SELECT … FROM “events_price” INNER JOIN “orders_order_items” ON (“events_price”.”id” = “orders_order_items”.”price_id”) INNER JOIN “events_program” ON (“events_price”.”program_id” = “events_program”.”id”) WHERE (<strong class="kk hv">“events_price”.”from_date” &lt;= ‘2017–04–29T07:53:00.210537+00:00’::timestamptz AND “events_price”.”to_date” &gt; ‘2017–04–29T07:53:00.210537+00:00’::timestamptz</strong> AND “orders_order_items”.”order_id” IN (29));</span></pre><p id="2e34" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以在日志中看到Django只执行了两个查询，预取查询现在包含了我们定义的自定义过滤器。</p><p id="3cca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了获取活动价格，我们可以使用在<code class="eh ml mm mn kk b">to_attr</code>中定义的新属性:</p><pre class="jy jz ka kb fq kj kk kl km aw kn dt"><span id="9c96" class="ko kp hu kk b fv kq kr l ks kt">&gt; [p.program.name for p in <strong class="kk hv">o.active_prices</strong>]</span><span id="3558" class="ko kp hu kk b fv ku kr l ks kt">[‘Day 1 Pass’]</span></pre><p id="f477" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">没有附加查询！</strong></p><h1 id="15d5" class="lj kp hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">最后的话</h1><p id="30df" class="pw-post-body-paragraph iy iz hu ja b jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv hn dt translated">预取是Django ORM一个非常强大的特性。我强烈建议仔细阅读这些文件——你肯定会大获成功。</p><p id="a930" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你喜欢Django优化技巧，可以看看我在medium上的其他故事:</p><div class="mz na fm fo nb nc"><a rel="noopener follow" target="_blank" href="/@hakibenita/things-you-must-know-about-django-admin-as-your-app-gets-bigger-6be0b0ee9614"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">随着你的应用变得越来越大，关于Django Admin你必须知道的事情</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">Django admin是一个非常强大的工具。我们用它进行日常操作、浏览数据和支持。随着我们的成长…</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kh nc"/></div></div></a></div><div class="mz na fm fo nb nc"><a rel="noopener follow" target="_blank" href="/@hakibenita/bullet-proofing-django-models-c080739be4e"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">防弹Django模型</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">我们最近在我们的一个产品中添加了类似银行账户的功能。在开发过程中，我们遇到了…</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">medium.com</p></div></div><div class="nl l"><div class="nr l nn no np nl nq kh nc"/></div></div></a></div><div class="mz na fm fo nb nc"><a href="https://hackernoon.com/timing-tests-in-python-for-fun-and-profit-1663144571" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hv fv z el nh eo ep ni er et ht dt translated">为了乐趣和利益用Python进行计时测试</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">因为提高测试性能的第一步是意识！</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">hackernoon.com</p></div></div><div class="nl l"><div class="ns l nn no np nl nq kh nc"/></div></div></a></div><blockquote class="nt nu nv"><p id="f922" class="iy iz my ja b jb jc jd je jf jg jh ji nw jk jl jm nx jo jp jq ny js jt ju jv hn dt translated"><a class="ae jw" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jw" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jw" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jw" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="iy iz my ja b jb jc jd je jf jg jh ji nw jk jl jm nx jo jp jq ny js jt ju jv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jw" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jw" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>