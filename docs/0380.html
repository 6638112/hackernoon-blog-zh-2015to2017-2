<html>
<head>
<title>Objects vs. Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对象与数据结构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/objects-vs-data-structures-e380b962c1d2?source=collection_archive---------0-----------------------#2016-01-17">https://medium.com/hackernoon/objects-vs-data-structures-e380b962c1d2?source=collection_archive---------0-----------------------#2016-01-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/7e4ca9e2be0327984e53ae3f2c2f3161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKW99f8wqfNYWs5PNY4PYw.jpeg"/></div></div></figure><div class=""/><p id="7c3a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Java开发的世界里，有对象就有对象。前者更重要。</p><p id="c347" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">困惑了吗？</p><p id="c7ee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">面向对象编程(OOP)向世界介绍了对象的概念(小“o”)。OOP对象是围绕状态的封装边界，提供某种公共行为。对象的概念不限于任何特定的语言。事实上，我们看到对象是用基于类的语言表示的，比如Java/C#/Ruby/Python，还有基于原型的语言，比如JavaScript。</p><p id="8b83" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Java引入了一个叫做“Object”的Java类(带一个大大的“O”)。Java对象是Object类的实例(包括所有子类)。这些对象是语言结构，而不是概念结构。</p><p id="48ee" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，问题来了:Java对象有资格成为OOP对象吗？嗯，这要视情况而定。本文着眼于使用数据结构对象和OOP对象的具体情况。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h2 id="d737" class="kh ki if bd kj kk kl km kn ko kp kq kr jn ks kt ku jr kv kw kx jv ky kz la lb dt translated">数据结构</h2><p id="9bb1" class="pw-post-body-paragraph jc jd if je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">考虑一个表示一个人的数据结构，它包括名、姓和电话号码。这种数据结构在各种过程语言中会是什么样子？</p><p id="8c43" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">C语言中的个人数据结构:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="0a6b" class="kh ki if lm b fv lq lr l ls lt">struct Person {<br/>  char firstName[20];<br/>  char lastName[20];<br/>  char phoneNumber[10];<br/>};</span></pre><p id="5bc5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Pascal中的个人数据结构:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="721e" class="kh ki if lm b fv lq lr l ls lt">type<br/>  Person = record<br/>    firstName : string;<br/>    lastName : string;<br/>    phoneNumber : string;<br/>  end</span></pre><p id="4eac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在Java中，相同数据结构可能如下所示:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="139d" class="kh ki if lm b fv lq lr l ls lt">public class Person {<br/>  public String firstName;<br/>  public String lastName;<br/>  public String phoneNumber;<br/>}</span></pre><p id="c16b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Java数据结构在“技术上”不同于C和Pascal版本，因为Java数据结构是一个类，而不是结构或记录。但是Java人在功能上和C struct或者Pascal记录有区别吗？不。功能上是一样的。所有3种数据结构都提供了3个可读写的字符串字段。</p><p id="5e04" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重要的一点是，Java Person对象根本不是一个“对象”，它是一个数据结构。Person对象的存在是为了将一些数据组织成一个单一的实体，可以作为一个整体传递和管理，就像C结构和Pascal记录一样。</p><p id="0270" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是如果Java Person对象看起来像这样会怎么样呢:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="c3dd" class="kh ki if lm b fv lq lr l ls lt">public class Person {<br/>  private String mFirstName;<br/>  private String mLastName;<br/>  private String mPhoneNumber;</span><span id="6d4d" class="kh ki if lm b fv lu lr l ls lt">  public String getFirstName() {<br/>    return mFirstName;<br/>  }</span><span id="e0e2" class="kh ki if lm b fv lu lr l ls lt">  public void setFirstName(String firstName) {<br/>    mFirstName = firstName;<br/>  }</span><span id="79b8" class="kh ki if lm b fv lu lr l ls lt">  public String getLastName() {<br/>    return mLastName;<br/>  }</span><span id="daed" class="kh ki if lm b fv lu lr l ls lt">  public void setLastName(String lastName) {<br/>    mLastName = lastName;<br/>  }</span><span id="47c0" class="kh ki if lm b fv lu lr l ls lt">  public String getPhoneNumber() {<br/>    return mPhoneNumber;<br/>  }</span><span id="90bb" class="kh ki if lm b fv lu lr l ls lt">  public void setPhoneNumber(String phoneNumber) {<br/>    mPhoneNumber = phoneNumber;<br/>  }<br/>}</span></pre><p id="6ed6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，Java对象是真正的对象吗？现在它有私有数据和公共方法。一定是OOP对象吧？</p><p id="325f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">即使有公共的getters和setters，Person仍然是一个数据结构。它的目的改变了吗？它的行为改变了吗？不会。Person对象仍然会以与它的public-property前身相同的方式和样式使用。Person的getter/setter版本仍然是100%的数据结构。</p><p id="f3bf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好，如果我们开始给人添加一些行为，像这样:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="05ba" class="kh ki if lm b fv lq lr l ls lt">public class Person {</span><span id="442c" class="kh ki if lm b fv lu lr l ls lt">  //... same getters/setters as before, except one:</span><span id="7665" class="kh ki if lm b fv lu lr l ls lt">  public void setPhoneNumber(String phoneNumber) throws FormatException {<br/>    validatePhoneNumber(phoneNumber);<br/>    mPhoneNumber = phoneNumber;<br/>  }</span><span id="3867" class="kh ki if lm b fv lu lr l ls lt">  private void validatePhoneNumber(String phoneNumber) throws FormatException {<br/>    // Do validation here to ensure we have a legit phone number.<br/>    // Throw an exception if its invalid.<br/>  }</span><span id="4b65" class="kh ki if lm b fv lu lr l ls lt">}</span></pre><p id="4d01" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们有真正的OOP对象了吗？Person的最新版本现在包含了验证行为，它甚至使用私有方法来实现验证。</p><p id="a058" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">甚至这个Person的最新化身也不完全是OOP对象。它更像是一个弗兰肯物体。电话号码验证行为实际上是一种行为——它是一种服务——这是OOP对象应该有的。但是请注意，我们仍然有所有这些方法来读取和写入状态。这里真的没有任何状态隐藏，也根本没有太多行为。Person仍然主要是一个公开其整个状态的数据结构，几乎不做任何事情，并将在整个代码库中用作具体类型。</p><p id="6cf8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不管你给这头猪涂了多少口红，Person都是数据结构，不是对象。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h2 id="53c3" class="kh ki if bd kj kk kl km kn ko kp kq kr jn ks kt ku jr kv kw kx jv ky kz la lb dt translated">OOP对象</h2><p id="649d" class="pw-post-body-paragraph jc jd if je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">OOP对象看起来像什么？它看起来像一种服务。OOP对象是做事情的构造——它表现和行动。</p><p id="e564" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">人员数据结构有名字、姓氏和电话号码。一个人物体行走、奔跑、跳跃和说话。一个人对象做事情。</p><p id="aab8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是一些OOP对象示例:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7020" class="kh ki if lm b fv lq lr l ls lt">public interface PhoneNumberValidator {</span><span id="3bed" class="kh ki if lm b fv lu lr l ls lt">  boolean validate(String phoneNumber);</span><span id="a198" class="kh ki if lm b fv lu lr l ls lt">}</span></pre><p id="099a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PhoneNumberValidator验证给定的字符串是否代表格式正确的电话号码。验证程序中没有内部状态的指示。也许验证器有状态，也许没有，但我们知道它提供电话号码验证服务。</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="de3b" class="kh ki if lm b fv lq lr l ls lt">public interface PersonDataStore {</span><span id="f127" class="kh ki if lm b fv lu lr l ls lt">  Person getPeople(PeopleQuery query);</span><span id="1609" class="kh ki if lm b fv lu lr l ls lt">  void addPerson(Person person);</span><span id="ba64" class="kh ki if lm b fv lu lr l ls lt">  void removePerson(Person person);</span><span id="d343" class="kh ki if lm b fv lu lr l ls lt">}</span></pre><p id="a376" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PersonDataStore提供了一种存储和查询个人数据结构的机制。在这个例子中，Person和PeopleQuery都是数据结构——它们只是组织信息。然而，PersonDataStore是一个提供服务的对象。也就是说，PersonDataStore可以接受PeopleQuery数据结构，并找到所有与查询中的标准匹配的人员数据结构。</p><p id="9e8e" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PersonDataStore是否持久存储在内存中？它会持续到磁盘吗？它索引数据吗？作为PersonDataStore的客户，我们不知道这些事情，也不关心。我们只关心PersonDataStore做什么，因为PersonDataStore是一个OOP对象。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h2 id="3fa1" class="kh ki if bd kj kk kl km kn ko kp kq kr jn ks kt ku jr kv kw kx jv ky kz la lb dt translated">混淆对象和数据结构</h2><p id="e3f6" class="pw-post-body-paragraph jc jd if je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">再次考虑人员数据结构。在最后一个例子中，我们添加了电话号码验证行为。可以想象，我们可能希望对名字和姓氏进行类似的验证。此外，当我们向这个数据结构添加更多的字段时，这些字段可能也需要被验证。</p><p id="406c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的Person <strong class="je ig">数据结构</strong>上验证<strong class="je ig">行为</strong>的问题是，我们已经创建了一个候选，它将经常违反<a class="ae lv" href="https://en.wikipedia.org/wiki/Open/closed_principle" rel="noopener ugc nofollow" target="_blank">打开/关闭原则</a>、<a class="ae lv" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>和<a class="ae lv" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">接口分离原则</a>:</p><p id="9324" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">开启/关闭原理:</strong></p><p id="38c2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个新字段都需要打开Person类并添加代码进行验证。</p><p id="2346" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">单一责任原则:</strong></p><p id="168b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Person类现在负责结构化数据、验证名字、验证姓氏和验证电话号码。这是许多可以独立变化的职责。</p><p id="236c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">界面分离原理:</strong></p><p id="7717" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您只关心收集一个电话号码。当使用Person的实例时，不仅依赖于validatePhoneNumber()方法，还依赖于validateFirstName()和validateLastName()方法。因此，您依赖于您不需要的方法，因此您违反了接口分离原则。</p><h2 id="3791" class="kh ki if bd kj kk kl km kn ko kp kq kr jn ks kt ku jr kv kw kx jv ky kz la lb dt translated">数据与行为</h2><p id="12fe" class="pw-post-body-paragraph jc jd if je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">我们可以从这个人的例子中学到的一般经验是，数据和行为不会一起变化。数据按I/O考虑因素分组，如web API输入格式和数据库模式。然而，行为是按用例分组的，这些用例代表了客户希望对应用程序做什么。</p><p id="cece" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们获取数据结构并开始添加行为时，我们会邀请Person示例中看到的所有OOP违例。</p><p id="b628" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，根据您的用例定义行为，根据您的I/O需求定义数据结构，然后定义连接两者的对象。例如，一个Android活动可能会定义如下所示的方法:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="7040" class="kh ki if lm b fv lq lr l ls lt">// Called when the user finishes entering a phone number.<br/>private void onPhoneNumberSet() {<br/>  String phoneNumber = mPhoneNumberTextView.getText().toString();<br/>  boolean isValid = mPhoneNumberValidator.validate(phoneNumber);<br/>  if (isValid) {<br/>    mPerson.setPhoneNumber(phoneNumber);<br/>  } else {<br/>    // Notify user of problem.<br/>  }<br/>}</span></pre><p id="06be" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，Person保持它自己的数据结构，不知道验证行为。然后，有一个PhoneNumberValidator对象，它知道如何验证电话号码字符串，但是不知道任何关于Person数据结构的信息。最后，包含活动编排电话号码验证，然后在Person数据结构上设置电话号码数据。</p><p id="77e8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当需要向数据源(web或本地数据库)提交个人数据时，您可以想象这样的情况:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="70dc" class="kh ki if lm b fv lq lr l ls lt">private void doSubmit() {<br/>  mPersonDataStore.addPerson(mPerson);<br/>}</span></pre><p id="6c5f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们不知道PersonDataStore是在与本地数据库对话，还是与web服务器对话，甚至是与本地内存对话。我们只知道我们的用例责任是收集个人数据并存储它。我们使用OOP对象来验证输入，现在我们使用OOP对象来存储数据。在这个过程中，数据是在Person数据结构中收集的。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><h2 id="3bad" class="kh ki if bd kj kk kl km kn ko kp kq kr jn ks kt ku jr kv kw kx jv ky kz la lb dt translated">为什么这么大惊小怪？</h2><p id="5b68" class="pw-post-body-paragraph jc jd if je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">为什么有人会关心数据结构和对象之间的细微差别呢？</p><p id="20f7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据结构是状态。</p><p id="9eff" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我重复一遍。</p><p id="5a67" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据结构是状态。</p><p id="48aa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，传递数据结构意味着共享状态，而共享状态是万恶之源。发明OOP对象的原因是为了提供一个共享状态可以被最小化和控制的范例(这就是为什么我们应该<a class="ae lv" rel="noopener" href="/@mattcarroll.name/package-wisely-4899f9580d3#.7em3f8gel">明智地打包</a>)。</p><p id="4aea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">把数据结构想象成你的代码中，你的OOP对象之间的一种交换格式。考虑以下伪代码:</p><pre class="lh li lj lk fq ll lm ln lo aw lp dt"><span id="a69d" class="kh ki if lm b fv lq lr l ls lt">objectA.doThing1();<br/>objectA.doThing2();</span><span id="7f7f" class="kh ki if lm b fv lu lr l ls lt">myDataStructure = objectA.extractState();</span><span id="5320" class="kh ki if lm b fv lu lr l ls lt">objectB.setState(myDataStructure);<br/>objectB.doThing3();<br/>objectB.doThing4();</span></pre><p id="3c50" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用objectA做一些工作。然后我们通过获得一个数据结构来提取objectA的状态。我们通过发送从A获得的数据结构来初始化objectB，现在objectB做一些工作。在这个例子中，myDataStructure有一个隐含的不变性，因此更改myDataStructure不会对objectA或objectB产生任何隐藏的内部影响。</p><p id="2a85" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据结构只是提供了一种在有组织的状态中移动的机制。它本身不提供任何行为。这就是我们应该如何在代码中利用数据结构。</p><p id="3ed2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">认识到状态提取应该是相对低频的操作也很重要。大多数时候，你应该让对象接受并返回其他对象，而不是数据结构。</p><p id="08a6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只有在应用程序跨越不同领域时，才应该使用数据结构。例如，当您在I/O域中接收输入时，您可以使用数据结构将该数据注入到您的业务域中。同样，当您需要向用户可视化地展示某些东西时，您可以使用数据结构从您的业务领域中提取信息，并将其发送到您的可视化领域中。数据结构是应用程序域之间的交换格式。</p></div><div class="ab cl ka kb hc kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hn ho hp hq hr"><p id="cd86" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在开发应用程序时，请记住，Java对象不一定是OOP对象，数据结构与OOP对象不是一回事，您应该确保识别和区分这些不同的结构。</p><div class="lh li lj lk fq ab cb"><figure class="lw hw lx ly lz ma mb paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lw hw lx ly lz ma mb paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lw hw lx ly lz ma mb paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mc md me"><p id="f922" class="jc jd mf je b jf jg jh ji jj jk jl jm mg jo jp jq mh js jt ju mi jw jx jy jz hn dt translated"><a class="ae lv" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lv" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lv" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lv" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd mf je b jf jg jh ji jj jk jl jm mg jo jp jq mh js jt ju mi jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lv" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lv" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lh li lj lk fq hw fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff mj"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure></div></div>    
</body>
</html>