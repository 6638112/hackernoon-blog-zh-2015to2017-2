<html>
<head>
<title>Django 1.11 goes live</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django 1.11上线</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/django-1-11-goes-live-d3e767498973?source=collection_archive---------8-----------------------#2017-04-07">https://medium.com/hackernoon/django-1-11-goes-live-d3e767498973?source=collection_archive---------8-----------------------#2017-04-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/4f0dabf112c702f46f7692a4c4c6caa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bw_Z0cUYMAZ4bjwQP92ndw.png"/></div></div></figure><p id="79eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该版本已被指定为长期支持(LTS)版本，这意味着至少在未来三年内将应用安全和数据丢失修复。</p><blockquote class="ka"><p id="0c90" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated"><a class="ae kk" href="https://djangostars.com/blog/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%201.11&amp;utm_content=click%20here" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">点击阅读更多关于Django的文章。</strong>T3】</a></p></blockquote><h1 id="d50d" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">新功能:</h1><p id="94b3" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">这个特性允许为数据库创建复合和定制索引。自定义索引为数据库查询提供了更好的优化，并且可以加快数据库的响应时间。</p><p id="766f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">定制表单的输出绝对是一件痛苦的事情。虽然目前我们只是简单地使用API，而且这个特性似乎没有必要，但它仍然是一个很好的改进，可以方便标准表单的定制。至少我们可以在django admin中看到这一点。</p><ul class=""><li id="c47d" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated"><a class="ae kk" href="https://docs.djangoproject.com/en/1.11/releases/1.11/#subquery-expressions" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">子查询表达式</strong> </a> <strong class="je hv">使用ORM创建显式子查询</strong></li></ul><p id="bff6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很有趣，因为Django 1.8为Django ORM引入了条件表达式。子查询表达式扩展了ORM的功能。因此，您可以在没有原始SQL查询的情况下创建更复杂的东西。</p><p id="db91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以使用<strong class="je hv">子查询</strong>表达式向QuerySet添加显式子查询。</p><p id="1164" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，要用帖子最新评论作者的电子邮件地址来注释每个帖子:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="aa66" class="mg km hu mc b fv mh mi l mj mk">&gt;&gt;&gt; from django.db.models import OuterRef, Subquery &gt;&gt;&gt; newest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created_at') &gt;&gt;&gt; Post.objects.annotate(newest_commenter_email=Subquery(newest.values('email')[:1]))</span></pre><p id="c7d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在PostgreSQL上，SQL看起来像:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="028d" class="mg km hu mc b fv mh mi l mj mk">SELECT "post"."id", ( SELECT U0."email" FROM "comment" U0 WHERE U0."post_id" = ("post"."id") ORDER BY U0."created_at" DESC LIMIT 1 ) AS "newest_commenter_email" FROM "post"</span></pre><h2 id="1cb3" class="mg km hu bd kn ml mm mn kr mo mp mq kv jn mr ms kz jr mt mu ld jv mv mw lh mx dt translated"><strong class="ak">您可能还喜欢:</strong></h2><div class="my mz fm fo na nb"><a href="https://djangostars.com/blog/merging-django-orm-with-sqlalchemy-for-easier-data-analysis/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%201.11&amp;utm_content=youmayalsolike1" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">将Django ORM与SQLAlchemy合并以简化数据分析</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">Django产品的开发通常简单明了:优秀的文档，许多现成的工具…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">djangostars.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ja nb"/></div></div></a></div><div class="my mz fm fo na nb"><a href="https://djangostars.com/blog/django-performance-optimization-tips/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%201.11&amp;utm_content=youmayalsolike2" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">Django性能优化技巧</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">当开发人员接到一个在Django上进行性能优化的任务时，我经常会遇到这种情况…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">djangostars.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np ja nb"/></div></div></a></div><p id="dc0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">引用外部查询集中的列</strong></p><p id="178d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当子查询中的queryset需要引用外部查询中的字段时，请使用OuterRef。它的行为类似于F表达式，只是在解析外部queryset之前，不会检查它是否引用了有效字段。</p><p id="a544" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">OuterRef的实例可以与子查询的嵌套实例一起使用，以引用不是直接父级的包含queryset。例如，此queryset需要在一对嵌套的子查询实例中才能正确解析:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="d0c8" class="mg km hu mc b fv mh mi l mj mk">&gt;&gt;&gt; Book.objects.filter(author=OuterRef(OuterRef('pk')))</span></pre><p id="9841" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Exists() </strong>子查询</p><p id="f834" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Exists是使用SQL EXISTS语句的子查询子类。在许多情况下，它的性能优于子查询，因为当找到第一个匹配行时，数据库能够停止对子查询的求值。</p><p id="2f8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，要在每篇文章上标注是否有最近一天的评论:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="17dd" class="mg km hu mc b fv mh mi l mj mk">&gt;&gt;&gt; from django.db.models import Exists, OuterRef &gt;&gt;&gt; from datetime import timedelta &gt;&gt;&gt; from django.utils import timezone &gt;&gt;&gt; one_day_ago = timezone.now() - timedelta(days=1) &gt;&gt;&gt; recent_comments = Comment.objects.filter( ... post=OuterRef('pk'), ... created_at__gte=one_day_ago, ... ) &gt;&gt;&gt; Post.objects.annotate(recent_comment=Exists(recent_comments))</span></pre><p id="e3cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在PostgreSQL上，SQL看起来像:</p><pre class="lx ly lz ma fq mb mc md me aw mf dt"><span id="8329" class="mg km hu mc b fv mh mi l mj mk">SELECT "post"."id", "post"."published_at", EXISTS( SELECT U0."id", U0."post_id", U0."email", U0."created_at" FROM "comment" U0 WHERE ( U0."created_at" &gt;= YYYY-MM-DD HH:MM:SS AND U0."post_id" = ("post"."id") ) ) AS "recent_comment" FROM "post"</span></pre><h1 id="160e" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw nr ky kz la ns lc ld le nt lg lh li dt translated">以前的版本</h1><p id="29a1" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">随着Django 1.11的发布，Django 1.10已经到了主流支持的末期。Django 1.10将在2017年12月之前的八个月内获得安全和数据丢失修复。</p><p id="3ffd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="nu">来源:</em>【https://docs.djangoproject.com/en/1.11/releases/1.11/】T2</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><a href="https://djangostars.com/services/python-django-development/?utm_source=medium&amp;utm_medium=hackernoon.com&amp;utm_campaign=django%201.11&amp;utm_content=banner_end"><div class="fe ff nv"><img src="../Images/45a1ce60def7b50ffe2311c7a897d600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdZ7gDbH7I9rnq7Z2xauiA.png"/></div></a></figure><p id="0415" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们随时欢迎您提出问题，分享您想阅读的话题！</p><blockquote class="ka"><p id="b892" class="kb kc hu bd kd ke kf kg kh ki kj jz ek translated">如果你觉得这篇文章有用，请点击👏下面的按钮:)</p></blockquote><figure class="nw nx ny nz oa iv"><div class="bz el l di"><div class="ob oc l"/></div></figure><div class="lx ly lz ma fq ab cb"><figure class="od iv oe of og oh oi paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="od iv oe of og oh oi paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="od iv oe of og oh oi paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="oj ok ol"><p id="f922" class="jc jd nu je b jf jg jh ji jj jk jl jm om jo jp jq on js jt ju oo jw jx jy jz hn dt translated"><a class="ae kk" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kk" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kk" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kk" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd nu je b jf jg jh ji jj jk jl jm om jo jp jq on js jt ju oo jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kk" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kk" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff op"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>