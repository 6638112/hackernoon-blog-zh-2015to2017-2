<html>
<head>
<title>Redux Testing Step by Step: A Simple Methodology for Testing Business Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逐步还原测试:测试业务逻辑的简单方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/redux-testing-step-by-step-a-simple-methodology-for-testing-business-logic-8901670756ce?source=collection_archive---------1-----------------------#2017-04-05">https://medium.com/hackernoon/redux-testing-step-by-step-a-simple-methodology-for-testing-business-logic-8901670756ce?source=collection_archive---------1-----------------------#2017-04-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d46024f16d92564bc036cf61330e1aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-PUPzsszZyQrvJ4G-_mDg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">full coverage, all green</figcaption></figure><blockquote class="jg jh ji"><p id="9e3b" class="jj jk jl jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><em class="hu">与</em> <a class="ki kj gr" href="https://medium.com/u/9406506a2c3b?source=post_page-----8901670756ce--------------------------------" rel="noopener" target="_blank"> <em class="hu">耶迪迪亚·肯纳德</em> </a> <em class="hu">和</em> <a class="ki kj gr" href="https://medium.com/u/5806c0dea72c?source=post_page-----8901670756ce--------------------------------" rel="noopener" target="_blank"> <em class="hu">伊森·沙拉比</em> </a></p></blockquote><p id="ec56" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated"><em class="jl">我们的</em><a class="ae kn" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"><em class="jl">Redux</em></a><em class="jl">工作流系列的第二部分。一个实施良好的系统只是工作的一半。另一半是证明我们的系统按照规范运行的自动化测试套件。这是提高我们工程速度的一个关键因素。Redux的主要好处之一是视图和业务逻辑之间的清晰分离，这也允许独立测试这两个部分。测试我们的业务逻辑意味着测试各种Redux结构——reducer、选择器和动作处理程序(thunks)。</em></p></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="ed61" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">面向现实生活应用的简单而强大的工作流程</h2><p id="4808" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">下面介绍的是我们系列的第二部分，是关于现实生活中应用程序的简单而健壮的工作流程。如果你还没有读过第一部分——“一步一步地还原:现实生活应用的简单而健壮的工作流程”——建议你先读一读。</p><p id="d110" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated"><a class="ae kn" href="https://github.com/reactjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>已经成为最受欢迎的<a class="ae kn" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>实现之一，用于管理<a class="ae kn" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a>应用中的数据流。然而，阅读Redux经常会导致感官超负荷，从而只见树木不见森林。这也适用于测试Redux项目。</p><p id="0c0c" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">像往常一样，我们将从迭代开始，没有一种正确的方法来测试您的Redux项目。我们将呈现一种我们个人信奉的<em class="jl">固执己见的</em>风味。</p><h2 id="5c31" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">一些动力</h2><p id="e2ba" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">测试的最大动机之一是<em class="jl">工程速度</em>。看起来编写测试会减慢开发过程，但是这种观念只在短期内有效。没有自动化测试，我们已经注意到，在我们交付的能力停滞之前，我们的项目只能增长那么多。</p><p id="4bf1" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">全面覆盖的自动化测试套件是一个非常强大的工具。它使新的贡献者能够推送代码，而不用担心破坏任何东西。它通过减轻对剧烈重构的恐惧来对抗代码腐败。它使发布速度更快，更有信心。它允许在生产中不断修复问题，而不需要等待人工回归。</p><h2 id="f9ec" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">测试的金字塔</h2><p id="117d" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">我们应该写什么样的测试？我们应该一起测试整个系统还是分别测试每个单元？考虑下面的例子:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lv"><img src="../Images/1db7a04fef93d808a5a1c3aeff167676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0dboi7W5svXlqXx1wVD3Q.png"/></div></div></figure><p id="f3f9" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">如果我们只是一起测试整个系统，我们将需要编写25个测试来覆盖整个系统(5x5的流程组合)。更好的方法是混合多个层次的测试:模块A单独的5个<em class="jl">单元测试</em>，模块B单独的另外5个<em class="jl">单元测试</em>，以及整个系统的1-2个<em class="jl">集成测试</em>。</p><p id="ece1" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">将多级方法应用于测试领域<em class="jl">前端应用</em>产生了著名的<em class="jl">测试金字塔</em>:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/3afa2a7dc3edea65c0a76cd64579c304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QItI1DL5m8Od9LzPB5tfDw.png"/></div></div></figure><p id="5560" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">关于金字塔的样子和不同层级的名称有很多模糊之处。这是我们的观点:</p><ul class=""><li id="15e4" class="mb mc hu jm b jn jo jr js kk md kl me km mf kh mg mh mi mj dt translated"><strong class="jm hv"> E2E测试</strong>——从外部测试整个应用。运行在实际的浏览器或移动设备上，使用实际的服务器，通常是在生产环境中。</li><li id="efbf" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mg mh mi mj dt translated"><strong class="jm hv"> UI自动化测试</strong> —从外部测试app的主要模块。运行在真实的浏览器或移动设备上，带有模拟服务器。</li><li id="448c" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mg mh mi mj dt translated"><strong class="jm hv">组件测试</strong> —从内部测试UI以及它与业务逻辑的集成。通常运行在<a class="ae kn" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>上，带有模拟服务。</li><li id="b34c" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mg mh mi mj dt translated"><strong class="jm hv">单元测试</strong> —测试没有UI的业务逻辑，作为单独的单元。在<a class="ae kn" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a>上奔跑，嘲讽单位外的一切。这里通常还包括单元之间的一层集成测试。</li></ul><p id="0265" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">不同级别的考试有不同的特点。你爬得越高，测试就越脆弱。它们提供了更多的信心，但是通常编写和维护起来更加昂贵。他们跑得也慢得多。一个好的平衡是从较低层次进行大量的测试，从较高层次进行越来越少的测试。</p><h2 id="1c6c" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">业务逻辑的单元测试</h2><p id="3c4d" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">这篇文章的剩余部分将关注测试金字塔的基础——业务逻辑的<em class="jl">单元测试</em>。这些是我们希望在项目中进行的大部分测试。我们将在以后的帖子中关注其他级别。</p><p id="f389" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们的Redux方法加强了组件和业务逻辑之间的清晰分离。记住这条规则:“将所有业务逻辑放在动作处理程序(thunks)、选择器和归约器中。”这将允许我们从现在开始完全忽略组件。</p><p id="b4c2" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们将继续讨论我们在<a class="ae kn" href="https://hackernoon.com/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092#.q8vryqq6r" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中实现的Reddit应用。它让用户从首页子编辑中选择3个主题，然后在一个可过滤的列表中看到他们的帖子。用代码刷新你的记忆，这里有:【https://github.com/wix/react-dataflow-example T4】</p><h2 id="d140" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">为测试进行设置</h2><p id="b6da" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">运行<em class="jl">单元测试</em>需要某种测试运行程序。像<a class="ae kn" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> jest </a>这样的现代跑步者包括你需要测试的一切，比如<a class="ae kn" href="https://facebook.github.io/jest/docs/setup-teardown.html#content" rel="noopener ugc nofollow" target="_blank">设置和拆卸</a>、<a class="ae kn" href="https://facebook.github.io/jest/docs/using-matchers.html#content" rel="noopener ugc nofollow" target="_blank">期望</a>和<a class="ae kn" href="https://facebook.github.io/jest/docs/mock-functions.html#content" rel="noopener ugc nofollow" target="_blank">嘲讽</a>。</p><p id="d86c" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们的应用依赖于<a class="ae kn" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>，它已经预配置了<a class="ae kn" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> jest </a>。您可以在“终端”中运行以下命令来进行设置:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="532a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">注意，我们还安装了<a class="ae kn" href="https://github.com/wix/redux-testkit" rel="noopener ugc nofollow" target="_blank">redux-test kit</a>——这个库减少了测试Redux的样板文件，使测试过程更加简单有趣。</p><p id="2d32" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">最后一个命令<code class="eh mr ms mt mu b">npm test</code>将在观察模式下启动jest，并在我们编写测试时自动运行它们。如果您的项目没有预装jest，您可以按照这些说明或简单地运行<code class="eh mr ms mt mu b">npm install jest --save-dev</code>来轻松安装它</p><h2 id="3c43" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">我们的游戏计划</h2><p id="3937" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">如果我们一直遵循<a class="ae kn" href="https://hackernoon.com/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092#.q8vryqq6r" rel="noopener ugc nofollow" target="_blank">方法</a>，我们所有的业务逻辑都可以在各种Redux构造中找到，比如<a class="ae kn" href="http://redux.js.org/docs/advanced/AsyncActions.html" rel="noopener ugc nofollow" target="_blank">动作处理器</a> ( <a class="ae kn" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunks </a>)、<a class="ae kn" href="http://redux.js.org/docs/recipes/ComputingDerivedData.html" rel="noopener ugc nofollow" target="_blank">选择器</a>和<a class="ae kn" href="http://redux.js.org/docs/basics/Reducers.html" rel="noopener ugc nofollow" target="_blank">reducer</a>。我们所要做的就是练习如何测试每一个:</p><ol class=""><li id="9b71" class="mb mc hu jm b jn jo jr js kk md kl me km mf kh mv mh mi mj dt translated"><strong class="jm hv">减速器的单元测试</strong></li><li id="dbad" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mv mh mi mj dt translated"><strong class="jm hv">选择器</strong>的单元测试</li><li id="b713" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mv mh mi mj dt translated"><strong class="jm hv">动作处理程序</strong>的单元测试(thunks)</li><li id="6405" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mv mh mi mj dt translated"><strong class="jm hv">服务的单元测试</strong></li><li id="802b" class="mb mc hu jm b jn mk jr ml kk mm kl mn km mo kh mv mh mi mj dt translated">整个<strong class="jm hv">商店</strong>的整合测试</li></ol></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="1b7f" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">减速器的单元测试</h2><p id="e2e1" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">Reducers是纯粹的函数，它接受现有的状态和动作，并在应用动作后返回新的状态。纯函数的好处是没有副作用，所以不需要模仿。</p><p id="3fd6" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们需要注意的一件事是<a class="ae kn" href="http://redux.js.org/docs/faq/ImmutableData.html#why-is-immutability-required" rel="noopener ugc nofollow" target="_blank">不变性</a>。不允许Reducers通过就地更改某个键来改变现有状态。这是一个<a class="ae kn" href="https://github.com/wix/redux-testkit" rel="noopener ugc nofollow" target="_blank"> redux-testkit </a>帮助我们验证不变性的例子。</p><p id="030d" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">jest的推荐做法是将测试与被测试的文件放在一起。我们的第一个减速器出现在<code class="eh mr ms mt mu b">src/store/topics/reducer.js</code>。我们将把它的测试放在<code class="eh mr ms mt mu b">src/store/topics/__tests__/reducer.spec.js</code>附近。</p><p id="6082" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">先从最简单的<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/45f020f0c29075d7fcfe1d5d444a807a69a6d842/src/store/topics/reducer.js" rel="noopener ugc nofollow" target="_blank">题目减速器</a>测试开始。当我们的reducer在没有提供现有状态和动作的情况下被执行时(两者都是<em class="jl">未定义</em>，它应该返回初始状态:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="7df4" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">接下来，让我们添加一些发送动作并检查是否返回正确状态的测试。为此，我们将使用redux-testkit的<a class="ae kn" href="https://github.com/wix/redux-testkit#recipe---unit-testing-reducers" rel="noopener ugc nofollow" target="_blank">减速器配方</a>:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="f6ea" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">注意，当向我们的reducer提供现有状态时，我们需要保持与reducer实现如何保持其状态的兼容性。在这种情况下，它使用<a class="ae kn" href="https://github.com/rtfeldman/seamless-immutable" rel="noopener ugc nofollow" target="_blank">无缝不可变</a>，这意味着我们也必须这样做。</p><p id="0aa6" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">如果你的状态对象是复杂的和深度嵌套的，redux-testkit包含其他方法来断言<a class="ae kn" href="https://github.com/wix/redux-testkit#reducerreducerwithstatestateexpectactiontochangeinstatechanges" rel="noopener ugc nofollow" target="_blank">状态增量</a>或者使用<a class="ae kn" href="https://github.com/wix/redux-testkit#reducerreducerwithstatestateexecuteaction" rel="noopener ugc nofollow" target="_blank">定制期望</a>。</p><p id="2146" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">经过全面测试的主题减速器在此处<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/e36e1f43ce797d47795eb15b44575f3e21912c7d/src/store/topics/__tests__/reducer.spec.js" rel="noopener ugc nofollow" target="_blank">可用</a>，在此处发布减速器<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/e36e1f43ce797d47795eb15b44575f3e21912c7d/src/store/posts/__tests__/reducer.spec.js" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="4bd9" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">选择器的单元测试</h2><p id="89b6" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">选择器也是纯粹的函数，它获取现有的全局状态并从中返回一些派生数据。再说一次，没有副作用，所以不需要嘲笑。</p><p id="a657" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们还需要注意这里的<a class="ae kn" href="http://redux.js.org/docs/faq/ImmutableData.html#why-is-immutability-required" rel="noopener ugc nofollow" target="_blank">不变性</a>。选择器是只读的，不应该改变状态。当使用像<a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" rel="noopener ugc nofollow" target="_blank"> array.reverse </a>这样的函数时，很容易忽略这一点，这些函数会使它们运行的对象发生变异，并在选择器运行时意外地改变状态。和以前一样，redux-testkit帮助我们验证了不变性。</p><p id="efb5" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们将测试与被测试的文件放在一起，但是我们将选择器测试与缩减器测试分开，即使缩减器实现在同一个文件中包含选择器。<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/97d26fc14b4d9f3a340bf57c2ab74af78f3c062b/src/store/topics/reducer.js" rel="noopener ugc nofollow" target="_blank">主题选择器</a>位于<code class="eh mr ms mt mu b">src/store/topics/reducer.js</code>内部。我们将把他们的测试放在<code class="eh mr ms mt mu b">src/store/topics/__tests__/selectors.spec.js</code>附近。</p><p id="0c7f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">让我们从对<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/97d26fc14b4d9f3a340bf57c2ab74af78f3c062b/src/store/topics/reducer.js#L48" rel="noopener ugc nofollow" target="_blank"> getSelectedTopicsByUrl选择器</a>的简单测试开始。我们将测试当状态为空(初始)时，它是否返回正确的结果。像以前一样，我们将使用redux-testkit的<a class="ae kn" href="https://github.com/wix/redux-testkit#recipe---unit-testing-selectors" rel="noopener ugc nofollow" target="_blank">选择器配方</a>:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="9aa8" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">再次注意，当向我们的选择器提供现有状态时，我们需要保持与reducer实现如何保持其状态的兼容性。在这种情况下，它使用<a class="ae kn" href="https://github.com/rtfeldman/seamless-immutable" rel="noopener ugc nofollow" target="_blank">无缝不可变</a>，这意味着我们也必须这样做。</p><p id="9db1" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们应该向这个选择器添加几个测试，以涵盖状态不为空的情况:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="3cc5" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">注意，redux-testkit包含其他方法，如<a class="ae kn" href="https://github.com/wix/redux-testkit#selectorselectorexecutestate-args" rel="noopener ugc nofollow" target="_blank"> execute </a>，如果您喜欢使用定制的期望。</p><p id="9230" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">经过全面测试的主题选择器在这里<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/e36e1f43ce797d47795eb15b44575f3e21912c7d/src/store/topics/__tests__/selectors.spec.js" rel="noopener ugc nofollow" target="_blank">可用</a>，文章选择器在这里<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/bcc6993e6bc27b1929cfc581ca6f773c931537d8/src/store/posts/__tests__/selectors.spec.js" rel="noopener ugc nofollow" target="_blank">可用</a>。</p></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="1059" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated"><strong class="ak">动作处理程序</strong>的单元测试(thunks)</h2><p id="66c9" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">根据我们的<a class="ae kn" href="https://hackernoon.com/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092#.q8vryqq6r" rel="noopener ugc nofollow" target="_blank">方法</a>，几乎我们导出的每个动作(由视图调度)都是一个<a class="ae kn" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunk </a>。Thunks包装执行动作的同步或异步函数。它们还会导致副作用，比如访问服务器，这在编写单元测试时通常会被嘲笑。</p><p id="29ec" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">当对thunk进行单元测试时，我们需要断言什么？thunk的主要输出是分派其他动作——主要是触发reducers中状态修改的普通对象动作。Thunks还可以调度其他thunks。这意味着我们应该对派出的<em class="jl">设定期望值。此外，由于thunks会导致访问服务器之类的副作用，我们也可以对这些设置期望值。</em></p><p id="dd7a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">像往常一样，我们将测试与被测试的文件放在一起。<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/53a2f3411d855b97860bb18ea75974eec82c29d8/src/store/topics/actions.js" rel="noopener ugc nofollow" target="_blank">主题动作</a>在<code class="eh mr ms mt mu b">src/store/topics/actions.js</code>里面。我们将把他们的测试放在<code class="eh mr ms mt mu b">src/store/topics/__tests__/actions.spec.js</code>附近。</p><p id="f61a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">让我们从测试<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/53a2f3411d855b97860bb18ea75974eec82c29d8/src/store/topics/actions.js#L14" rel="noopener ugc nofollow" target="_blank"> fetchTopics动作</a>开始。我们将测试它是否会触发预期的调度。因为这是一个单元测试，所以我们不会实际执行分派——它们会被嘲笑。我们将使用redux-testkit的<a class="ae kn" href="https://github.com/wix/redux-testkit#recipe---unit-testing-thunks" rel="noopener ugc nofollow" target="_blank"> Thunk方法</a>:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><h2 id="0d85" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">单元测试thunks调用其他thunks</h2><p id="105b" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">随着您的系统变得越来越复杂，您可能会有一个thunk分派另一个thunk。这是一个有趣的测试案例。我们可以在我们的Reddit应用程序的<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/bcc6993e6bc27b1929cfc581ca6f773c931537d8/src/store/topics/actions.js#L40" rel="noopener ugc nofollow" target="_blank"> selectTopic操作</a>中看到这个例子。</p><p id="be7b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们的最佳实践是始终将不同的thunks视为不同的单元——即使它们在同一个文件中。这意味着当<em class="jl">单元测试</em>一个调度另一个的thunk时，我们不会实际执行第二个thunk——我们会一直模拟它。为了改进我们的测试，给第二个thunk的匿名内部函数一个明确的名字也是一个好主意:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="06f7" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们的助手库redux-testkit在测试调度另一个thunk的thunk时提出了几个<a class="ae kn" href="https://github.com/wix/redux-testkit#limitations-when-testing-thunks-that-dispatch-other-thunks" rel="noopener ugc nofollow" target="_blank">限制</a>。我们不能对发送给第二个thunk的参数设置期望值，也不能模仿它的返回值。乍看起来，这些限制降低了我们测试的广度，但它们实际上加强了对兄弟思维的正确处理。</p><p id="86f0" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">如果您的用例受到这些限制，您可能不会将不同的thunks视为不同的单元——这通常是一种<em class="jl">代码气味</em>。进一步的讨论超出了这篇文章的范围，但是这个主题非常重要，所以我们决定专门写一篇简短的文章——“Redux Thunks Dispatching Other Thunks——讨论和最佳实践”。</p><p id="5534" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">那么<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/bcc6993e6bc27b1929cfc581ca6f773c931537d8/src/store/topics/actions.js#L40" rel="noopener ugc nofollow" target="_blank"> selectTopic action </a>的单元测试会是什么样子呢？</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="25da" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">经过全面测试的主题操作在<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/b95f82560bd2e04c04d1702ce29a572449dfd0ed/src/store/topics/__tests__/actions.spec.js" rel="noopener ugc nofollow" target="_blank">这里</a>可用，发布操作<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/b95f82560bd2e04c04d1702ce29a572449dfd0ed/src/store/posts/__tests__/actions.spec.js" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="24dd" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated"><strong class="ak">服务的单元测试</strong></h2><p id="13d8" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">服务是外部API的抽象外观(如后端服务器)。它们是无状态的，通常包含纯逻辑。服务的一个常见副作用是使用<a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank"> fetch </a>发出HTTP请求——我们将不得不对此加以模仿。为此，我们将使用<a class="ae kn" href="https://github.com/jefflau/jest-fetch-mock" rel="noopener ugc nofollow" target="_blank"> jest-fetch-mock </a>。用<br/> <code class="eh mr ms mt mu b">npm install jest-fetch-mock --save-dev</code>安装</p><p id="cf93" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">像往常一样，我们将测试与被测试的文件放在一起。reddit服务位于<code class="eh mr ms mt mu b">src/services/reddit.js</code>内部。我们将在<code class="eh mr ms mt mu b">src/services/__tests__/reddit.spec.js</code>附近进行测试。</p><p id="d659" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">让我们从对<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/cae09bba934bda406bca8ed5d5caffededdce6ab/src/services/reddit.js#L11" rel="noopener ugc nofollow" target="_blank"> getDefaultSubreddits命令</a>的简单测试开始:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="9983" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">这些测试在开发过程中也非常方便，因为它们让我们可以根据遵循契约的示例数据进行工作。对于这个测试，我们手动记录了Reddit API，并将记录作为JSON放在<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/cae09bba934bda406bca8ed5d5caffededdce6ab/src/services/__tests__/reddit.subreddits.json" rel="noopener ugc nofollow" target="_blank"> reddit.subreddits.json </a>中。实际上，更方便的做法是先编写测试，然后完成满足它们的实现。</p><p id="8ad0" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">经过全面测试的reddit服务在<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/cae09bba934bda406bca8ed5d5caffededdce6ab/src/services/__tests__/reddit.spec.js" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="9d75" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">整个<strong class="ak">商场的整合测试</strong></h2><p id="cf28" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">到目前为止，我们所有的测试都集中在单个<em class="jl">单元</em>——单个缩减器、单个选择器、单个thunk或单个服务。我们的下一个议程是测试我们的单元如何互连——换句话说，<em class="jl">集成测试</em>。</p><p id="15a1" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">关于术语“集成测试”有很多模糊之处——这完全取决于什么与什么集成。让我们明确并准确地定义什么在我们的案例中起作用。我们的重点是客户中业务逻辑单元之间的集成。不是客户端和服务器之间的集成。业务逻辑和UI之间没有集成。</p><p id="7771" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">使用Redux，我们的业务逻辑与应用程序的其余部分完全分离，位于我们的<em class="jl">商店</em>下。为了一起测试所有的Redux结构，我们需要一个实际的Redux store实例。没有理由不使用真实的东西，所以我们将创建一个商店实例，就像我们在<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/53a2f3411d855b97860bb18ea75974eec82c29d8/src/index.js#L10" rel="noopener ugc nofollow" target="_blank">生产代码</a>中创建商店一样。</p><p id="2f1b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">驱动我们测试场景的输入是什么？回顾Flux <a class="ae kn" href="https://cdn-images-1.medium.com/max/1600/1*stmn8kxXJrX9hbk39hHQJA.png" rel="noopener">架构图</a>，触发商店变化的唯一方式是通过分派一个动作。这意味着<em class="jl">动作</em>将成为我们的输入。</p><p id="046f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">在我们的场景中，我们将做出什么样的断言？回顾Flux <a class="ae kn" href="https://cdn-images-1.medium.com/max/1600/1*stmn8kxXJrX9hbk39hHQJA.png" rel="noopener">架构图</a>，消费我们商店的唯一方式是监听更新状态。我们通常从不直接访问新状态，而是使用选择器。这意味着<em class="jl">选择器</em>将用于我们的断言。</p><p id="fe64" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">为了将测试与被测试的文件放在一起，我们将使用<code class="eh mr ms mt mu b">src/store</code>文件夹。<a class="ae kn" href="https://github.com/wix/react-dataflow-example/tree/cae09bba934bda406bca8ed5d5caffededdce6ab/src/store/topics" rel="noopener ugc nofollow" target="_blank">主题域</a>位于<code class="eh mr ms mt mu b">src/store/topics</code>下。我们将在<code class="eh mr ms mt mu b">src/store/__tests__/topics.spec.js</code>附近进行测试。</p><p id="11c5" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">让我们从一个实例化商店的空框架开始:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="2cb8" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们不需要redux-testkit的太多帮助，因为我们所做的只是使用官方的Redux API。我们添加的唯一助手是一个名为<a class="ae kn" href="https://github.com/wix/redux-testkit#flushthunks--flushthunkscreatemiddleware" rel="noopener ugc nofollow" target="_blank"> FlushThunks </a>的中间件。这个中间件跟踪所有已经被分派的thunks。这对于一个thunk分派另一个thunk并让我们在运行断言之前等待所有承诺都被解析的情况很有用。如果您没有thunks分派其他thunks，您可以移除这个中间件。</p><p id="ad25" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">让我们实现一个有趣的与主题相关的集成场景:我们将从从reddit服务获取所有主题开始。然后只选择其中的两个，并验证我们的选择仍然无效(需要3个)。然后，我们将选择第三个并验证选择是否有效。一旦选择了3个主题，系统通过<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/cae09bba934bda406bca8ed5d5caffededdce6ab/src/store/topics/actions.js#L40" rel="noopener ugc nofollow" target="_blank">分派</a>一个帖子动作从这些主题中预取帖子。最后，我们将验证预取是否成功，以及正确的帖子是否到达了我们的商店。最后一个动作是一个thunk调度另一个thunk——所以我们需要使用FlushThunks来等待一切平息下来:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="56e4" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">这个场景似乎重复了我们之前的<em class="jl">单元测试</em>中已经测试过的方面。这是正确的。根据定义<em class="jl">集成测试</em>需要几个单元并组合它们的流程。</p><p id="c352" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">这个想法是为了测试单元之间的少量快乐流。没有必要检查每个可能的组合。让我们以上面的场景为例，没有必要添加另一个测试来检查当选择第四个主题时会发生什么(我们期望第一个主题被替换)。我们已经在广泛的<em class="jl">单元测试</em>中涵盖了这些边缘情况。</p><p id="3c0f" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">记住我们的金字塔。我们走得越高，我们需要写的场景就越少。集成场景的总数应该大大低于单元场景。不确定应该编写哪些集成场景？尝试找到您尚未在集成场景中涉及的<em class="jl">动作</em>，并围绕它们构建一个动作。</p><p id="0a0b" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">经过全面测试的主题域可在<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/0ae091aab8f798cee5fe5d235218c5e6c0a6d3cb/src/store/__tests__/topics.spec.js" rel="noopener ugc nofollow" target="_blank">这里</a>，帖子域<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/0ae091aab8f798cee5fe5d235218c5e6c0a6d3cb/src/store/__tests__/posts.spec.js" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl ko kp hc kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hn ho hp hq hr"><h2 id="9256" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">摘要</h2><p id="4e37" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">我们已经完成了我们的游戏计划，我们的业务逻辑应该包括在内。我们示例Reddit应用程序的完整代码(包括业务逻辑的完整测试)可在GitHub的以下分支中找到:</p><div class="mw mx fm fo my mz"><a href="https://github.com/wix/react-dataflow-example/tree/redux-thunk-tests" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">wix/react-数据流-示例</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">react-dataflow-example -为现实生活中的react应用程序尝试不同的数据流方法</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ja mz"/></div></div></a></div><h2 id="6ba1" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">新闻报道</h2><p id="68d0" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">你如何知道你是否有足够的测试覆盖率？一种方法是使用jest覆盖率报告，它指出了在测试中实际执行的代码行的百分比。通过运行以下命令生成报告:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="8617" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">当测试业务逻辑时，我们应该能够毫无困难地达到100%的覆盖率。请记住，完全覆盖并不一定意味着测试是有意义的，我们现在可以盲目自信地部署。但是如果你没有100%的话——他们肯定是缺乏的。</p><p id="799a" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">这是我们为Reddit应用程序编写的测试覆盖报告:</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff no"><img src="../Images/6fadd4983a6dc8435724081241dca0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ateJvn_BBkXp_WKS1GK7A.png"/></div></div></figure><p id="4507" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">我们的服务还需要一点改进。我们可以看到<a class="ae kn" href="https://github.com/wix/react-dataflow-example/blob/0ae091aab8f798cee5fe5d235218c5e6c0a6d3cb/src/services/reddit.js#L25" rel="noopener ugc nofollow" target="_blank">未测试的线</a>，它们看起来像是我们甚至可以选择忽略的边缘条件。</p><p id="89cf" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">因为我们只测试业务逻辑，所以我们可以使用以下命令将报告限制在相关目录— <code class="eh mr ms mt mu b">src/store</code>和<code class="eh mr ms mt mu b">src/services</code>:</p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><h2 id="509f" class="kv kw hu bd kx ky kz la lb lc ld le lf kk lg lh li kl lj lk ll km lm ln lo lp dt translated">发布演职员表场景</h2><p id="4545" class="pw-post-body-paragraph jj jk hu jm b jn lq jp jq jr lr jt ju kk ls jx jy kl lt kb kc km lu kf kg kh hn dt translated">写出好的测试是有艺术的。如果你写的测试太少，你将不会获得完全覆盖所提供的信心。如果你写得太多，维护它们会变得很麻烦，不会增加价值。</p><p id="0b35" class="pw-post-body-paragraph jj jk hu jm b jn jo jp jq jr js jt ju kk jw jx jy kl ka kb kc km ke kf kg kh hn dt translated">保证编写正确数量的测试的方法之一是TDD — <a class="ae kn" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>。我们是Wix中TDD的忠实粉丝，但是我们没有成功地用Redux创建一个感觉自然的TDD工作流。这最终导致了<a class="ae kn" href="https://github.com/wix/remx" rel="noopener ugc nofollow" target="_blank"> remx </a>的诞生——一个由<a class="ae kn" href="https://github.com/reactjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>教条启发而来的习惯用法<a class="ae kn" href="https://github.com/mobxjs/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>的有趣组合。很快会有更多。</p><div class="lw lx ly lz fq ab cb"><figure class="np iv nq nr ns nt nu paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="np iv nq nr ns nt nu paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="np iv nq nr ns nt nu paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jg jh ji"><p id="f922" class="jj jk jl jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><a class="ae kn" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kn" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kn" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae kn" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jj jk jl jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kn" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kn" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nv"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="nw mq l"/></div></figure></div></div>    
</body>
</html>