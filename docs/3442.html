<html>
<head>
<title>Yubl’s road to Serverless — Part 3, Ops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Yubl的无服务器之路—第三部分，运营</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/yubls-road-to-serverless-part-3-ops-6c82139bb7ee?source=collection_archive---------1-----------------------#2017-04-02">https://medium.com/hackernoon/yubls-road-to-serverless-part-3-ops-6c82139bb7ee?source=collection_archive---------1-----------------------#2017-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="6fa8" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">这条路到此为止</h1><p id="c8a4" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">第1部分:<a class="ae kn" rel="noopener" href="/@theburningmonk/yubls-road-to-serverless-part-1-overview-ca348370acde">概述</a></p><p id="211d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">第2部分:<a class="ae kn" rel="noopener" href="/@theburningmonk/yubls-road-to-serverless-part-2-testing-and-ci-cd-72b2e583fe64">测试和持续交付策略</a></p><p id="5c21" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">第三部:<a class="ae kn" href="https://hackernoon.com/yubls-road-to-serverless-part-3-ops-6c82139bb7ee" rel="noopener ugc nofollow" target="_blank"> ops </a></p><p id="cd1c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">第4部分:<a class="ae kn" href="https://hackernoon.com/yubls-road-to-serverless-part-4-building-a-scalable-push-notification-system-62b38924ed61" rel="noopener ugc nofollow" target="_blank">构建可伸缩的推送通知系统</a></p><p id="c2f6" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">第5部分:<a class="ae kn" href="https://hackernoon.com/yubls-road-to-serverless-part-5-building-better-recommendations-with-lambda-bigquery-and-1d74407f3b3a" rel="noopener ugc nofollow" target="_blank">建立一个更好的推荐系统</a></p><p id="5b47" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">一些人问我关于我们的监控、记录等策略。在<a class="ae kn" rel="noopener" href="/@theburningmonk/yubls-road-to-serverless-part-2-testing-and-ci-cd-72b2e583fe64">第2部分</a>之后，并且观看了<em class="kt"> Chris Swan </em>在<a class="ae kn" href="https://www.meetup.com/Serverless-London/" rel="noopener ugc nofollow" target="_blank">无服务器会议</a>上谈论<a class="ae kn" href="https://www.youtube.com/watch?v=hFhyQH0QkzI" rel="noopener ugc nofollow" target="_blank">“无服务器操作不是一个已解决的问题”</a>，这是我们谈论如何使用AWS Lambda实现ops的好时机。</p><h1 id="f30d" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">诺普斯。=无操作</h1><p id="414d" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">“无运营”的概念经常被提到无服务器技术(我自己也做过)，但这并不意味着你不再需要担心运营。</p><p id="1a18" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">对我来说，“ops”是与保持我的系统<strong class="jr hv">运行</strong>和<strong class="jr hv">在可接受的参数内执行</strong>相关的一切的总称，包括(但不限于)资源供应、配置管理、监控和随时处理任何现场问题。无论您的软件是在云中的虚拟机上运行，还是在本地硬件上运行，还是像小功能一样运行，保持系统正常运行的责任将始终存在。</p><p id="3501" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">在您的组织中，需要有人来履行这些职责。可能你有一个专门的运营团队，或者你的开发人员将分担这些责任。</p><p id="12d7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated"><em class="kt"> NoOps </em>对我来说，意味着<strong class="jr hv"> <em class="kt">在我的组织中没有Ops专业化</em></strong>——即。没有专门的运营团队——因为履行运营职责所需的<strong class="jr hv">技能和努力不足以证明这种专业化</strong>的必要性。作为一个组织，从财务角度来看，尽可能推迟这种专业化符合您的最佳利益，也许更重要的是，因为<a class="ae kn" href="http://www.melconway.com/Home/Conways_Law.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hv"> <em class="kt">康威定律</em> </strong> </a>告诉我们，拥有一个运营团队是最终获得一套运营程序/流程、工具和基础设施的可靠方式，其复杂性反过来将证明所述运营团队的存在是正确的。</p><p id="3fc2" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">在<em class="kt"> Yubl </em>，当我们<a class="ae kn" rel="noopener" href="/@theburningmonk/yubls-road-to-serverless-part-1-overview-ca348370acde">迁移到无服务器架构</a>时，我们的部署管道变得更加精简，我们的工具链变得更加简单，我们发现对专门运营团队的需求减少了，并且我们正在彻底解散我们的运营团队。</p><h1 id="550f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">记录</h1><p id="7058" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">每当你从你的<em class="kt"> Lambda </em>函数中写入<em class="kt"> stdout </em>时——例如，当你在你的nodejs代码中执行<em class="kt"> console.log </em>时——它会在<em class="kt"> CloudWatch Logs </em>中的函数的<em class="kt">日志组</em>中结束。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/8ec12f852b2518b53b22b6a8a22663e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*XyQIp1XlevmR9MsF."/></div></figure><h1 id="6535" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">集中伐木</h1><p id="0bc3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">然而，日志是不容易搜索的，一旦你有了一打函数，你会想把它们收集在一个中心位置。<em class="kt"> ELK </em>栈是目前集中日志记录的事实标准，你可以在<em class="kt"> EC2、</em>和<a class="ae kn" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank">T39】上运行你自己的<em class="kt"> ELK </em>栈，elastic.co</a>也提供了<a class="ae kn" href="https://www.elastic.co/cloud" rel="noopener ugc nofollow" target="_blank">托管版本的</a>elastic search和<em class="kt"> Kibana </em>。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/b098a25ae5cfbf5a2ecc4725476f12fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*BNgdMet0VrBAPCY7."/></div></figure><p id="3c72" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">要将您的日志从<em class="kt"> CloudWatch Logs </em>发送到<em class="kt"> ELK </em>，您可以将<em class="kt">日志组</em>订阅到负责发送日志的<strong class="jr hv"><em class="kt">cloud watch-Logs-to-ELK</em></strong>函数。</p><p id="f465" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">您可以通过AWS管理控制台手动订阅<em class="kt">日志组</em>。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/b99bb0ab55c72dfbf0907243e91f0a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*_9rVfCayruMNVCU2."/></div></figure><p id="77d7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">但是，您不希望每个人在每次创建新的<em class="kt"> Lambda </em>函数时都需要记住一个手动步骤。相反，最好在<em class="kt"> CloudWatch Events </em>中设置一个规则，以调用一个<strong class="jr hv"><em class="kt">subscribe-Log-group</em></strong><em class="kt">Lambda</em>函数来为新的<em class="kt">日志组</em>设置订阅。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ld"><img src="../Images/46a35c535706434086b087b38b95e09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rycWU-GU-zciRIqF."/></div></div></figure><p id="d0f6" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">请记住两件事:</p><ul class=""><li id="18dc" class="li lj hu jr b js ko jw kp ka lk ke ll ki lm km ln lo lp lq dt translated">lots服务在<em class="kt"> CloudWatch Logs </em>中创建日志，所以你会想通过名字过滤<em class="kt">日志组</em>，<em class="kt"> Lambda </em>函数日志有前缀<em class="kt"> /aws/lambda/ </em></li><li id="9595" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">不要为<em class="kt">cloud watch-logs-to-elk</em><strong class="jr hv"/>函数订阅<em class="kt">日志组</em>(或者您决定如何称呼它)，否则您会为<em class="kt"> cloudwatch-logs-to-elk </em>函数创建一个无限循环，其中它自己的日志将触发自身并生成更多日志，等等</li></ul><h1 id="35da" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">分布式跟踪</h1><p id="e615" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">将所有日志放在一个容易搜索的地方是很好的，但是随着您的架构扩展到越来越多的相互依赖的服务，您将需要<a class="ae kn" href="http://theburningmonk.com/2015/05/a-consistent-approach-to-track-correlation-ids-through-microservices/" rel="noopener ugc nofollow" target="_blank">关联来自不同服务的日志</a>以了解在一个用户请求期间发生的所有事件。</p><p id="1186" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">例如，当用户在<em class="kt"> Yubl </em>应用中创建新帖子时，我们会将帖子分发给用户的所有关注者。沿着这条流程会发生很多事情:</p><ol class=""><li id="ea04" class="li lj hu jr b js ko jw kp ka lk ke ll ki lm km lw lo lp lq dt translated">用户A的客户端调用遗留API来创建新帖子</li><li id="62c1" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">遗留API将一个<strong class="jr hv"> <em class="kt"> yubl发布的</em> </strong>事件触发到一个<em class="kt"> Kinesis </em>流中</li><li id="b5de" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">调用<strong class="jr hv"><em class="kt">distribute-yubl</em></strong>函数来处理该事件</li><li id="2725" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated"><em class="kt"> distribute-yubl </em>函数调用<strong class="jr hv"><em class="kt">relationship-API</em></strong>查找用户A的关注者</li><li id="1e24" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated"><em class="kt"> distribute-yubl </em>函数随后执行一些业务逻辑，将用户A的关注者分组，并为每一批向一个<em class="kt"> SNS </em>主题发送一条消息</li><li id="6848" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km lw lo lp lq dt translated">为每个<em class="kt"> SNS </em>消息调用<strong class="jr hv"> <em class="kt">添加到订阅源</em> </strong>功能，并将新帖子添加到每个关注者的订阅源</li></ol><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ld"><img src="../Images/ba6a60d5d8c6ec6caad57de45f24b468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dLwo9_OsPhEDzWza."/></div></div></figure><p id="d8e0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">如果用户A的一个追随者没有在提要中收到他的新帖子，那么问题可能出在许多不同的地方。为了使这种调查更容易，我们需要能够按时间顺序查看<strong class="jr hv">所有</strong>相关日志，这就是关联id(例如<em class="kt">初始请求id </em>、<em class="kt">用户id </em>、<em class="kt"> yubl-id </em>等。)进来吧。</p><p id="a715" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">因为初始用户请求的处理流经API调用、<em class="kt"> Kinesis </em>事件和<em class="kt"> SNS </em>消息，这意味着关联id也需要通过API调用、<em class="kt"> Kinesis </em>事件和<em class="kt"> SNS </em>消息来捕获和传递。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ld"><img src="../Images/16aa52d108c32e7326410c0278d1e1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EO2-nuwqpwli8hNb."/></div></div></figure><p id="f3e1" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们的方法是使用我们自己的客户端库，它将传递捕获的关联id。</p><h1 id="a870" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">捕获相关id</h1><p id="9049" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们所有的<em class="kt">λ</em>函数都是用包装器创建的，包装器用额外的优点包装您的处理程序代码，比如将相关标识捕获到<em class="kt">全局中。CONTEXT </em>对象(因为nodejs是单线程的，所以它可以工作)。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/71dbb9ed8885b154082f0b1756bb2763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*t7yIND90JvHgfkS4."/></div></figure><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/2d3f8dc58779e4fa1c0431cb6b958008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*-VJU4iz7y2x5SYsZ."/></div></figure><h1 id="131f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">转发相关标识</h1><p id="0a53" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们的HTTP客户端库是一个围绕<a class="ae kn" href="https://www.npmjs.com/package/superagent" rel="noopener ugc nofollow" target="_blank">超级代理</a> HTTP客户端的薄包装，并将捕获的相关id注入到传出的HTTP头中。</p><p id="5971" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们还有一个发布<em class="kt">驱动</em>事件的客户端库，可以将相关id注入到<a class="ae kn" href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html" rel="noopener ugc nofollow" target="_blank">记录有效载荷</a>中。</p><p id="b22e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">对于<em class="kt"> SNS，</em>您可以在<a class="ae kn" href="http://docs.aws.amazon.com/sns/latest/api/API_Publish.html" rel="noopener ugc nofollow" target="_blank">发布消息时将相关标识作为消息属性包含在内</a>。</p><h1 id="ab9d" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">齐普金和亚马逊x光</h1><p id="ed8c" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">从那时起，AWS已经发布了<a class="ae kn" href="https://aws.amazon.com/xray/" rel="noopener ugc nofollow" target="_blank"> x光</a>但是它还在预览中，所以我还没有机会看到它在实践中是如何工作的，并且在编写本报告的时候，它也不支持<em class="kt"> Lambda </em>。</p><p id="26e5" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">还有<a class="ae kn" href="http://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>，但是它需要您在<em class="kt"> EC2 </em>上运行额外的基础设施，并且虽然它有<a class="ae kn" href="http://zipkin.io/pages/existing_instrumentations" rel="noopener ugc nofollow" target="_blank">广泛的支持</a>用于在无服务器环境(您没有或者需要传统的web框架)中进行测试，但是我不太清楚。</p><h1 id="5029" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">监视</h1><p id="8410" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">您可以从<em class="kt"> CloudWatch </em>中获得许多基本的度量标准，比如调用计数、持续时间、错误等。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ld"><img src="../Images/f8811fa84f74f5e1c9694168cf9d90ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xrPIjFA4Px3RqJvL."/></div></div></figure><p id="0b8b" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">您也可以使用AWS SDK<a class="ae kn" href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutMetricData.html" rel="noopener ugc nofollow" target="_blank">向CloudWatch </a>发布自定义指标(如用户创建、后查看)。然而，由于这些都是HTTP调用，您必须意识到它们会为面向用户的函数增加延迟(例如。提供原料药的那些)。您可以通过以“一劳永逸”的方式发布延迟，和/或为您在请求结束时发布度量标准所花费的时间(比如说，最多50毫秒)编制预算，来减少额外的延迟。</p><p id="64c0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">因为你必须在函数调用期间做所有的事情，这迫使你做出权衡。</p><p id="3253" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">另一种方法是从<a class="ae kn" href="https://www.datadoghq.com/blog/monitoring-lambda-functions-datadog/" rel="noopener ugc nofollow" target="_blank"> Datadog的书</a>中吸取经验，使用特殊的日志消息并在事后处理它们。例如，如果您以如下所示的格式<em class="kt">监控|纪元时间戳|度量值|度量类型|度量名称</em>编写日志..</p><blockquote class="lx ly lz"><p id="d17c" class="jp jq kt jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">console . log(" MONITORING | 1489795335 | 27.4 | latency | user-API-latency ")；</p><p id="6301" class="jp jq kt jr b js ko ju jv jw kp jy jz ma kq kc kd mb kr kg kh mc ks kk kl km hn dt translated">console . log(" MONITORING | 1489795335 | 8 | count | yubls-served ")；</p></blockquote><p id="3fb2" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">然后您可以处理这些日志消息(参见上面的<em class="kt">日志</em>部分),并将它们作为度量发布。使用这种方法，您将会以牺牲指标的活性来换取更少的API延迟开销。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/c50854581871c55cec3ec10c98755c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*oFS1Cq3Dg7sgnLj6."/></div></figure><p id="5b0c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">当然，您可以在您的架构中采用这两种方法，并针对每种情况使用合适的方法:</p><ul class=""><li id="ccef" class="li lj hu jr b js ko jw kp ka lk ke ll ki lm km ln lo lp lq dt translated">对于关键路径上的功能(这将直接影响用户体验的延迟)，选择将度量作为特殊日志消息发布的方法；</li><li id="03c9" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">对于其他功能(cron作业、kinesis处理器等。)在调用持续时间不会显著影响用户体验的情况下，发布指标作为调用的一部分</li></ul><h1 id="5922" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">仪表板+警报</h1><p id="73e6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们在<em class="kt"> CloudWatch </em>和<em class="kt"> Graphite </em>中设置了许多仪表板(使用<a class="ae kn" href="https://www.hostedgraphite.com/" rel="noopener ugc nofollow" target="_blank"> hostedgraphite </a>，用于我们在EC2上运行的遗留堆栈)，它们显示在服务器团队区域附近的大型监视器上。我们还针对API延迟和错误计数等各种指标设置了警报，并设置了<a class="ae kn" href="https://www.opsgenie.com/" rel="noopener ugc nofollow" target="_blank"> opsgenie </a>来提醒那个星期值班的人。</p><h1 id="e50f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">考虑CloudWatch的替代品</h1><p id="e38b" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">虽然<em class="kt"> CloudWatch </em>是一个很好的、具有成本效益的监控解决方案(在某些情况下，这是从AWS服务(如<em class="kt"> Kinesis </em>和<em class="kt"> DynamoDB)中获取指标的唯一方式)</em>，但它也有缺点。</p><p id="b7c7" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">它的UI和定制与竞争对手如<a class="ae kn" href="https://graphiteapp.org/" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a><em class="kt"/><a class="ae kn" href="https://www.datadoghq.com/" rel="noopener ugc nofollow" target="_blank"><em class="kt">Datadog</em></a>和<a class="ae kn" href="https://www.sysdig.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> Sysdig </em> </a>不可同日而语，而且它缺乏你在<a class="ae kn" href="https://www.stackdriver.com/" rel="noopener ugc nofollow" target="_blank"><em class="kt">stack driver</em></a>和<a class="ae kn" href="https://www.wavefront.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">波前</em> </a>中找到的异常检测和寻找相关性等高级功能。</p><p id="f592" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">然而，最大的限制是<em class="kt"> CloudWatch </em>指标只能精确到分钟。这意味着您发现问题的<em class="kt">时间以分钟为单位(您需要一些数据点来区分需要人工干预的实际问题和临时问题)，因此您恢复</em>的<em class="kt">时间可能以几十分钟为单位。随着规模的扩大和不可用性成本的上升，您需要努力减少这两种时间，这可能意味着您需要比<em class="kt"> CloudWatch </em>能够提供的更精细的指标。</em></p><p id="b57f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">不使用<em class="kt"> CloudWatch </em>的另一个好理由是，<strong class="jr hv">你真的不希望你的监控系统在它监控的系统</strong>同时出现故障。多年来，我们经历了许多AWS中断，影响了我们在<em class="kt"> EC2 </em>上运行的核心系统以及<em class="kt"> CloudWatch </em>本身。当我们的系统出现故障并恢复时，我们无法看到发生了什么，以及它对我们的用户有何影响。</p><h1 id="ae1d" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">配置管理</h1><p id="ffc9" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">无论您使用何种方法进行配置管理，您都应该始终确保:</p><ul class=""><li id="ef9d" class="li lj hu jr b js ko jw kp ka lk ke ll ki lm km ln lo lp lq dt translated">敏感数据(如凭据、连接字符串)在传输中和静态时都是加密的</li><li id="936c" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">对敏感数据的访问应该基于角色</li><li id="07b0" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">您可以轻松快速地传播配置更改</li></ul><p id="335e" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">现在，你可以直接在你的<em class="kt"> Lambda </em>函数中添加<strong class="jr hv">环境变量</strong>，并用<em class="kt"> KMS对它们进行加密。</em></p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff ld"><img src="../Images/0dd667bdb2283bfeae2c6d600de1cbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BJP2Ncv7vVea483q."/></div></div></figure><p id="6de0" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">这是我们开始使用的方法，尽管在<em class="kt">无服务器</em>框架中使用了环境变量，因为那时它还不是<em class="kt"> Lambda </em>服务的一个特性。在我们有了十几个共享配置值的函数(例如MongoDB连接字符串)后，这种方法变得很麻烦，手动传播配置更改(通过更新和重新部署需要更新配置值的每个函数)既费力又慢得令人痛苦。</p><p id="c1ce" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">在我们发展的这个阶段，我们转向了集中式配置服务。在考虑了<a class="ae kn" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> consul </a>(我知道很多人都在用)之后，我们决定使用<em class="kt"> API网关</em>、<em class="kt"> Lambda </em>和<em class="kt"> DynamoDB </em>来编写我们自己的程序，因为:</p><ul class=""><li id="6d64" class="li lj hu jr b js ko jw kp ka lk ke ll ki lm km ln lo lp lq dt translated">我们不需要<em class="kt">执政官</em>的许多功能，只需要kv商店</li><li id="bee2" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">咨询是我们必须经营和管理的另一件事</li><li id="30b6" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">领事是我们必须学习的另一件事</li><li id="15b5" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">即使用2个节点运行<em class="kt"> consul </em>(你需要<em class="kt">一些</em>冗余用于生产)它仍然贵几个数量级</li></ul><p id="b5b6" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">敏感数据(由开发人员)使用<em class="kt"> KMS </em>进行加密，并以加密的形式存储在<em class="kt">配置API </em>中，当<em class="kt">λ</em>函数启动时，它会向<em class="kt">配置API </em>请求所需的配置值，并使用<em class="kt"> KMS </em>对加密的blob进行解密。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="fe ff md"><img src="../Images/579b46d056f3e636df54388a73de6a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bprTAyof-TV_sid_."/></div></div></figure><p id="7b84" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我们使用在<em class="kt"> api网关</em>中创建的API密钥来保护对<em class="kt">配置API </em>的访问，如果这些密钥遭到破坏，攻击者将能够通过此API更新配置值。您可以通过用<em class="kt"> IAM </em>角色保护POST端点来更进一步(我们最终没有实现),这将要求开发人员发出<a class="ae kn" href="http://amzn.to/2mxTOyH" rel="noopener ugc nofollow" target="_blank">签名请求</a>来更新配置值。</p><p id="8640" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">攻击者仍然可以检索加密形式的敏感数据，但他们将无法解密，因为<em class="kt"> KMS </em>也需要基于角色的访问。</p><h1 id="c53a" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">客户端库</h1><p id="cc3f" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">由于我们的大多数<em class="kt">λ</em>函数需要与<em class="kt">配置API </em>对话，我们投入了大量精力来使我们的客户端库真正健壮，并在缓存支持和定期轮询中烘焙，以从源代码刷新配置值。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/219362b6fa9d040c2c65d1f363d90d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*8ERvKL7B5tBdsihx."/></div></figure><p id="749f" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">所以，这就是它的乡亲们，希望你喜欢这个职位，不要检查该系列的其余部分。</p><p id="150c" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">AWS Lambda和其他无服务器技术的出现极大地简化了组织内部履行运营职责所需的技能和工具。然而，这种新范式也为现有工具链带来了新的限制和挑战，并要求我们提出新的答案。事情正在以令人难以置信的速度变化，我很高兴看到这个领域出现了什么新的实践和工具！</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="a17d" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">喜欢您正在阅读的内容，但需要更多帮助？我很乐意作为一名独立顾问提供服务，帮助您完成无服务器项目——架构审查、代码审查、构建概念验证，或者提供关于领先实践和工具的建议。</p><p id="e3d4" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我在<strong class="jr hv">伦敦，英国</strong>工作，目前是英国唯一的<a class="ae kn" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hv"> AWS无服务器英雄</strong> </a>。我有近<strong class="jr hv"> 10年<a class="ae kn" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank">的</a></strong>经验在AWS中大规模运行生产工作负载。我主要在英国开展业务，但我愿意出差一周以上。要了解我们如何能够合作，请在这里告诉我更多关于您试图解决的问题的信息。</p><p id="fa31" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">我还可以举办一个内部研讨会，帮助您的无服务器架构在T2投入生产。您可以在这里找到关于为期两天的研讨会<a class="ae kn" href="https://theburningmonk.com/workshops/" rel="noopener ugc nofollow" target="_blank">的更多信息，该研讨会将带您从AWS Lambda的基础一直到日志聚合、分发跟踪和安全最佳实践的通用操作模式。</a></p><p id="2399" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">如果你更喜欢按照自己的节奏学习，那么你也可以找到所有与我为曼宁制作的<a class="ae kn" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="jr hv">视频课程</strong> </a>相同的研讨会内容。我们将讨论的主题包括:</p><ul class=""><li id="27e5" class="li lj hu jr b js ko jw kp ka lk ke ll ki lm km ln lo lp lq dt translated">认证<em class="kt"> &amp; </em>授权与API网关<em class="kt"> &amp; </em>认知</li><li id="cb0f" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">本地测试<em class="kt"> &amp; </em>运行功能</li><li id="25ea" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">CI/CD</li><li id="3af2" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">日志聚合</li><li id="649a" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">监控最佳实践</li><li id="8c34" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">X射线分布式跟踪</li><li id="8d1b" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">跟踪相关id</li><li id="880c" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated"><em class="kt">性能&amp;成本</em>优化</li><li id="1377" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">错误处理</li><li id="916b" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">配置管理</li><li id="8f57" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">金丝雀部署</li><li id="5d40" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">VPC</li><li id="908b" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">安全</li><li id="a387" class="li lj hu jr b js lr jw ls ka lt ke lu ki lv km ln lo lp lq dt translated">Lambda、Kinesis和API网关的最佳实践</li></ul><p id="2e68" class="pw-post-body-paragraph jp jq hu jr b js ko ju jv jw kp jy jz ka kq kc kd ke kr kg kh ki ks kk kl km hn dt translated">代码<strong class="jr hv"> ytcui </strong>也可以获得<strong class="jr hv">票面价格的6折优惠</strong>。不过，这个数字只有在我们参加曼宁的早期访问计划(MEAP)时才有效。</p></div></div>    
</body>
</html>