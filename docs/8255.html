<html>
<head>
<title>Inspecting Docker images without pulling them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检查Docker图像，无需拉动它们</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/inspecting-docker-images-without-pulling-them-4de53d34a604?source=collection_archive---------1-----------------------#2017-11-26">https://medium.com/hackernoon/inspecting-docker-images-without-pulling-them-4de53d34a604?source=collection_archive---------1-----------------------#2017-11-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ceeecc9855ac61f216a650aec9c090e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjivBbS5QyKZO0wBKxg9QA.jpeg"/></div></div></figure><p id="071f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嘿，</p><p id="b6c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">根据你要构建的内容，可能会发生这样的情况，其中一部分涉及到从注册表中检查Docker映像，但是你负担不起。</p><p id="81c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">原来<a class="ae ka" href="https://docs.docker.com/registry/spec/api/" rel="noopener ugc nofollow" target="_blank">有一个API </a>可以让你做到这一点——无论是DockerHub还是私有注册表。</p><blockquote class="kb kc kd"><p id="d69d" class="jc jd ke je b jf jg jh ji jj jk jl jm kf jo jp jq kg js jt ju kh jw jx jy jz hn dt translated"><em class="hu">Docker Registry HTTP API是一种便于向Docker引擎分发图像的协议。它与docker registry的实例进行交互，docker registry是一种管理docker图像信息并支持其分发的服务。</em></p></blockquote><h1 id="3fa3" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">在本地测试</h1><p id="9787" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">本地测试的第一步是从<a class="ae ka" href="https://hub.docker.com/_/registry/" rel="noopener ugc nofollow" target="_blank">库/注册表</a>映像中创建一个注册表。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="adfb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">检查它是否确实在工作:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="f2ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让本地注册中心工作起来，我们可以直接从注册中心元数据转移到检查图像的脚本。下面的脚本包含了检索它所需要的全部内容，并且只依赖于两个依赖项:<code class="eh lr ls lt lu b">bash</code>和<a class="ae ka" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>。</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="0e17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ke"> ps。:需要注意的是，API调用需要指定它接受的内容类型(</em> <code class="eh lr ls lt lu b"><em class="ke">application/vnd.docker.distribution.manifest.v2+json</em></code> <em class="ke">)。</em></p><p id="98b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们来看看它是否真的有效:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="3560" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">酷，它确实有效！</p><p id="8755" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这对于不需要认证的注册中心来说是可行的，但它并不适合DockerHub。在那里检查公共图像时，我们需要在获取图像摘要之前执行一个额外的步骤——检索一个令牌。有了这样的令牌，我们就可以检查公共或私有图像。</p><p id="3e79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到脚本，让我们创建一个不同的脚本来处理这种情况—称之为<code class="eh lr ls lt lu b">get-public-image-config.sh</code>(这是为了简洁起见，使用一些其他编程语言，您可以放置一些条件并检测每种情况)。</p><p id="2414" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">额外的代码可以放在一个名为<code class="eh lr ls lt lu b">get_token</code>的方法中，该方法只将<code class="eh lr ls lt lu b">image</code>作为一个参数:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="18bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了令牌，就只需要在其他呼叫中使用它了。</p><p id="49e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们的目标是私有图像，我们需要稍微修改一下<code class="eh lr ls lt lu b">get_token</code>:在从<code class="eh lr ls lt lu b">auth.docker.io</code>获取令牌的调用中，我们需要使用DockerHub用户名和密码对(没有身份验证，我们只能访问公共图像)。为此，在调用中指定一个授权头(<code class="eh lr ls lt lu b">curl</code>中的<code class="eh lr ls lt lu b">--user</code>标志):</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="188b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，有了这个新的令牌，我们可以检索给定图像和标签的摘要(注意我们添加的额外的<code class="eh lr ls lt lu b">Authorization: Bearer $token</code>头):</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="488d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样我们就可以有一个完整的脚本来从DockerHub中检索公共图像(看看在<code class="eh lr ls lt lu b">main</code>中我们如何首先检索一个令牌，然后我们将这个令牌传递给下面的方法):</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="c1b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ke">注意。:同样，必须添加图片的全名(官方图片使用的是</em> <code class="eh lr ls lt lu b"><em class="ke">library</em></code> <em class="ke">资源库所以</em> <code class="eh lr ls lt lu b"><em class="ke">nginx</em></code> <em class="ke">应该简称为</em> <code class="eh lr ls lt lu b"><em class="ke">library/nginx</em></code> <em class="ke">)。</em></p><p id="9886" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了确保它能正常工作，对类似于<a class="ae ka" href="http://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank"> nginx </a>的图像运行它:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="7915" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你试图检索一个不是很新的图像(比如说，有两年了)，你会注意到我上面发布的脚本可能不起作用。</p><p id="fa55" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">原因是很久以前就被推送到docker注册表的图像不会使用第二版的V2清单。但是，即使在常规字符串中，它们仍然显示图像配置。</p><p id="bfa0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">贝娄是一个处理这种情况的脚本:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="a4fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在寻找差异，看看<code class="eh lr ls lt lu b">main</code>。本质上，我们放弃了检索一个<code class="eh lr ls lt lu b">digest</code>的想法，简单地选择“旧配置”。在旧的配置中，我们看到了列表中的第一个blob，它代表了最上层——包含所有信息的层。在那里，我们解析纯文本JSON，然后获取配置。</p><h1 id="ac13" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">结束语</h1><p id="e20d" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">与DockerHub或私有注册表交互并不困难，只是没有很好的文档记录。有了这些脚本，让它在您想要的任何语言上工作变得非常容易——只需添加一些检查，解析图像名称，您就可以开始工作了。</p><p id="7f20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是文章中提到的资源:</p><ul class=""><li id="f403" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated"><a class="ae ka" href="https://docs.docker.com/registry/spec/api/#content-digests" rel="noopener ugc nofollow" target="_blank"> Docker注册表API —内容摘要</a></li><li id="6f1a" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://docs.docker.com/registry/spec/api/#pulling-an-image-manifest" rel="noopener ugc nofollow" target="_blank"> Docker注册表API —提取图像清单</a></li><li id="1f7d" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://docs.docker.com/registry/spec/api/#pulling-a-layer" rel="noopener ugc nofollow" target="_blank"> Docker注册表API —拉一层</a></li><li id="9cff" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://gist.github.com/cirocosta/17ea17be7ac11594cb0f290b0a3ac0d1" rel="noopener ugc nofollow" target="_blank">要旨:这里提到的所有脚本</a></li></ul><p id="88b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我第一次在<a class="ae ka" href="https://ops.tips/blog/inspecting-docker-image-without-pull/" rel="noopener ugc nofollow" target="_blank"> ops.tips </a>上发表这篇文章后，我不能不提到人们建议的一些替代方案来结束这篇文章:</p><ul class=""><li id="5064" class="lv lw hu je b jf jg jj jk jn lx jr ly jv lz jz ma mb mc md dt translated"><a class="ae ka" href="https://github.com/GoogleCloudPlatform/container-diff" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleCloudPlatform/container-diff</a>—<em class="ke">“区分您的码头工人集装箱”</em>——这看起来很有趣，但是即使您可以在分析图像时为其指定<code class="eh lr ls lt lu b">remote://</code>，它看起来总是会拖动整个图像。也许我做错了什么？</li><li id="9e43" class="lv lw hu je b jf me jj mf jn mg jr mh jv mi jz ma mb mc md dt translated"><a class="ae ka" href="https://github.com/projectatomic/skopeo" rel="noopener ugc nofollow" target="_blank">https://github.com/projectatomic/skopeo</a>—<em class="ke">“与远程图像注册中心合作——检索信息、图像、签署内容”</em> —嗯，言出必行！我完全推荐的目的是检查图像或存储库，而不拉他们👍</li></ul><p id="7c1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">顺便说一下，如果你不想尝试Skopeo，在MacOS上从源代码构建它非常容易:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="b027" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，从Dockerhub检查图像或存储库只需要一个命令:</p><figure class="ll lm ln lo fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="146e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请注意，这里我为命令指定了<code class="eh lr ls lt lu b">--override-os</code>标志。原因是，否则它将尝试通过标记有<code class="eh lr ls lt lu b">OS=darwin</code>的摘要来检查图像或存储库过滤。如果您使用的是Linux，就不需要使用该标志。</p><p id="5519" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你不愿意用你最喜欢的语言来实现，而只想收集图像的配置，那么一定要检查Skopeo。</p><p id="a698" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我有错，或者有更简单的方法，请告诉我。</p><p id="b386" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">祝你玩得开心！</p><p id="635a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ke">精加工</em></p></div><div class="ab cl mj mk hc ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hn ho hp hq hr"><p id="0f29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ke">原为发表于</em><a class="ae ka" href="https://ops.tips/blog/inspecting-docker-image-without-pull/" rel="noopener ugc nofollow" target="_blank"><em class="ke">ops . tips</em></a>《T21》2017年11月26日。</p></div></div>    
</body>
</html>