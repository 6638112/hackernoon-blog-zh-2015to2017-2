<html>
<head>
<title>Using Normalizr to organize data in store. Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Normalizr组织存储中的数据。第二部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-normalizr-to-organize-data-in-store-part-2-d9646133b7df?source=collection_archive---------29-----------------------#2017-10-17">https://medium.com/hackernoon/using-normalizr-to-organize-data-in-store-part-2-d9646133b7df?source=collection_archive---------29-----------------------#2017-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/42c3b6b55ff46f3658bce87faa79a5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dtSqnHY9moWHz5ZFiH93Cw.jpeg"/></div></div></figure><p id="2cea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本文中，我想继续讨论在React-Redux应用程序中使用Normalizr的话题，并最终回答关于通用API的问题，这个问题在<a class="ae ka" href="https://hackernoon.com/using-normalizr-to-organize-data-in-stores-practical-guide-82fa061b60fb" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">上一篇文章</strong> </a>中有简要提及。</p><p id="1fb0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了提醒您那篇文章是关于什么的，<a class="ae ka" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Normalizr </strong> </a>是一个对由嵌套实体表示的数据进行规范化的实用程序(就像在服务器响应中一样)，这样它就可以被存储并在以后使用，就像在前端有一个数据库的副本一样(例如在Redux存储中)。在第1部分中，我们有一个用下图描述的实体关系的例子:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/f9009b6cb048e51e8c56e78db5fe6321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QO4TXjh5e7LtlC9YukeVTQ.png"/></div></div><figcaption class="kg kh fg fe ff ki kj bd b be z ek"><strong class="bd kk">Fig. 1. Entity-Relationship Diagram</strong></figcaption></figure><p id="0c17" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Normalizr有一个现成的反规范化API，但这可能还不够，因为它要求从服务器获取的数据与您希望在应用程序中使用的形状完全一致。例如，如果您想要对上一篇文章中的示例中的数据进行反规格化，以使一个<em class="kl">学生</em>实体包含<em class="kl">课程</em>，那么就必须完全按照这种方式获取数据——在<em class="kl">学生</em>中的课程。但是您可以在<em class="kl">教师</em>实体内获取课程，或者单独获取<em class="kl">课程</em>。在这种情况下，基本上有两种方法:你可以像在第一部分中描述的那样去规范化选择器中的实体，或者你可以定义你自己的API，我们将在这里尝试这样做。</p><p id="d48a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">API的主要困难在于，与后端不同，我们没有在前端描述所有模型及其关系。我们为Normalizr定义的模式也没有多大帮助，因为我们没有表示那里的实体之间的关系。事实上，前端对数据库中的实体和关系一无所知。因此，如果我们想在向商店请求的模型中包含一些东西，我们应该明确指出如何找到我们想要包含的东西。</p><p id="4172" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我认为能够以这种方式定义对商店的请求会很好:</p><pre class="kc kd ke kf fq km kn ko kp aw kq dt"><span id="047e" class="kr ks hu kn b fv kt ku l kv kw">const schema = {<br/>    modelName: 'student',<br/>    include: [<br/>        {<br/>            modelName: 'studentCourse',<br/>            isRelation: true,<br/>            include: [<br/>                {<br/>                    modelName: 'course',<br/>                    include: [<br/>                        {<br/>                            modelName: 'teacher',<br/>                            through: 'teacherCourse',<br/>                        }<br/>                    ]<br/>                },<br/>            ],<br/>        }<br/>    ]<br/>}</span></pre><p id="7f6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里，我们希望从商店中获取<em class="kl"> student </em>,并在其中嵌套include属性中指定的模型。它看起来非常类似于我们在第一部分中编写的从服务器获取数据的请求，只是增加了几个属性。在这里，我使用属性<em class="kl"> isRelation </em>来表示应该包含一个关系，并使用属性<em class="kl">到</em>来告诉API如何找到所需的实体。我们稍后会谈到这一点。现在我们可以尝试实现API了。它应该只有几个功能。第一个被称为<em class="kl">反规格化</em>，应该在使用API时直接调用:</p><pre class="kc kd ke kf fq km kn ko kp aw kq dt"><span id="78c1" class="kr ks hu kn b fv kt ku l kv kw">function denormalize (entity, models, schema) {<br/>    const {include} = schema;<br/> <br/>    const toInclude = include.map(i =&gt; {<br/>        const entities = getInclusion(entity, models, schema, i);<br/>        if (i.include) {<br/>            //if an inclusion has its own inclusion, call the function recursively <br/>            return entities.map(e =&gt; denormalize(e, models, i));<br/>        } else {<br/>            return entities;<br/>        }<br/>    });<br/> <br/>    const entityWithRelations = {...entity};<br/>    include.map((i, index) =&gt; <br/>        entityWithRelations[i.modelName] = toInclude[index]);<br/> <br/>    return entityWithRelations;<br/>}</span></pre><p id="060c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该函数应该将一个要反规范化的实体(<em class="kl">实体</em>)和来自商店的所有实体(<em class="kl">模型</em>)作为参数，以找到需要嵌套的实体。参数<em class="kl">模式</em>这里描述了如上定义的对存储的请求。它应该是这种类型的对象:</p><pre class="kc kd ke kf fq km kn ko kp aw kq dt"><span id="3868" class="kr ks hu kn b fv kt ku l kv kw">{<br/>    modelName, //name of a requested model<br/>    through, //name of a relation through which it should be found<br/>    include, //an array of schemas to be included in the requested model<br/>    isRelation, //true, if the requested model is a relation<br/>}</span></pre><p id="7338" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个函数应该从<em class="kl">模型</em>对象中获取要嵌套的实体。这里我利用了这样一个事实，即在一个关系中，相关模型的Id被存储为<em class="kl"> &lt;模型名称&gt; Id </em>:</p><pre class="kc kd ke kf fq km kn ko kp aw kq dt"><span id="39e2" class="kr ks hu kn b fv kt ku l kv kw">function getInclusion(entity, models, modelSchema, inclusionSchema) {<br/>    const {modelName, isRelation: isModelRelation} = modelSchema;<br/>    const {modelName:inclusionName, through, isRelation} = inclusionSchema;<br/> <br/>    if (isModelRelation) { //include into a relation<br/>       const foreignKey = `${inclusionName}Id`;<br/> <br/>               return values(models[inclusionName])<br/>        .filter(m =&gt; m.id === entity[foreignKey]);<br/>    } else { //include into an entity<br/>        if (isInclusionRelation) { //include a relation<br/>            const ownKey = `${modelName}Id`;<br/> <br/>            return values(models[inclusionName])<br/>                .filter(m =&gt; m[ownKey] === entity.id);<br/>        } else { //include an entity<br/>            const ownKey = `${modelName}Id`;<br/>            const foreignKey = `${inclusionName}Id`;<br/> <br/>            const relations = values(models[through])<br/>                .filter(r =&gt; r[ownKey] === entity.id);<br/>            return relations.map(r =&gt; models[inclusionName][r[foreignKey]]);<br/>        }<br/>    }<br/>}</span></pre><p id="8a38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们必须考虑三种情况:</p><p id="c000" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">案例一:</strong>将一个实体包含到一个关系中。在这种情况下，我们可以从我们想要包含的关系中找到所需的实体。</p><p id="944a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">案例2: </strong>将关系包含到实体中。我们必须走相反的路——我们通过实体id找到一个关系。</p><p id="c731" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">案例三:</strong>将一个实体包含到另一个实体中。在这种情况下，我们必须走更长的路。首先，我们通过实体id找到一个关系(就像在第二种情况下一样)，然后我们从关系中找到需要的实体并获取它们的id。</p><p id="c06b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">差不多就是这样了。还有一点要提的是:在建议的实现中，API的顶部应该有一个选择器。如果我们用<a class="ae ka" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">重新选择</strong> </a>，可能看起来是这样的:</p><pre class="kc kd ke kf fq km kn ko kp aw kq dt"><span id="2eed" class="kr ks hu kn b fv kt ku l kv kw">export const selectModels = (state) =&gt; state.models;<br/> <br/>export const find = (schema, ids) =&gt; createSelector (<br/>    selectModels,<br/>    (models) =&gt; {<br/>       const {modelName, include} = schema;<br/>       return !include <br/>           ? values(pick(models[modelName], ids)) <br/>           : values(pick(models[modelName], ids))<br/>               .map(v =&gt; denormalize(v, models, schema));<br/>    }<br/>);</span></pre><p id="0fdc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，<a class="ae ka" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">传奇</strong> </a>的实际要求归结为这样的形状:</p><pre class="kc kd ke kf fq km kn ko kp aw kq dt"><span id="ff0b" class="kr ks hu kn b fv kt ku l kv kw">const candidates = yield select(find({schema, ids}))</span></pre><p id="7388" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">方法<em class="kl">值</em>、<em class="kl">选择</em>和<em class="kl">克隆体</em> p此处来自<a class="ae ka" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> Lodash </strong> </a>。</p><p id="24f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个API由我测试过，但迄今为止从未在实际项目中使用过。虽然我想我一有机会就会去申请。这似乎很有用，因为我们不需要每次从存储中获取数据时都在选择器中编写相同的反规格化，而且可能更容易使用。无论如何，它现在更多的是一个建议，而不是一个经过验证的现成的解决方案。如果你对这个主题有其他想法，请随时评论这篇文章。</p></div><div class="ab cl kx ky hc kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hn ho hp hq hr"><div class="kc kd ke kf fq le"><a href="https://hackernoon.com/missing-part-of-redux-saga-experience-1d2d169ba765" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">Redux Saga体验中缺失的部分</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">Redux saga是应用程序和redux store之间的中间件，由redux actions处理。这意味着，它可以…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">hackernoon.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls ja le"/></div></div></a></div><div class="lt lu fm fo lv le"><a href="https://hackernoon.com/using-normalizr-to-organize-data-in-stores-practical-guide-82fa061b60fb" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">使用Normalizr组织商店中的数据——实用指南</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">在对Normalizr的工作结果应用一些简单的操作之后，我们得到了可以存储的数据</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">hackernoon.com</p></div></div><div class="ln l"><div class="lw l lp lq lr ln ls ja le"/></div></div></a></div><div class="lt lu fm fo lv le"><a href="https://hackernoon.com/usage-of-reselect-in-a-react-redux-application-fcdca05cc00d" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">在React-Redux应用程序中使用重选</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">为什么重选这么好</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">hackernoon.com</p></div></div><div class="ln l"><div class="lx l lp lq lr ln ls ja le"/></div></div></a></div><div class="lt lu fm fo lv le"><a href="https://hackernoon.com/how-to-stop-using-callbacks-and-start-living-1e5ed92e68e8" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab ej"><div class="lg ab lh cl cj li"><h2 class="bd hv fv z el lj eo ep lk er et ht dt translated">如何停止使用回调，开始生活</h2><div class="ll l"><h3 class="bd b fv z el lj eo ep lk er et ek translated">Javascript有两种处理异步任务的主要方式——回调和承诺。一般来说，承诺是…</h3></div><div class="lm l"><p class="bd b gc z el lj eo ep lk er et ek translated">hackernoon.com</p></div></div><div class="ln l"><div class="ly l lp lq lr ln ls ja le"/></div></div></a></div><p id="7595" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作者:<a class="ae ka" href="https://github.com/iPhaeton" rel="noopener ugc nofollow" target="_blank">伊利亚·博哈斯洛克</a></p></div></div>    
</body>
</html>