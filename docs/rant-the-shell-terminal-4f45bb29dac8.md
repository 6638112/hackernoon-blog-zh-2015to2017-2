# 咆哮:外壳和终端

> 原文：<https://medium.com/hackernoon/rant-the-shell-terminal-4f45bb29dac8>

声明:这是一个咆哮，但我的意思是这是一个有用的咆哮。这篇文章的重点是疯狂地对待事物，提供解决方案并探索它们。但是，我不会完全探究所提供的解决方案，因此它们可能显得不完整。我的意图不是过多地纠缠于它们的细节，而是刺激你的思维，试图动摇一些愚蠢的现状。

哦，它也没有看起来那么长。它有一些图片和一个可选的附录。会很有趣的，我保证！

# 标准流

想想你曾经写过的一个程序。因为您是一个真正的 Unixer，所以您接受从 stdin 输出到 stdout 的输入。有一个美丽的简单，这是进一步加强了管道。管道真的很美。不开玩笑。它们是一个令人惊奇的概念，从概念上讲它们是有意义的。不是很多东西都有这个。

那么让我们来看一个我们都知道并且喜爱的程序，curl:

```
% curl -vvv [http://api.icndb.com/jokes/random](http://api.icndb.com/jokes/random) | jq '.value.joke'
"Two wrongs don't make a right. Unless you're Chuck Norris. Then two wrongs make a roundhouse kick to the face."
```

curl 会热情地回复它所连接的 IP、请求和响应头，甚至进度条！最后，输出被传递给 jq，在那里它可以尽情地为我们带来我们的笑话。

保持这种想法。这里有些可疑。

curl 如何说明哪些数据(http 响应)要传递给管道，哪些信息对用户有意义(进度条等)？毕竟，jq 对请求的进度条不感兴趣，但是用户肯定感兴趣。

您很可能知道答案:stderr。stdout 是通过管道传递给命令的内容，而不是通过管道处理的 stderr 是由 shell 处理的。我们可以像这样显式地处理 stderr:

```
% curl -vvv [http://api.icndb.com/jokes/random](http://api.icndb.com/jokes/random) 2>/dev/null | jq '.value.joke'
"Chuck Norris can win at solitaire with only 18 cards."
```

按照惯例，2 是 stderr 的文件描述符，所以我们可以告诉我们的 shell 将它通过管道传输到某个文件。现在你看不到了。

您可能没有注意到这里的“错误”，尤其是如果您是一个经验丰富的 shell 用户。我劝你再读一遍前面的几段。

慢慢来。

## 搞什么

*我们究竟如何使用 stderr 作为约定来表示对用户有意义的输出呢？*它的字面意思是“标准*错误*，我们将其混编为*也就是*意思是“完全合法的输出”。

我试图想出一个合适的类比，但失败了，因为唯一合适的似乎是一家餐厅，它有一道名为“打我的脸”的菜，有时是美味的蛋奶酥，有时会让你脸上挨一拳。

这不仅仅是 stderr。stdin 也有问题:

```
% echo 4 | read -E
4
```

有一个程序接受来自 stdin 的输入，但也需要用户输入(“你确定”s，多步输入等)？太糟糕了，如果你是管道！

是的，你可以做像操纵 */dev/tty* 和朋友这样的事情。但这不是重点。你也可以使用诅咒，或者写一个 GUI 或者一个服务器，或者你可以直接去百慕大或者巴哈马群岛。

重点是 stdin、stdout 和 stderr 这三个神圣的组合有缺陷。他们混淆了两个不同的概念:*程序*交互和*用户*交互。我们希望管道用于数据的*程序化*操作，终端用于数据的*交互式*操作。

## 一个谦卑的提议

我们添加了另外两个流:userin 和 userout。管道在标准输入和标准输出之间绑定，用户输入和用户输出被绑定到终端。

![](img/4482ed5c7b479459a978ec76ac86ef45.png)

如果在你面前没有管道，你从 stdin 中读取，那么你是从终端，也就是 userin 中读取。如果你没有连接到终端，那么一切正常:阅读将永远受阻，写作没有任何效果。

以下是出现的一些复杂情况:

1.  我们应该如何将 userin 或 userout 重定向到其他管道？
2.  任何硬编码 fds 3 或 4 的东西都将被破坏。
3.  像 apt-get 这种你平时和 *yes* 结合的程序呢？如果他们接受来自 userin 的输入，考虑到列表中的第 1 点，那么 *yes* 将如何向其写入？坦白地说，我并不为他们感到遗憾。这应该是你传递给程序的一个标志。*是的*是一个 hack。
4.  然而，它确实提出了一个有效的编程决策:我们从 stdin 接受什么，从 userin 接受什么？没有直接的答案，但是如果你想一想，你可能已经有答案了:适合程序的结构化输入(比如 init 文件格式、html 或任何真正的结构化数据)来自 stdin。人工输入(如提示、查询等)来自用户。这还得考虑清楚。
5.  同样的问题也适用于 stdout 和 userout。我的直觉告诉我，这也不是一个那么复杂的决定:每当您觉得需要写入 stderr 时，就使用 userout，但这并不意味着出错。stdout 仍然是程序的输出，这一点没有改变。userout 是针对用户的显式输出*。*
6.  宋承宪呢？tmux 呢？
7.  这不仅仅是 libc 的变化，包括这些变量——终端需要合作。当您使用最新的 libc，但使用非 compat 终端时，会发生什么情况？那么 userin 和 userout 的语义是什么呢？

对这些问题的一个可能的解决方案是用一个 libc 函数给你 userin 和 userout 的句柄，这样它们就不是普通的全局变量了。这意味着它们是不可管道化的，至少没有特殊的语法是不行的。我对此很高兴。

我真的很喜欢这个想法，因为它增加了美感，同时又不破坏一切:程序仍然通过管道进行交互。而且是 opt-in——引入 userin 和 userout 之前写的程序不会有什么感觉，之后写的程序终于可以不把用户输出写到 stderr 并且知道可以从 userin 获取用户输入了。

# 对人类有意义的输出

不过，说够了。让我们继续讨论更有争议的话题。

现在是 2016 年，我仍然不能在我的终端上查看图像，或者看到语法高亮显示的文件，或者交互式地阅读 pdf 或绘制图表。这里的趋势是，你只能查看文本，而不能查看其他任何内容。

不一定要这样。写下这几行字我就开始害怕了，但是如果……如果……终端不仅限于文本呢？

![](img/1b5af673450a78978d2f252df9938b44.png)

未来就在这里，它的提示是一只 Nyan 猫。[术语](https://www.enlightenment.org/about-terminology)实现了我要求的所有功能，甚至更多。在上面的图片中，我输入*蒂卡特·3d-save.png*，一个图像出现了，所以我有什么可抱怨的，对吗？

问题在于标准。我们需要一种标准的方式来告诉我们的终端，嘿，这里的输出是一个图像或视频或 PostScript 或代码文件，请适当地格式化它。对于这种输出，一个终端实现一个*单独的命令*是不够好的。刚刚安装完 Ubuntu 作为他们的第一个 Linux 发行版的人应该能够启动 gnome-terminal 和一个猫图像。

记住，有了 userout 的加入，我们就有了一种方式来传达一条信息是给用户的，而不是给一个无关紧要的程序的，所以管道不是我们的一个大问题。

这不是在公园散步。我们再次面临一系列问题:

1.  我们如何交流输出类型？我怎么说我将要写一个 svg 或者 ogg 呢？
2.  我们如何写几个不同性质的东西？如果我有一个想播放的视频和一个要显示的 gif，我必须在开始写 gif 之前写完视频吗？
3.  支持哪些格式？列表实现是依赖的吗？有最低要求吗？是否有各种格式的规范实现列表？我们如何从中选择一个呢？
4.  控件呢？可以播放/暂停/静音/循环播放视频吗？这种支持是强制性的吗？最低要求的控制是什么？gif 有控件吗？
5.  那么*屏幕*和 *tmux* 呢？我连接并在我的 SuperAwesomeTerm *cat* 中连接一个图像，然后再连接 OldGrumpyTerm。不仅如此，我还决定 ssh 到我自己和连接。会发生什么？
6.  我们怎么关掉它？我实际上想看图像的二进制斑点。
7.  我是 Bob，我写了 BobTerm。你让我处理各种糟糕的事情！它曾经是简单的文本，但现在我必须知道如何输出随机的二进制格式！ [libvte](https://github.com/GNOME/vte) 甚至不支持这个(…还不支持)。
8.  这不是淘汰了 [*mplayer*](http://www.mplayerhq.hu/design7/news.html) 或者 [*feh*](https://feh.finalrewind.org/) 之类的东西吗？如果你能*猫*一个图像，那么你为什么需要 *feh* 来做呢？其实这不是给了终端太大的权力吗？

要解决的最简单的问题是发出文件格式的信号。对此我们有[的模拟动作](https://tools.ietf.org/html/rfc2045)。但这不是简单地写一个 mime 头后跟一个换行符的问题:如果我们不想发送 mime 头呢？如果我们不发送 mime 头，但是我们的输出看起来完全像一个 mime 头呢？

要处理 1 和 2，一个相对简单的方法是能够“分叉”一个流。c 伪代码:

```
FILE *userout = getuserout();
FILE *video_stream = forkstream(userout, “video/ogg”);
FILE *gif_tream = forkstream(userout, “image/gif”);
```

这将允许我们提供一个 mime 类型，并且可以无忧无虑地传递文件。比这更酷的是确保在写入 *gif_stream* 的同时写入 *video_stream* 不会导致冲突。这将很难实现，但我认为这是值得的。

令人烦恼的是，我们需要处理 3、4 和 5:不支持这些的终端怎么办？符合标准所需的最低格式数量是多少？多终端呢？

让我们做一个侧边栏，我认为这个侧边栏不仅与这一点或这种咆哮有关，而且与整个系列的咆哮有关。与其听我唠叨(我敢肯定你现在已经厌倦了)，我建议你听听比我聪明的人说些聪明的话。收听，直到他展示幻灯片“网站需要在每个浏览器中看起来完全一样吗？”也许更多。无论如何你应该看那个讲座。尼古拉斯·扎卡斯谈渐进式改进:

决定跳过还是只想看我说话？哦，你这个马屁精。以下是他所说的内容:

电视过去只显示黑白画面。然后，人们开始制造彩色电视，然后是高清电视。尽管它们的功能大相径庭，但它们都能够显示相同的内容:你插入它们，它们会向你显示《老友记》的第 100 次重播。

我还没有意识到的一个问题是，这是否给了终端太多的责任。我认为答案是否定的。终端应该支持它想要支持的确切数量，而不是超出的格式。但是它应该有这个基本的能力:程序应该能够向用户显示它们正在显示的内容。

这是可能的。我们已经在其他地方做了。我们只是忽略了终点站。

## 让我们停止忽视终端

鱼对你的壳做了惊人的事情。你有补全建议和颜色，还有这么多有意义的东西，以至于你想知道为什么还有人自愿使用 bash！？ [zsh](http://www.zsh.org/) 这是一个绝对的野兽，尽管它是 bash 的替代者，但仍然不是无处不在。

为什么？为什么你的发行版不附带 zsh 或者 fish？平心而论，有些人是这样认为的。我可以说 [Arch](http://archlinux.org) 的安装镜像带有一个配置好的 zsh。但这只是沧海一粟。Ubuntu 为什么不用 zsh 作为默认？为什么 CentOS 不给你鱼？

我不知道为什么我们要这样对待自己。你的屏幕太棒了。你可以用它看高清电影。但是当你在终端工作的时候，你可能连反 alised 字体都没有。

# 我们几乎拥有的东西

在写这篇文章的时候，我在谷歌上搜寻我的想法。不可能只有我一个人有添加标准流或者让 shell 不那么可怕的疯狂想法。事实上，出现了两个流行的项目: [FinalTerm](https://github.com/p-e-w/finalterm) 和 [TermKit](https://github.com/unconed/TermKit) 。

FinalTerm 触及了我在终结部分提出的一些观点。它也从来没有脱离过 alpha，而且它还遭受着[死亡](http://worldwidemann.com/finally-terminated/)的严重劣势。

无论是好是坏，TermKit 都让我吃惊。它击中了我的目标，然后更多。它也遭受同样的死亡症状。我不打算在这里涵盖一切，因为一篇文章发表在这个 reddit 页面上。

这些项目的失败并没有让我开心。FinalTerm 死于技术原因和常规的 OSS 原因(首席开发人员失去动力，谁来掌权？)，而 TermKit 的消亡既是因为技术原因，也是因为它试图在太短的时间内做太多的事情。这不是激励。

## 前进的道路

最让我难过的是，我就是不知道该拿这些想法怎么办。即使我实现了自己的 shell 和终端，这也是不够的——这些事情需要程序开发者的合作。有可能太晚了，我们会一直处于今天的状态。不是*不好是*不好。只是…呃。

呃。

我不知道接下来会发生什么。

# 更新:我接下来做了什么

我开始开发一款名为 plex 的[终端模拟器。](https://github.com/Zirak/plex)这不会是一个完整的技术演示，只会提供这里提出的想法的概念证明(希望如此)。

让我们看看它去哪里。

# 附录

但是等一下…你想去哪里？我们还没完成。这一部分详细描述了我无法解决的问题，或者我对这个问题的想法还不成熟，不重要。请随意跳过这一部分或整篇文章！做后一件事可能有点晚了。

## Shell 和 getopt 语法

让我们从一些新鲜的东西开始:向命令传递参数。

```
# It always starts out simple:
% ls something
% ls -l something
% ls --format=long
# wait, or was it
% ls --format long
# what about spaces
% ls ’01\. Serenity.mp4'
# and quotes
% ls “I’m a teapot”
% ls I\’m\ a\ teapot
# now you’ll want to kill yourself
% grep -EIrn ‘can \’you [\\doubt] \”w\\/hy’
```

我都不知道上一个例子对不对。我不忍心去经历它。

有很多方法可以向命令传递参数，其中一些必须以某种格式作为前缀。有些旗帜需要单破折号，有些旗帜需要双破折号。而且有很多不一致的逻辑:通常双破折号是一个多字母单词的前缀，但有时不是(例如: *mplayer -sub subtitle-path* ，还有 *mplayer - help* ，以及 *find* 是一个惯犯)。有时你可以在一个破折号中指定几个单字母的参数，例如 *grep* ，但是有时事情很奇怪，比如在 *head -20 path* 中，它将破折号后的数字参数视为表示 *-n* ，这样的例子不胜枚举。

不要让我开始 *find -exec* 和你必须经历的那种杂耍，更不要说将东西通过管道传递到 *sh -c* ！

哦，让我们不要忘记 *-帮助*，这有时工作，但有时不处理。想象一下，如果您的 shell 能够通过首先使用- *help* 运行程序并解析结果，为您提供智能提示和补全，从而智能地推断程序的参数，这将是多么强大。但是当然，使用输出根本不是标准化的，所以你可以忘记这一点。像 Python 的 *argparse* 或 Ruby 的 *optparse* 这样的内置参数解析器在某种程度上缓解了这个问题，但是你永远不会在 libc 中看到这样的东西。

还有就是变量展开是多么的怪异。这就像愚蠢的文本宏。我们应该得到更好的。

fish 在这个基础上有所改进，并且在这个过程中打破了很多东西(这有好有坏)。但我认为他们做得还不够。我想要一种合适的编程语言。

现在告诉我:你运行过 ipython 吗？

这是一次令人难以置信的经历。如果我是一个更勇敢的人，我会做。这更像是我们应得的。我们应该拥有一种合适的编程语言，拥有合理的管道和变量语法，以及真正的帮助。

我们永远也不会得到它。

## 输出格式

假设你有两个程序，它们想互相发送数据。为了使事情变得简单一点，您可以通过 shell 运行两者，这样就可以用管道将它们连接起来。最著名的例子就是 ps 和 grep:

```
% ps aux | grep dbus
```

这里又有问题了。我在第一个例子中用 curl 和 jq 巧妙地提到了这一点。程序不会互相发送结构化的、机器友好的数据。由于程序输出和人类输出之间的卷积，随着时间的推移，程序采用了它们自己的输出惯例，而你，这个输出消费者，只能靠你自己去理解这里发生了什么。
澄清一下: *ps* 输出不容易被机器读取和解析。我们的程序既需要知道我们正在接受来自 ps 的输入，也需要知道如何解析该输入。

这有好有坏。这很好，因为让你的程序输出自由格式的文本是令人惊奇的。这很糟糕，因为让程序输出自由格式的文本很难处理。

这不是一个容易解决的问题。大多数人说“开始传递对象而不是文本”，但这并不像看起来那么容易。程序间通信的语义是一个难题。这里有一些困难:

1.  改变这一切会打破一切。如果没有某种黑客解决方案，程序将需要知道昨天用 X 格式写输出的程序现在什么时候用 y 格式写输出。
2.  这需要改变*一切*。从 *ls* 到 *ssh* 到*安装*到*滑轨*。这种变化是巨大的，不会在一夜之间发生，这意味着采用将会落后。
3.  如果把结构化输出写到 stdout 会怎么样？你不希望用户看到一些难看的原始数据。
4.  你失去了很多自由。如果你被绑定到一个输出格式，你想表达的东西不包括在那里，你就只能用黑客了。
5.  说到这里，我还没有说我们将使用什么格式。 [JSON](http://json.org/) ？[消息包](http://msgpack.org/index.html)？[伯特](http://bert-rpc.org/)？ [Cap'n Proto](https://capnproto.org/) ？数百万人中还有其他人吗？我们如何选择其中一个？
    如果我们选择像 [Protobuf](https://developers.google.com/protocol-buffers/) 或[credit](https://thrift.apache.org/)这样的强类型解决方案，那么我们如何传达我们的模式呢？
    如果我们选择像[S-表达式](https://en.wikipedia.org/wiki/S-expression)这样的弱类型解决方案，我们会遇到验证和去串行化的问题，这将我们引向下一个问题:
6.  我们将如何实现序列化和反序列化？不同的语言对类型和值有着截然不同的概念。你如何编写一个非常大的整数，而又不破坏你旁边的程序，如果没有 BigDecimal 库，这个程序是无法处理的？日期和随机物体呢？你能发送函数吗？
7.  谁负责验证？当然，程序应该总是净化它们的输入，但是如果程序写出无效的输出会发生什么呢？贝壳给了它严厉的谈话吗？它会随之滚动吗？
8.  一旦选择了一种格式，我们就几乎永远被卡住了。新的语言必须实现这种序列化和反序列化。谁来写这些解析器呢？编写解析器很难。
9.  更不用说流了——我们的数据序列化格式需要是可流的，以便通过管道正确使用。
10.  这如何影响通过文件访问的众多 Linux APIs，比如在 *proc* 树中的那些？是否将 */proc/mount* 和 */proc/net/arp* 等进行更改，以便为您提供此序列化输出？这些是向后不兼容的主要来源。
11.  去他妈的，我不干了。

您可能会认为 Powershell 已经解决了这个问题。这就像说 Python 解决了这个问题——Powershell 只在特定平台上编写的程序之间进行通信，而不是在完全不同的平台之间进行通用的协调。Java 如何将日期对象传递给 Erlang？Io(使用原型继承)如何将对象发送给 C？

这是一个难题。一个今天无法解决的问题。对于一个比我聪明的人来说，说聪明的话，我建议你看乔·阿姆斯特朗的《如何以及为什么把事情安排在一起》:

[![](img/50ef4044ecd4e250b5d50f368b775d38.png)](http://bit.ly/HackernoonFB)[![](img/979d9a46439d5aebbdcdca574e21dc81.png)](https://goo.gl/k7XYbx)[![](img/2930ba6bd2c12218fdbbf7e02c8746ff.png)](https://goo.gl/4ofytp)

> [黑客中午](http://bit.ly/Hackernoon)是黑客如何开始他们的下午。我们是 [@AMI](http://bit.ly/atAMIatAMI) 家庭的一员。我们现在[接受投稿](http://bit.ly/hackernoonsubmission)，并乐意[讨论广告&赞助](mailto:partners@amipublications.com)机会。
> 
> 如果你喜欢这个故事，我们推荐你阅读我们的[最新科技故事](http://bit.ly/hackernoonlatestt)和[趋势科技故事](https://hackernoon.com/trending)。直到下一次，不要把世界的现实想当然！

[![](img/be0ca55ba73a573dce11effb2ee80d56.png)](https://goo.gl/Ahtev1)