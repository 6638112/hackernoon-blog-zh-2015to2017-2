<html>
<head>
<title>Coordinators: solving a problem you didn’t even know you had</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调者:解决一个你自己都不知道的问题</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/coordinators-solving-a-problem-you-didnt-even-know-you-had-e86623f15ebf?source=collection_archive---------5-----------------------#2017-01-30">https://medium.com/hackernoon/coordinators-solving-a-problem-you-didnt-even-know-you-had-e86623f15ebf?source=collection_archive---------5-----------------------#2017-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="84de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Square有一个大多数人不知道的图书馆。叫做<a class="ae jp" href="https://github.com/square/coordinators" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">协调人</strong> </a>。不是一个很有描述性的名字，在Github页面上也没有太多关于它的信息。</p><blockquote class="jq jr js"><p id="d133" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">Android 上的MVWhatever的简单生命周期。不开玩笑。</p></blockquote><p id="1c52" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">和一些示例代码:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="88fb" class="kg kh hu kc b fv ki kj l kk kl">class ExampleCoordinator extends Coordinator {<br/><br/>  @Override public void attach(View view) {<br/>    // Attach listeners, load state, whatever.<br/>  }<br/><br/>  @Override public void detach(View view) {<br/>    // Unbind listeners, save state, go nuts.<br/>  }<br/>}</span></pre><p id="55db" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在任何一个<code class="eh km kn ko kc b">View</code>上安装一个<code class="eh km kn ko kc b">Coordinator</code>:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="8c4f" class="kg kh hu kc b fv ki kj l kk kl">// Bind a Coordinator to a View.<br/>Coordinators.bind(view, coordinatorProvider);</span></pre><p id="2b74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它真的没有说它是什么，它做什么，以及它应该如何使用，对不对？</p><p id="9f95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了理解这个问题，我们必须了解一下自定义视图组的发展，因为这显然是下一步。</p><figure class="jx jy jz ka fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff kp"><img src="../Images/6e3b999f3b6b934b69d13d755ef84684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZL5rIv7GVl8V0s0RWH4Pg.jpeg"/></div></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">The evolution of displaying screens on Android</figcaption></figure><p id="c458" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jt">(如果活动/片段内容让你厌烦，请随意跳到精彩内容！)</em> </strong></p><h1 id="0977" class="lb kh hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">活动</h1><p id="89c0" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">每个人都知道活动。它们应该代表应用程序中的单个屏幕，并且根据您可以定义的特定意图过滤器，从技术上来说是一个“入口点”。</p><p id="eef8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了开始一个新的活动，你使用一个<code class="eh km kn ko kc b">Intent</code>，比如<code class="eh km kn ko kc b">activity.startActivity(activity, OtherActivity.class)</code>。</p><p id="1310" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们也不能嵌套。好吧，这并不完全正确，有<code class="eh km kn ko kc b">LocalActivityManager </code>和<code class="eh km kn ko kc b">ActivityGroup</code>，但自从API级以来，它们就被弃用了。我们还不如假装它们不存在。</p><p id="0c56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用<code class="eh km kn ko kc b">setContentView()</code>显示视图组的活动。人们通常认为它只显示一种特定类型的视图组，用它的布局id ( <code class="eh km kn ko kc b">R.layout.activity_main</code>)指定，然后如果你需要一个不同的屏幕，你只需要创建一个新的活动。</p><p id="3142" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后一旦你不得不把两个不同的屏幕放在同一个“页面”上，一切都乱套了。</p><h1 id="f350" class="lb kh hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">碎片</h1><figure class="jx jy jz ka fq kq fe ff paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="fe ff md"><img src="../Images/c8b82a100347e3238289d47ade5632db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxNGSqtWpVv5pRIdYpltRw.png"/></div></div><figcaption class="kx ky fg fe ff kz la bd b be z ek">Fragment/Activity lifecycle from <a class="ae jp" href="https://github.com/xxv/android-lifecycle" rel="noopener ugc nofollow" target="_blank">https://github.com/xxv/android-lifecycle</a> by Steve Pomeroy</figcaption></figure><p id="d1bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">片段是屏幕的“片段”。从技术上来说，它们显示一个定制的视图组，并由活动内部的<code class="eh km kn ko kc b">FragmentManager</code>管理。<code class="eh km kn ko kc b">Fragment</code>与<code class="eh km kn ko kc b">FragmentController</code>相关联，后者与“主机活动”相关联。</p><p id="18dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它们的设计主要是为了让你可以创建功能类似于“子活动”的“子屏幕”，继承所有重要的生命周期回调，比如<code class="eh km kn ko kc b">onCreate()</code>、<code class="eh km kn ko kc b">onActivityResult()</code>、<code class="eh km kn ko kc b">onPermissionResult()</code>，甚至更重要的<code class="eh km kn ko kc b">onSaveInstanceState(Bundle bundle);</code>。</p><p id="2d0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">他们还添加了自己的生命周期回调集，比如<code class="eh km kn ko kc b">onAttach()</code>、<code class="eh km kn ko kc b">onCreateView()</code>、<code class="eh km kn ko kc b">onActivityCreated()</code>、<code class="eh km kn ko kc b">onDestroyView()</code>和<code class="eh km kn ko kc b">onDetach()</code>。</p><p id="5b37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">可以用<code class="eh km kn ko kc b">getSupportFragmentManager().beginTransaction().add(R.id.container, new MyFragment()).commit();</code>创建片段。</p><p id="cd53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是大多数时候，你只需要访问你绑定的活动，<em class="jt"/>(通常用<code class="eh km kn ko kc b">onAttach()</code>完成)，以及对<code class="eh km kn ko kc b">onCreateView()</code>和<code class="eh km kn ko kc b">onDestroyView()</code>。</p><p id="2c5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在有了所有额外的复杂性，您可以通过使用片段的<code class="eh km kn ko kc b"><a class="ae jp" href="http://stackoverflow.com/a/13391359/2413303" rel="noopener ugc nofollow" target="_blank">getChildFragmentManager()</a></code><a class="ae jp" href="http://stackoverflow.com/a/13391359/2413303" rel="noopener ugc nofollow" target="_blank">将一个片段嵌套在一个片段中——这有时会导致混淆您是需要<code class="eh km kn ko kc b">getFragmentManager()</code>还是<code class="eh km kn ko kc b">getChildFragmentManager()</code>。</a></p><p id="5011" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有人可能会问，我们真的需要在活动的“子视图”中进行所有这些生命周期回调吗？</p><p id="ef6b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可能还会问，如果我们的活动中可以有“子视图”,那么为什么首先要创建多个活动呢？</p><h1 id="5358" class="lb kh hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">自定义视图组</h1><p id="762d" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">你知道活动和片段有什么共同点吗？它们显示了本来就可嵌套的<em class="jt">视图组</em>(<code class="eh km kn ko kc b">ViewGroup</code>和<code class="eh km kn ko kc b">View</code>)，它们都是用XML声明的，而且它们还有一些不错的回调。</p><p id="de8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你可以交换视图并得到相同的结果时，你会想为什么我们要首先使用它们来显示不同的屏幕。</p><figure class="jx jy jz ka fq kq"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="f039" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以扩展我们选择的视图组(<code class="eh km kn ko kc b">DrawerLayout</code>、<code class="eh km kn ko kc b">RelativeLayout</code>、<code class="eh km kn ko kc b">FrameLayout</code>、<code class="eh km kn ko kc b">LinearLayout</code>等)。)并使用我们选择的新的自定义视图组作为我们继承的对象。</p><p id="9853" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为我们使用布局膨胀通过<code class="eh km kn ko kc b">R.layout.custom_viewgroup</code>来膨胀自定义视图组，所以我们在<code class="eh km kn ko kc b">@OnClick</code>或<code class="eh km kn ko kc b">@BindView</code>中绑定的视图总是保证存在于<code class="eh km kn ko kc b">onFinishInflate()</code>中。</p><p id="9024" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以本质上，我们有类似于<code class="eh km kn ko kc b">onViewCreated()</code>、<code class="eh km kn ko kc b">onStart()</code>和<code class="eh km kn ko kc b">onStop()</code>的开箱即用回调。</p><p id="5c27" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代替<code class="eh km kn ko kc b">getSupportFragmentManager().beginTransaction().blah().commit()</code>，我们可以很容易地只选择<code class="eh km kn ko kc b">inflate</code>、<code class="eh km kn ko kc b">addView</code>或<code class="eh km kn ko kc b">removeView</code>。</p><p id="cc83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，即使我们已经制作了一个子屏幕，不再直接绑定到一堆不必要的回调，由神秘的<code class="eh km kn ko kc b">FragmentManagerImpl</code>编排——有一件事可能仍然会困扰我们。</p><p id="14d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">自定义视图组是通过通货膨胀创建的，它不是POJO。它有4个构造函数，需要扩展一个Android特定的类才能工作。</strong></p><h1 id="971f" class="lb kh hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">协调者</h1><p id="a032" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">为了摆脱定制视图组的限制，我们可以将所有“视图控制器”逻辑移出视图组本身，并将其作为标签附加。</p><p id="e1ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它是这样工作的:</p><figure class="jx jy jz ka fq kq"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="f41e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，您可以创建一个协调器，它几乎可以是任何POJO类，并且可以附加到任何自定义视图组，而不必扩展它。</p><p id="84d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有了协调器，您会收到对<code class="eh km kn ko kc b">attach(View)</code>和<code class="eh km kn ko kc b">detach(View)</code>的回调。代替原始视图组的<code class="eh km kn ko kc b">onAttachedToWindow()</code>和<code class="eh km kn ko kc b">onDetachedFromWindow()</code>回调。</p><p id="205d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，这个协调器实例通过存储为一个<code class="eh km kn ko kc b">tag</code>与ViewGroup相关联。这样就可以得到协调器为<code class="eh km kn ko kc b">Coordinator coordinator = (Coordinator)getTag(R.id.coordinator)</code>，当然是由<code class="eh km kn ko kc b">Coordinators</code>类提供的。</p><p id="ea51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这有什么好处？既然我们的类是一个POJO，我们实际上可以直接用Dagger注入这个类，而不必在组件中指定一个<code class="eh km kn ko kc b">void inject(MyCustomViewGroup group);</code>方法。</p><figure class="jx jy jz ka fq kq"><div class="bz el l di"><div class="me mf l"/></div></figure><p id="b0ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们获得了以下好处:</p><ul class=""><li id="fece" class="mg mh hu it b iu iv iy iz jc mi jg mj jk mk jo ml mm mn mo dt translated">我们不需要从视图组继承并定义4个构造函数来定义我们自己的“视图控制器”逻辑</li><li id="2e59" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">我们可以从匕首直接注射我们新做的协调器，不需要<code class="eh km kn ko kc b">void inject(MyCoordinator coordinator)</code></li><li id="d99a" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">我们不再需要一个<code class="eh km kn ko kc b">Context</code>来创建“视图”的实例，我们可以创建一个协调器来代替</li></ul><h1 id="bc16" class="lb kh hu bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx dt translated">结论</h1><p id="92ae" class="pw-post-body-paragraph ir is hu it b iu ly iw ix iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo hn dt translated">个人比较喜欢<code class="eh km kn ko kc b">Coordinators</code>走的方向。我不完全确定<code class="eh km kn ko kc b">onAttachedToWindow()</code>和<code class="eh km kn ko kc b">onDetachedFromWindow()</code>回调本身是否真的足够，但是在我们自己的类中定义一个自己的<code class="eh km kn ko kc b">attach(View)</code>和<code class="eh km kn ko kc b">detach(View)</code>方法，然后将它与一个<code class="eh km kn ko kc b">tag</code>关联起来也并不困难。</p><p id="b23f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为回报，我们得到了一个POJO视图控制器，它可以通过Dagger直接创建和注入，而不需要创建4个构造函数，也不需要在自己的XML文件中硬连接自定义视图组。</p><p id="ec8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果导航逻辑从活动/片段中分离出来，并被移动到表示层，那么新的协调器方法会工作得特别好。这使得代码更加简洁——毕竟，应用程序状态转换不是视图应该管理的事情。</p><p id="09b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我带着协调员在<a class="ae jp" href="https://github.com/Zhuinden/simple-stack/tree/master/simple-stack-example-mvp" rel="noopener ugc nofollow" target="_blank">https://github . com/zhuin den/simple-stack/tree/master/simple-stack-example-MVP</a>进行了一次试驾。</p><div class="jx jy jz ka fq ab cb"><figure class="mu kq mv mw mx my mz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mu kq mv mw mx my mz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mu kq mv mw mx my mz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jq jr js"><p id="f922" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jx jy jz ka fq kq"><div class="bz el l di"><div class="na mf l"/></div></figure></div></div>    
</body>
</html>