<html>
<head>
<title>Grasp “By Value” and “By Reference” in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript中的“按值”和“按引用”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/grasp-by-value-and-by-reference-in-javascript-7ed75efa1293?source=collection_archive---------2-----------------------#2017-06-04">https://medium.com/hackernoon/grasp-by-value-and-by-reference-in-javascript-7ed75efa1293?source=collection_archive---------2-----------------------#2017-06-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e9a8" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">并了解为什么知道其中的区别是至关重要的</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/10ff2f130148bd5944194f43d9be5c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sT1WaL6NwK0a-tauBeRXzA.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a></figcaption></figure><p id="c6a2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">JavaScript 是一种面向对象的语言:这意味着JavaScript中的大多数东西都是<strong class="kc hv">对象</strong>。例如，函数就是对象。唯一不是对象的元素是<strong class="kc hv">原始数据类型:</strong> <em class="kw">字符串</em>，<em class="kw">数字</em>，<em class="kw">布尔</em>，<em class="kw">空值</em>和<em class="kw">未定义。</em>这些原始数据类型也是<em class="kw"> </em> <strong class="kc hv">不可变的</strong>，这意味着一旦创建就不能修改。</p><p id="a6e2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">两者的区别之一是原始数据类型通过值传递<em class="kw">，对象通过引用</em>传递<em class="kw">。</em></p><blockquote class="kx"><p id="5e14" class="ky kz hu bd la lb lc ld le lf lg kv ek translated">原始数据类型通过值传递<em class="lh">，对象通过引用传递<em class="lh">。</em></em></p></blockquote><p id="fc78" class="pw-post-body-paragraph ka kb hu kc b kd li iv kf kg lj iy ki kj lk kl km kn ll kp kq kr lm kt ku kv hn dt translated">这是什么意思？你可以这样想:</p><ul class=""><li id="f383" class="ln lo hu kc b kd ke kg kh kj lp kn lq kr lr kv ls lt lu lv dt translated"><strong class="kc hv">按值意味着创建原始</strong>的副本。把它想象成双胞胎:他们生来一模一样，但是第一个双胞胎没有失去一条腿，而第二个双胞胎在战争中失去了一条腿。</li><li id="5710" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated"><strong class="kc hv">引用是指为原</strong>创建一个别名。当你妈妈叫你“南瓜派”的时候，虽然你的名字是玛格丽特，但这并不会突然产生一个克隆的你:你仍然是一个，但你可以被这两个截然不同的名字所称呼。</li></ul><p id="c063" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们看看原语和对象是如何表现的，首先当我们用<a class="ae jz" href="https://hackernoon.com/tagged/assiognment" rel="noopener ugc nofollow" target="_blank">赋值</a>操作符(=)给它们赋值时，其次当我们将它们作为参数传递给函数时。</p><h1 id="6788" class="mb mc hu bd md me mf mg mh mi mj mk ml ja mm jb mn jd mo je mp jg mq jh mr ms dt translated">1.用=运算符为基本对象赋值</h1><h2 id="58e8" class="mt mc hu bd md mu mv mw mh mx my mz ml kj na nb mn kn nc nd mp kr ne nf mr ng dt translated">对于原始数据类型，=运算符按值工作</h2><p id="bceb" class="pw-post-body-paragraph ka kb hu kc b kd nh iv kf kg ni iy ki kj nj kl km kn nk kp kq kr nl kt ku kv hn dt translated">考虑以下代码:</p><pre class="jk jl jm jn fq nm nn no np aw nq dt"><span id="7109" class="mt mc hu nn b fv nr ns l nt nu">var name = "Carlos";<br/>var firstName = name;<br/>name = "Carla";</span><span id="7fea" class="mt mc hu nn b fv nv ns l nt nu">console.log(name); // "Carla"<br/>console.log(firstName); // "Carlos"</span></pre><p id="0e83" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">→ <a class="ae jz" href="https://jsbin.com/naloqarajo/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="b4f8" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">结果非常简单:这就是=运算符按值工作。这里实际发生的事情可以简化如下:</p><ul class=""><li id="2636" class="ln lo hu kc b kd ke kg kh kj lp kn lq kr lr kv ls lt lu lv dt translated">变量<code class="eh nw nx ny nn b">name</code>被创建并被赋予值“Carlos”。JavaScript为它分配一个内存点。</li><li id="b71d" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated">变量<code class="eh nw nx ny nn b">firstName</code>被创建并被赋予<code class="eh nw nx ny nn b">name</code>值的<em class="kw">副本</em>。<code class="eh nw nx ny nn b">firstName</code>有自己的内存点，独立于<code class="eh nw nx ny nn b">name</code>。这时在代码中，<code class="eh nw nx ny nn b">firstName</code>也有一个值“卡洛斯”。</li><li id="9882" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated">然后我们将<code class="eh nw nx ny nn b">name</code>的值改为“Carla”。但是<code class="eh nw nx ny nn b">firstName</code>仍然保持其原始值，因为它位于不同的内存点。</li></ul><blockquote class="kx"><p id="7ae2" class="ky kz hu bd la lb nz oa ob oc od kv ek translated">当处理原语时，运算符=创建原始变量的副本。这就是价值的含义。</p></blockquote><h2 id="e0eb" class="mt mc hu bd md mu oe mw mh mx of mz ml kj og nb mn kn oh nd mp kr oi nf mr ng dt translated">对于对象，=运算符通过引用工作</h2><p id="52db" class="pw-post-body-paragraph ka kb hu kc b kd nh iv kf kg ni iy ki kj nj kl km kn nk kp kq kr nl kt ku kv hn dt translated">考虑以下代码:</p><pre class="jk jl jm jn fq nm nn no np aw nq dt"><span id="fa10" class="mt mc hu nn b fv nr ns l nt nu">var myName = {<br/>  firstName: "Carlos"<br/>};<br/>var identity = myName;<br/>myName.firstName = "Carla";</span><span id="a4c8" class="mt mc hu nn b fv nv ns l nt nu">console.log(myName.firstName); // "Carla"<br/>console.log(identity.firstName); // "Carla"</span></pre><p id="051c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">→ <a class="ae jz" href="https://jsbin.com/fujidanoma/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="4cea" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里，包含对象的变量的输出是相同的。发生这种情况是因为，当处理对象时，=操作符通过引用工作。实际发生的情况可以描述如下:</p><ul class=""><li id="85dd" class="ln lo hu kc b kd ke kg kh kj lp kn lq kr lr kv ls lt lu lv dt translated">变量<code class="eh nw nx ny nn b">myName</code>被创建，并被赋予一个具有属性<code class="eh nw nx ny nn b">firstName</code>的对象的值。<code class="eh nw nx ny nn b">firstName</code>有“卡洛斯”的价值。JavaScript为<code class="eh nw nx ny nn b">myName</code>和它包含的对象分配一个内存点。</li><li id="47a1" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated">变量<code class="eh nw nx ny nn b">identity</code>被创建并指向<code class="eh nw nx ny nn b">myName</code>。<em class="kw">没有专用的内存空间给</em> <code class="eh nw nx ny nn b"><em class="kw">identity</em></code> <em class="kw">的值</em>。它只<em class="kw">指向</em>的<code class="eh nw nx ny nn b">myName</code>的值。</li><li id="437f" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated">我们将<code class="eh nw nx ny nn b">myName</code>的<code class="eh nw nx ny nn b">firstName</code>属性的值改为“Carla”而不是“Carlos”。</li></ul><p id="a603" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当我们记录<code class="eh nw nx ny nn b">myName.firstName</code>时，它显示新的值，这非常简单。但是当我们记录<code class="eh nw nx ny nn b">identity.firstName</code>时，它的<em class="kw">也会显示<code class="eh nw nx ny nn b">myName.firstName</code>的新值“Carla”。这是因为只有<code class="eh nw nx ny nn b">identity.firstName</code>指向</em> <code class="eh nw nx ny nn b">myName.firstName</code>在内存中的位置。</p><blockquote class="kx"><p id="a569" class="ky kz hu bd la lb lc ld le lf lg kv ek translated">处理对象时，运算符=会创建原始对象的别名，而不会创建新对象。这就是“通过引用”的意思。</p></blockquote><h1 id="2569" class="mb mc hu bd md me mf mg mh mi mj mk ml ja oj jb mn jd ok je mp jg ol jh mr ms dt translated">2.将原语和对象传递给函数</h1><h2 id="54f3" class="mt mc hu bd md mu mv mw mh mx my mz ml kj na nb mn kn nc nd mp kr ne nf mr ng dt translated">原始数据类型通过值传递给函数</h2><p id="2f00" class="pw-post-body-paragraph ka kb hu kc b kd nh iv kf kg ni iy ki kj nj kl km kn nk kp kq kr nl kt ku kv hn dt translated">如果在函数内部更改原始数据类型的值，这种更改不会影响外部作用域中的变量:</p><pre class="jk jl jm jn fq nm nn no np aw nq dt"><span id="3ee9" class="mt mc hu nn b fv nr ns l nt nu">var myName = "Carlos";<br/>function myNameIs(aName){<br/>  aName = "Carla";<br/>}<br/>myNameIs(myName);</span><span id="1ddc" class="mt mc hu nn b fv nv ns l nt nu">console.log(myName); // "Carlos"</span></pre><p id="9cf4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">→ <a class="ae jz" href="https://jsbin.com/jiciyunaso/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="57fb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">即使我们在函数<code class="eh nw nx ny nn b">myNameIs</code>内部改变<code class="eh nw nx ny nn b">myName</code>变量，当我们在调用函数后打印它时，它仍然有值“Carlos”。这是因为当传递基本类型时，它们是通过值传递的。</p><p id="dbd5" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们传递的是<code class="eh nw nx ny nn b">myName</code>的副本:你在函数体内对<code class="eh nw nx ny nn b">myName</code>做的任何事情都不会影响全局范围内的<code class="eh nw nx ny nn b">myName</code>变量，因为你传递的是<code class="eh nw nx ny nn b">myName</code>的副本，而不是原始的<code class="eh nw nx ny nn b">myName</code>变量。</p><h2 id="34bf" class="mt mc hu bd md mu mv mw mh mx my mz ml kj na nb mn kn nc nd mp kr ne nf mr ng dt translated">对象通过引用传递给函数</h2><p id="9135" class="pw-post-body-paragraph ka kb hu kc b kd nh iv kf kg ni iy ki kj nj kl km kn nk kp kq kr nl kt ku kv hn dt translated">当你通过引用传递东西时，你传递的是指向其他东西的东西，而不是对象的副本。因此，由于JavaScript通过引用传递对象，当您在函数中更改该对象的属性时，更改将反映在外部范围中:</p><pre class="jk jl jm jn fq nm nn no np aw nq dt"><span id="f9fd" class="mt mc hu nn b fv nr ns l nt nu">var myName = {};<br/>function myNameIs(aName){<br/>  aName.firstName = "Carla";<br/>}<br/>myNameIs(myName);</span><span id="5784" class="mt mc hu nn b fv nv ns l nt nu">console.log(myName); // Object {firstName: "Carla"}</span></pre><p id="ef45" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">→ <a class="ae jz" href="https://jsbin.com/weqamuwewu/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="5d10" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，如果我在调用函数<code class="eh nw nx ny nn b">myNameIs</code>后记录<code class="eh nw nx ny nn b">myName</code>变量，它会记录一个键为<code class="eh nw nx ny nn b">firstName</code>的对象，其值等于“Carla”。当我们将对象传递给函数时，它在全局范围内发生了变化。</p><p id="3020" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这是因为当您将一个对象传递给函数时，您传递的不是一个副本。你正在传递一个<em class="kw">将</em>指向<code class="eh nw nx ny nn b">myName</code>对象的东西。因此，当您在函数中更改该对象的属性时，您正在更改外部作用域中该对象的属性。</p><p id="5b31" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是有一点你应该注意:</p><pre class="jk jl jm jn fq nm nn no np aw nq dt"><span id="72e2" class="mt mc hu nn b fv nr ns l nt nu">var myName = {<br/>  firstName: "Carla"<br/>};</span><span id="e452" class="mt mc hu nn b fv nv ns l nt nu">function myNameIs(aName){<br/>  aName = {<br/>    nickName: "Carlita"<br/>  };<br/>}</span><span id="8782" class="mt mc hu nn b fv nv ns l nt nu">myNameIs(myName);<br/>console.log(myName); // Object {firstName: "Carla"}</span></pre><p id="a583" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">→ <a class="ae jz" href="https://jsbin.com/zifayokotu/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p><p id="73c3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">这里它打印了外部作用域中变量<code class="eh nw nx ny nn b">myName</code>的值，这次没有给对象添加一个<code class="eh nw nx ny nn b">nickName</code>属性。这是为什么呢？如果你仔细观察，我们在函数中所做的是试图给<code class="eh nw nx ny nn b">myName</code>对象重新赋值。</p><p id="68a3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是你不能把<code class="eh nw nx ny nn b">myName</code> <em class="kw">指向</em>的东西，你只能把<code class="eh nw nx ny nn b">myName</code>的一个<em class="kw">属性</em>改成别的，就像这样:</p><pre class="jk jl jm jn fq nm nn no np aw nq dt"><span id="74ca" class="mt mc hu nn b fv nr ns l nt nu">var myName = {<br/>  firstName: "Carla"<br/>};</span><span id="da89" class="mt mc hu nn b fv nv ns l nt nu">function myNameIs(aName){<br/>  aName.nickName = "Carlita";<br/>}</span><span id="ec26" class="mt mc hu nn b fv nv ns l nt nu">myNameIs(myName);<br/>console.log(myName); // Object {firstName: "Carla", nickName: "Carlita"}</span></pre><p id="27dd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">→ <a class="ae jz" href="https://jsbin.com/xicuyuneho/edit?js,console" rel="noopener ugc nofollow" target="_blank">自己试试</a></p></div><div class="ab cl om on hc oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="hn ho hp hq hr"><p id="6c6e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">想了解更多？查看我关于JavaScript基础的其他文章:</p><ul class=""><li id="1dcd" class="ln lo hu kc b kd ke kg kh kj lp kn lq kr lr kv ls lt lu lv dt translated"><a class="ae jz" href="https://hackernoon.com/hoisting-in-javascript-a-quick-guide-cc4d9597bbd7" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">JavaScript中的吊装:快速指南</strong> </a></li><li id="f056" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated"><a class="ae jz" href="https://hackernoon.com/understand-javascript-variable-scope-with-ease-221a6d41dc43" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">轻松理解JavaScript变量作用域</strong> </a></li><li id="b837" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated"><a class="ae jz" href="https://hackernoon.com/get-your-head-around-this-73c23653b102" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv"/></a></li><li id="8901" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated"><a class="ae jz" href="https://hackernoon.com/how-to-use-javascript-closures-with-confidence-85cd1f841a6b" rel="noopener ugc nofollow" target="_blank"> <strong class="kc hv">如何自信地使用JavaScript闭包</strong> </a></li><li id="c490" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated"><a class="ae jz" href="https://hackernoon.com/a-quick-handbook-for-dates-in-javascript-7b71d0ef8e53" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">JavaScript中的日期快速手册</strong> </a></li><li id="2784" class="ln lo hu kc b kd lw kg lx kj ly kn lz kr ma kv ls lt lu lv dt translated"><a class="ae jz" rel="noopener" href="/@lenafaure/work-with-javascript-arrays-like-a-boss-97207a042e42"> <strong class="kc hv">像老板一样使用JavaScript数组</strong> </a></li></ul></div><div class="ab cl om on hc oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="hn ho hp hq hr"><p id="4729" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我希望你喜欢这个“按值”和“按引用”的解释。</p><p id="26f2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">请随意评论并喜欢这篇文章，以便其他人可以在Medium上轻松找到它！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="http://eepurl.com/dvio9L"><div class="fe ff ot"><img src="../Images/3183c9cfe7a8644bc0a59d2e3e57fa27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*td_Zl-oX7vl2kIsoldqcLA.png"/></div></a></figure><div class="jk jl jm jn fq ab cb"><figure class="ou jo ov ow ox oy oz paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ou jo ov ow ox oy oz paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ou jo ov ow ox oy oz paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="pa pb pc"><p id="f922" class="ka kb kw kc b kd ke iv kf kg kh iy ki pd kk kl km pe ko kp kq pf ks kt ku kv hn dt translated"><a class="ae jz" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae jz" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jz" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ka kb kw kc b kd ke iv kf kg kh iy ki pd kk kl km pe ko kp kq pf ks kt ku kv hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jz" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jz" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pg"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ph pi l"/></div></figure></div></div>    
</body>
</html>