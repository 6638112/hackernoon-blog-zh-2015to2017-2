<html>
<head>
<title>Part 2 : Picking Kotlin for Android — Killing Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:为Android选择kot Lin——杀死特性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/part-2-picking-kotlin-for-android-killing-features-a6a643c8dc8d?source=collection_archive---------5-----------------------#2017-04-08">https://medium.com/hackernoon/part-2-picking-kotlin-for-android-killing-features-a6a643c8dc8d?source=collection_archive---------5-----------------------#2017-04-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="f805" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">更有生产力&amp;编写有表现力的代码&amp;构建更好的架构</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/735e4e61141b54f386f3c91c7bfdac07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcsC49oEgeDK8pacA1YLbw.png"/></div></div></figure><p id="9cd1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">欢迎来到第2部分，这一部分由许多gist (Java vs Kotlin示例代码)组成，作为一个展示案例。许多有用的评论/论点都写在要点里。为了有更好的阅读体验，我会推荐你使用大屏幕继续阅读这篇文章。</p><h1 id="d40b" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">编译时空安全</h1><p id="84d0" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">与Java相比，Kotlin中的“编译时Null-Safe”是一个重大的根本性改进。它解决了Java中臭名昭著的空问题，并提供了一种非常高效的方法来编写高质量和无NPE的代码。</p><p id="49de" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在Java中，默认情况下，你创建的每一个对象都会被赋值为null。也被称为“<a class="ae lo" href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions" rel="noopener ugc nofollow" target="_blank">亿元错误</a>”。Java、第三方库甚至IDE中都出现了许多“变通方法”，例如:</p><ul class=""><li id="f1c4" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq lu lv lw lx dt translated"><code class="eh ly lz ma mb b">@NotNull</code></li><li id="efef" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated"><code class="eh ly lz ma mb b">Objects.requireNonNull(..)</code></li><li id="fdc0" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated"><code class="eh ly lz ma mb b">Optional.ofNullable(..)</code></li></ul><p id="3f04" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仔细看看下面的Java示例，它展示了编写相同功能的四种不同方法。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="e644" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第一个函数<code class="eh ly lz ma mb b">doRiskyThing</code>是不带<code class="eh ly lz ma mb b">@NotNull</code>注释的。该函数不是自文档化的，您必须采取一些变通方法来改进它。</p><p id="590f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">如果我们只关注函数声明</strong> <code class="eh ly lz ma mb b">public String doRiskyThing(String riskyString)</code> <strong class="jx hv">而不关注实现细节</strong>，开发者将不会得到任何关于输入参数的信息。Java开发人员可能会遇到这样的问题:</p><ul class=""><li id="837b" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq lu lv lw lx dt translated">能不能过个<code class="eh ly lz ma mb b">null</code>？</li><li id="4d8e" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">如果我过了一个<code class="eh ly lz ma mb b">null</code>，回报会是什么？<code class="eh ly lz ma mb b">null</code>？空字符串？其他默认字符串？</li></ul><p id="1f9a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">想想看，如果开发人员被要求使用<code class="eh ly lz ma mb b">doRiskyThing</code>来构建一些东西，他们必须花费额外的努力来运行测试或查看源代码来建立他们的信心。</p><p id="a625" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另外两个例子是流行的“变通办法”，只有<code class="eh ly lz ma mb b">doOptionalThing(String strOpt)</code>在运行时是安全的。</p><p id="8a84" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">在Kotlin中，可空对象必须通过追加</strong> <code class="eh ly lz ma mb b"><strong class="jx hv">?</strong></code> <strong class="jx hv"> </strong>来表示。比如<code class="eh ly lz ma mb b">Int?</code> <code class="eh ly lz ma mb b">String?</code> <code class="eh ly lz ma mb b">Long?</code> <code class="eh ly lz ma mb b">DateTime?</code> <code class="eh ly lz ma mb b">BigDecimal?</code>。该语法将在编译时和IDE检查中被检查。</p><p id="6148" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">不需要任何变通方法，并且下面的功能是由<strong class="jx hv">设计</strong>自文档化的。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="a7e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如你在这个小例子中看到的根本区别，为什么Java不修复“十亿美元的错误”？</p><blockquote class="mj"><p id="d420" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">Java必须保持向后兼容性</p></blockquote><p id="94a3" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated"><strong class="jx hv"> <em class="my">所以，你可能会问与科特林有什么关系？</em>T9】</strong></p><p id="1496" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">2016年8月，我们将使用现有的Java库编写一个新的Android应用程序或后端应用程序。考虑到Java &amp; Kotlin都可以100%使用现有的Java库。如果我们选择Java而不是Kotlin，我们就必须牺牲编译时空安全的美妙之处，并做许多额外的“变通”来应对我们甚至不需要的权衡(向后兼容性)？</p><blockquote class="mj"><p id="8be8" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">科特林听起来很有趣？零安全只是主要的查杀功能之一。</p><p id="1d39" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">我要介绍的至少有5+杀人功能。</p></blockquote><p id="59b1" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated"><strong class="jx hv"> <em class="my">注意事项/免责声明:</em> </strong> <em class="my"> </em> <strong class="jx hv"> <em class="my">如果你一直看下面的Kotlin杀人特征，你就再也不想回Java了。相信我，三思而后行！</em> </strong></p><h1 id="e66e" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">零开销可空类型、可空链接和默认值</h1><p id="236d" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">Java 8在<code class="eh ly lz ma mb b">java.util</code>包中引入了一个新的<code class="eh ly lz ma mb b">Optional&lt;T&gt;</code>类。因为<code class="eh ly lz ma mb b">Optional&lt;T&gt;</code>只是一个值类型(容器)来包装一个值。</p><p id="c6b1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，Java中缺少模式匹配(Scala中一个非常强大的特性)，解开和比较包装的值是Java中该死的痛苦。<code class="eh ly lz ma mb b"><a class="ae lo" href="http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments" rel="noopener ugc nofollow" target="_blank">Optional&lt;T&gt;</a></code> <a class="ae lo" href="http://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments" rel="noopener ugc nofollow" target="_blank">拟采用<strong class="jx hv">仅</strong>为返回式以提高“无结果”的意识，</a>遂避开NPE。查看以下示例</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Java Optional Overheads example</figcaption></figure><p id="c1da" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们看一个Scala模式匹配(FYI)的简单例子:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Scala Option pattern matching</figcaption></figure><p id="2ae2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们看看Kotlin的可空类型有多强大:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Kotlin Nullable Type</figcaption></figure><p id="02ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从我的经验来看，在Java/Scala中从一种类型到java.util.Optional/scala.Option类型的重构是一场灾难，看起来像是重写了受影响的代码的一整部分。但是重构Kotlin的可空类型几乎不费吹灰之力。</p><h1 id="af6b" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">类型推理</h1><p id="f6bc" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">类型推理美化了静态类型语言的美，可以提高编码效率，使其达到动态类型的水平。</p><p id="d488" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Java和Kotlin都是静态的强类型语言。这一特性对于大规模应用非常重要。</p><blockquote class="mj"><p id="387a" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">好东西是有代价的</p></blockquote><p id="ca06" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated">在Java中，与PHP或Javascript这样的动态弱类型语言相比，你必须花费额外的精力来为变量指定类型定义。</p><p id="8206" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有时，类型定义是无意义和冗长的，因为</p><ul class=""><li id="740a" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq lu lv lw lx dt translated">这对人类来说太明显了</li><li id="428e" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">编译器应该足够聪明，知道类型</li><li id="32e1" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">类型定义增加了重构的成本。</li></ul><p id="7de8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，当我们使用类型关键字:<code class="eh ly lz ma mb b">String</code>值:<code class="eh ly lz ma mb b">Integer</code>创建带有种子值的映射时</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="b3de" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在科特林，</p><blockquote class="mj"><p id="0d7c" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">让编译器帮你做吧</p></blockquote><p id="ef16" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated">我们可以跳过类型定义，让编译器为我们进行类型推断。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="1836" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">语法非常类似于动态类型语言，但是任何类型不匹配的操作都将被认为是编译错误。</p><p id="3681" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">具有类型推断的Kotlin可以帮助我们编写不太冗长的代码，而不会牺牲任何东西。</p><h1 id="2dd8" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">默认参数和命名参数</h1><p id="dd3c" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">在现实世界中，有些情况下我们需要缺省值而不是空值。Java开发人员要么围绕if-null-then-default值做一项非常难看的工作，要么做一项冗长的方法重载。举个例子，</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="261d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">“丑陋的解决办法”和“冗长的方法重载”也不是自文档化的，很难用Java重构/更改。</p><p id="327b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Kotlin支持<strong class="jx hv">命名和默认参数</strong>，它帮助开发者创建一个更加直观、有意义和可维护的API。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="1607" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">作为主旨的例子已经清楚地展示了<strong class="jx hv">命名和缺省参数的威力。</strong>与Java相比，这是Kotlin的一个根本性的重大改进。</p><p id="7275" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一旦你习惯了Kotlin强大的<strong class="jx hv">命名和默认参数</strong>来设计你的接口<strong class="jx hv">，</strong>你就不会再回到Java了。</p><h1 id="c177" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">延伸很牛逼</h1><p id="8c31" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">在Java中，我们不能直接在一个<code class="eh ly lz ma mb b">Class</code>上添加功能。如果一些逻辑应用在特定的<code class="eh ly lz ma mb b">Type</code>上，并且必须在一个项目中多次使用，Java开发人员习惯于为<code class="eh ly lz ma mb b">Type XXX</code>创建一个<code class="eh ly lz ma mb b">XXXUtils</code>，以便遵循D.R.Y .原则。</p><blockquote class="mj"><p id="7e4a" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">编程没有魔力。关于抽象的一切</p></blockquote><p id="55e3" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated">Kotlin提供了一个更好的抽象来建模由“Java Utils模式”——<strong class="jx hv">扩展</strong>解决的类似问题</p><p id="b14e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">传统Java实用程序的用法</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="db08" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Kotlin是如何为这个问题提供更好的抽象的？我们可以用非常简单的语法直接为特定的<code class="eh ly lz ma mb b">Type</code>添加一个“扩展”！(非常类似于javascript)</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="5de5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">“Java Utils模式”不是IDE友好的，新手不会注意到一些功能已经在XXXUtils中实现了，而Kotlin的扩展完全解决了这个问题。</p><p id="eba3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面是一些截图，展示了IDE自动完成Kotlin扩展的过程。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nd"><img src="../Images/1869e6f12b4203d15445e3830a03c6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTx_tV7pMMxizzvRm0mScQ.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ne"><img src="../Images/8ffec79213429fc934fc2f47579078d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWzz4js4yI3MFt81kh1ySg.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/c5dc805690ea5d00b8be2a0bf6f07ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7N5b_aV_cy3KppRGkhf-7A.png"/></div></div></figure><p id="4704" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有了科特林分机，你就再也不用问了</p><blockquote class="mj"><p id="085c" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated"><em class="ng">是不是XXXUtils.someFunc()已经实现了？</em></p></blockquote><p id="1754" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated">永远不用在。utils文件夹。100%的时候你会在自动完成的列表中找到它。</p><h1 id="4f71" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">便捷数据类</h1><p id="5b16" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">在强类型语言中，我们将创建许多“值对象”来保存数据，通过显式类型来分类它们的域。比如API响应、API请求、数据模型、代理对象等。</p><p id="2887" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是一种非常常见的做法，应该尽可能简单。</p><p id="bf51" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我会见了Scala和最近的Kotlin之后。Java对创建“值对象”的唯一印象:</p><blockquote class="mj"><p id="6134" class="mk ml hu bd mm mn mo mp mq mr ms kq ek translated">对于函数式编程来说，Java太冗长、太昂贵(不可变方法)</p></blockquote><p id="1ea8" class="pw-post-body-paragraph jv jw hu jx b jy mt iv ka kb mu iy kd ke mv kg kh ki mw kk kl km mx ko kp kq hn dt translated">开始阅读下面的Kotlin <code class="eh ly lz ma mb b">data class</code>以获得一些见解，不要忘记阅读评论:)。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="3b1f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在Java中，开发人员不得不使用相对较差的方式(可变或生成器模式)来创建复杂的对象。举个例子，</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="69ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们如何在Java中使用它？</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="efc3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">科特林提供了一个非常方便的<code class="eh ly lz ma mb b">data class</code></p><ul class=""><li id="d0a5" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq lu lv lw lx dt translated">利用构造函数上的<strong class="jx hv">名称和默认参数</strong>的力量</li><li id="1086" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">为编写纯不可变对象提供便利的<code class="eh ly lz ma mb b">.copy</code></li><li id="02c6" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">对于调试是开发人员友好的</li></ul><p id="b4fb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">它有助于减少getter、setter和多重构造函数的冗长。更重要的是，<code class="eh ly lz ma mb b">data class</code>在默认情况下已经可以在一些流行的JSON序列化库中使用，比如GSON、Jackson。</p><p id="b6a8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你熟悉Java，在没有<strong class="jx hv">名称和默认参数</strong>的情况下，你会知道创建一个“值对象”来实现与科特林的<code class="eh ly lz ma mb b">data class</code>相同的便利性是不可行的。</p><h1 id="03f2" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">“kotlineze”Java库</h1><p id="3ed8" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">在大型应用程序中，一致性是保持源代码更可预测和可维护的最重要的作用。</p><p id="c1c5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">默认情况下，Kotlin不鼓励为变量创建getter/setter函数。每个变量都有一个get()/set(值)来实现:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="c451" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，在纯Kotlin代码中，我们从不写<code class="eh ly lz ma mb b">getXXX()</code>或<code class="eh ly lz ma mb b">setXXX(value)</code>。但是，几乎100%的Java库都会使用getter/setter。</p><p id="03b2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="my">科特林是如何解决这种出入的？让我们看看Java Android库中的“TextView”。</em> </strong></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nh"><img src="../Images/95f912de8ad8309eca93804b974d577a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLockNoj0fV-6KK2fQivhA.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Standard Android TextView(Java) in Kotlin</figcaption></figure><p id="4a96" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Kotlin将Kotlin化Java的“默认”getter/setter为kot Lin风格，使用Java库你永远不会感到不舒服。</p><p id="7ce4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你有在Scala中使用Java库的经验，你一定非常想要这个特性，至少我是这么想的。</p><h1 id="8aab" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">更好的函数式编程支持</h1><p id="08a3" class="pw-post-body-paragraph jv jw hu jx b jy lj iv ka kb lk iy kd ke ll kg kh ki lm kk kl km ln ko kp kq hn dt translated">用Java编写函数式代码比用Kotlin要昂贵得多。因为Kotlin提供了以下功能:</p><ul class=""><li id="888e" class="lp lq hu jx b jy jz kb kc ke lr ki ls km lt kq lu lv lw lx dt translated">类型推理</li><li id="e531" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">廉价的数据类(不可变的<code class="eh ly lz ma mb b">.copy</code>特性)</li><li id="7886" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">函数/lamda的直观类型声明，即<code class="eh ly lz ma mb b">(Int)-&gt; Int</code>、<code class="eh ly lz ma mb b">(Int,Int) -&gt; Bool</code>而不是<code class="eh ly lz ma mb b">java.util.functions.BiFunction&lt;T,U,R&gt;...</code></li><li id="bd0e" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">支持析构</li><li id="24b8" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">每样东西都是一个表达式(更容易编写声明性代码)</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Easy to create Pair &amp; destructing a pair</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Destructing a List</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Destructing a data class</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Currying function example</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mh mi l"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Every thing is an expression</figcaption></figure><h1 id="9d4e" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">主要好处(前述)</h1><ul class=""><li id="64d8" class="lp lq hu jx b jy lj kb lk ke ni ki nj km nk kq lu lv lw lx dt translated">编译时空安全</li><li id="1313" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">零开销可空类型、可空链接和默认值</li><li id="6c58" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">类型推理</li><li id="5411" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">默认参数和命名参数</li><li id="56c4" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">延伸很牛逼</li><li id="f3c4" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">便捷数据类</li><li id="46ca" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">“kotlineze”Java库</li><li id="88cc" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">更好的函数式编程支持</li></ul><h1 id="35ce" class="kr ks hu bd kt ku kv kw kx ky kz la lb ja lc jb ld jd le je lf jg lg jh lh li dt translated">小点心</h1><ul class=""><li id="03f8" class="lp lq hu jx b jy lj kb lk ke ni ki nj km nk kq lu lv lw lx dt translated">直观的字符串模板</li><li id="56f3" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">Kotlin std-lib中实现了许多方便的功能，即<code class="eh ly lz ma mb b">array.find</code> …</li><li id="124c" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">单个文件中的多个类或对象</li><li id="d76f" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">支持遗留JVM。Kotlin在Java 6上运行，它的接口可以像在Java 8中一样有默认的实现。</li><li id="448d" class="lp lq hu jx b jy mc kb md ke me ki mf km mg kq lu lv lw lx dt translated">最佳IDE支持</li></ul></div><div class="ab cl nl nm hc nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hn ho hp hq hr"><p id="a2a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="my">接下来— </em> </strong> <a class="ae lo" rel="noopener" href="/@gaplotech/part-3-picking-kotlin-for-android-swift-in-android-7db405962c13"> <em class="my">第三部分:为Android挑选kot Lin—Android中的Swift？</em>T11】</a></p><div class="jk jl jm jn fq ab cb"><figure class="ns jo nt nu nv nw nx paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="ns jo nt nu nv nw nx paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="ns jo nt nu nv nw nx paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ny nz oa"><p id="f922" class="jv jw my jx b jy jz iv ka kb kc iy kd ob kf kg kh oc kj kk kl od kn ko kp kq hn dt translated"><a class="ae lo" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是AMI家庭的一员。我们现在<a class="ae lo" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae lo" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jv jw my jx b jy jz iv ka kb kc iy kd ob kf kg kh oc kj kk kl od kn ko kp kq hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lo" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lo" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oe"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>