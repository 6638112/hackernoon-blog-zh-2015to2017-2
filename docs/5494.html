<html>
<head>
<title>Controlling Python Async Creep</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">控制Python异步蔓延</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/controlling-python-async-creep-ec0a0f4b79ba?source=collection_archive---------2-----------------------#2017-07-30">https://medium.com/hackernoon/controlling-python-async-creep-ec0a0f4b79ba?source=collection_archive---------2-----------------------#2017-07-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/51eb74abd68e0f2db6ee60c7c0ea43ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lpO60MFa0QBfY60ZvF3tA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo Credit: <a class="ae jg" href="https://unsplash.com/collections/597524/growth?photo=aO_jMXTduUE" rel="noopener ugc nofollow" target="_blank">Christian Jourdy</a> via <a class="ae jg" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1d07" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不久前，Python在基础语言中加入了正式的异步性。玩<a class="ae jg" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank">asyncio</a>T0】和<code class="eh kf kg kh ki b">coroutines</code>很有趣，它们是几乎并行执行的基本构造。但是当你开始更多地集成常规代码库时，你可能会发现事情会变得棘手。尤其是当您被迫与同步代码交互时。</p><p id="9b67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当调用<em class="kj">一个合适的</em>函数时，情况变得复杂了。这样做需要一个<code class="eh kf kg kh ki b">async</code>定义的代码块或协程。除了如果你的调用者必须是异步的，那么你也不能调用<em class="kj">它</em>，除非它的调用者是异步的。然后强制其调用者进入异步块，依此类推。这就是“异步蠕变”。</p><p id="aaa7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它可以迅速升级，进入代码的各个角落。如果代码库是异步的，这没什么大不了的，但是在混合使用时会阻碍开发。</p><p id="5928" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是我用来解决这个问题的两个主要机制。两者都假设我们正在构建一个受益于异步执行的应用程序。</p><h2 id="b92c" class="kk kl hu bd km kn ko kp kq kr ks kt ku js kv kw kx jw ky kz la ka lb lc ld le dt translated">等待异步代码块</h2><p id="b699" class="pw-post-body-paragraph jh ji hu jj b jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">无论是构建异步应用程序还是增强线性应用程序，确定将从异步执行中获益最多的部分都很重要。这通常不难回答，但没有其他人能替你做到。一般的指导方针是从等待I/O的事情开始，比如文件或套接字访问、HTTP请求等。</p><p id="e509" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一旦您知道了哪些部分需要优化，就开始识别那些可以在彼此之上运行的部分。越多可以组合在一起越好。一个很好的例子是代码需要来自几个互不依赖的REST APIs的信息。您可以使用<code class="eh kf kg kh ki b">aiohttp</code>并并行进行所有调用，而不是等待每个调用完成后再进行下一个调用。</p><p id="39e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在的问题是将这些代码块加载到主事件循环中。有几种方法可以做到这一点，我喜欢将它们放入异步函数中，并使用<code class="eh kf kg kh ki b">asyncio.ensure_future()</code>将它们放入循环中，使用<code class="eh kf kg kh ki b">loop.run_until_complete()</code>等待完成:</p><pre class="lk ll lm ln fq lo ki lp lq aw lr dt"><span id="d541" class="kk kl hu ki b fv ls lt l lu lv">import asyncio<br/>import aiohttp</span><span id="4636" class="kk kl hu ki b fv lw lt l lu lv">async def fetch(url):<br/>    response = await aiohttp.request('GET', url)<br/>    return await response.text()</span><span id="f7e4" class="kk kl hu ki b fv lw lt l lu lv">loop = asyncio.get_event_loop()<br/>loop.run_until_complete(asyncio.gather(<br/>    asyncio.ensure_future(fetch("http://www.google.com")),<br/>    asyncio.ensure_future(fetch("http://www.github.com")),<br/>    asyncio.ensure_future(fetch("http://www.reddit.com"))<br/>))</span></pre><p id="c197" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一个类似于我在上一篇文章中使用的例子:<a class="ae jg" href="https://hackernoon.com/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32" rel="noopener ugc nofollow" target="_blank">线程异步魔法以及如何使用它</a>。</p><p id="688c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">asyncio.ensure_future()</code>将函数转换成协程，<code class="eh kf kg kh ki b">asyncio.gather()</code>将它们组合在一起，而<code class="eh kf kg kh ki b">loop.run_until_complete()</code>阻塞执行，直到所有调用完成。它的输出是每个调用的结果列表。</p><p id="4450" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">遵循到目前为止所讨论的要点将产生运行同步块的代码。但是其中一些块将一起执行几个异步函数。</p><h2 id="2a5b" class="kk kl hu bd km kn ko kp kq kr ks kt ku js kv kw kx jw ky kz la ka lb lc ld le dt translated">用一根线</h2><p id="7226" class="pw-post-body-paragraph jh ji hu jj b jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">在我之前的<a class="ae jg" href="https://hackernoon.com/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32" rel="noopener ugc nofollow" target="_blank">文章中也讨论过，创建一个独立的线程作为一个工作者并不难。它运行自己的事件循环，您使用线程安全的asyncio方法让它工作。好的方面是你可以让它与<code class="eh kf kg kh ki b">call_soon()</code>同步工作，或者与<code class="eh kf kg kh ki b">run_coroutine_threadsafe()</code>异步工作。</a></p><pre class="lk ll lm ln fq lo ki lp lq aw lr dt"><span id="090a" class="kk kl hu ki b fv ls lt l lu lv">from threading import Thread</span><span id="1716" class="kk kl hu ki b fv lw lt l lu lv">...</span><span id="8a0f" class="kk kl hu ki b fv lw lt l lu lv">def start_background_loop(loop):<br/>    asyncio.set_event_loop(loop)<br/>    loop.run_forever()</span><span id="4f07" class="kk kl hu ki b fv lw lt l lu lv"># Create a new loop<br/>new_loop = asyncio.new_event_loop()</span><span id="1fcc" class="kk kl hu ki b fv lw lt l lu lv"># Assign the loop to another thread<br/>t = Thread(target=start_background_loop, args=(new_loop,))<br/>t.start()</span><span id="f496" class="kk kl hu ki b fv lw lt l lu lv"># Give it some async work<br/>future = asyncio.run_coroutine_threadsafe(<br/>    fetch("http://www.google.com"), <br/>    new_loop<br/>)</span><span id="7621" class="kk kl hu ki b fv lw lt l lu lv"># Wait for the result<br/>print(future.result())</span><span id="2eb2" class="kk kl hu ki b fv lw lt l lu lv"># Do it again but with a callback<br/>asyncio.run_coroutine_threadsafe(<br/>    fetch("http://www.github.com"),<br/>    new_loop<br/>).add_done_callback(lambda future: print(future.result()))</span></pre><p id="bb82" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们从<code class="eh kf kg kh ki b">run_coroutine_threadsafe</code>得到一个<code class="eh kf kg kh ki b">Future</code>，我们可以使用<code class="eh kf kg kh ki b">result(timeout)</code>方法等待它，或者用<code class="eh kf kg kh ki b">add_done_callback(function)</code>添加一个回调。回调函数将接收未来作为参数。</p><h2 id="2d44" class="kk kl hu bd km kn ko kp kq kr ks kt ku js kv kw kx jw ky kz la ka lb lc ld le dt translated">在相同的API方法中支持异步和同步调用</h2><p id="66e1" class="pw-post-body-paragraph jh ji hu jj b jk lf jm jn jo lg jq jr js lh ju jv jw li jy jz ka lj kc kd ke hn dt translated">让我们来看看更复杂的东西。如果您有一个库或模块，其中大多数函数可以并行运行，但您只希望调用方是异步的，那该怎么办？</p><p id="597b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们可以利用线程模型，因为调度器方法是同步的。这意味着用户不需要声明自己是异步的，也不需要在代码中处理异步爬行。异步块仍然包含在您的模块中。</p><p id="b2c4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它还允许api接口选择是否使用asyncio。事实上，我们甚至可以更进一步，使用inspect magic自动检测何时异步。</p><p id="30fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">没有线程，你就无法控制你的事件循环。用户可以做他们自己的异步摆弄，干扰你的方法如何执行。线程将至少保证在您操作的事件循环中异步执行。需要时可以开始和停止。这导致更可预测、可重复的结果。</p><p id="aa7a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们看一个建立在前面的例子上的例子。这里我们制作了一个包装器方法，它根据调用者调用适当的同步或异步函数。</p><pre class="lk ll lm ln fq lo ki lp lq aw lr dt"><span id="599d" class="kk kl hu ki b fv ls lt l lu lv">import inspect<br/>import requests</span><span id="5257" class="kk kl hu ki b fv lw lt l lu lv">...</span><span id="10a6" class="kk kl hu ki b fv lw lt l lu lv">def is_async_caller():<br/>    """Figure out who's calling."""</span><span id="1259" class="kk kl hu ki b fv lw lt l lu lv">    # Get the calling frame<br/>    caller = inspect.currentframe().f_back.f_back</span><span id="133c" class="kk kl hu ki b fv lw lt l lu lv">    # Pull the function name from FrameInfo<br/>    func_name = inspect.getframeinfo(caller)[2]</span><span id="35d3" class="kk kl hu ki b fv lw lt l lu lv">    # Get the function object<br/>    f = caller.f_locals.get(<br/>        func_name, <br/>        caller.f_globals.get(func_name)<br/>    )</span><span id="fc05" class="kk kl hu ki b fv lw lt l lu lv">    # If there's any indication that the function object is a <br/>    # coroutine, return True. inspect.iscoroutinefunction() should<br/>    # be all we need, the rest are here to illustrate.</span><span id="f53b" class="kk kl hu ki b fv lw lt l lu lv">    if any([inspect.iscoroutinefunction(f),<br/>            inspect.isgeneratorfunction(f),<br/>            inspect.iscoroutine(f), inspect.isawaitable(f),<br/>            inspect.isasyncgenfunction(f) , inspect.isasyncgen(f)]):<br/>        return True<br/>    else:<br/>        return False</span><span id="2b4c" class="kk kl hu ki b fv lw lt l lu lv">def fetch(url):<br/>    """GET the URL, do it asynchronously if the caller is async"""<br/><br/>    # Figure out which function is calling us<br/>    if is_async_caller():<br/>        print("Calling ASYNC method")</span><span id="546d" class="kk kl hu ki b fv lw lt l lu lv">        # Run the async version of this method and<br/>        # print the result with a callback<br/>        asyncio.run_coroutine_threadsafe(<br/>            _async_fetch(url), <br/>            new_loop<br/>        ).add_done_callback(lambda f: print(f.result()))</span><span id="7a56" class="kk kl hu ki b fv lw lt l lu lv">    else:<br/>        print("Calling BLOCKING method")</span><span id="928f" class="kk kl hu ki b fv lw lt l lu lv">        # Run the synchronous version and print the result<br/>        print(_sync_fetch(url))<br/></span><span id="d45f" class="kk kl hu ki b fv lw lt l lu lv">def _sync_fetch(url):<br/>    """Blocking GET"""</span><span id="5769" class="kk kl hu ki b fv lw lt l lu lv">    return requests.get(url).content<br/></span><span id="0447" class="kk kl hu ki b fv lw lt l lu lv">async def _async_fetch(url):<br/>    """Async GET"""</span><span id="27db" class="kk kl hu ki b fv lw lt l lu lv">    resp = await aiohttp.request('GET', url)<br/>    return await resp.text()<br/></span><span id="6ad2" class="kk kl hu ki b fv lw lt l lu lv">def call_sync_fetch():<br/>    """Blocking fetch call"""</span><span id="e300" class="kk kl hu ki b fv lw lt l lu lv">    fetch("<a class="ae jg" href="http://www.github.com" rel="noopener ugc nofollow" target="_blank">http://www.github.com</a>")<br/></span><span id="8a2c" class="kk kl hu ki b fv lw lt l lu lv">async def call_async_fetch():<br/>    """Asynchronous fetch call (no different from sync call <br/>       except this function is defined async)"""</span><span id="3fd8" class="kk kl hu ki b fv lw lt l lu lv">    fetch("<a class="ae jg" href="http://www.github.com" rel="noopener ugc nofollow" target="_blank">http://www.github.com</a>")<br/></span><span id="0fc2" class="kk kl hu ki b fv lw lt l lu lv"># Perform a blocking GET<br/>call_sync_fetch()</span><span id="eb03" class="kk kl hu ki b fv lw lt l lu lv"># Perform an async GET<br/>loop = asyncio.get_event_loop()<br/>loop.run_until_complete(call_async_fetch())</span></pre><p id="e336" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在<code class="eh kf kg kh ki b">is_async_caller()</code>中使用<code class="eh kf kg kh ki b">inspect</code>来获取调用我们的函数对象，并确定它是否是协程。虽然这很奇特，说明了可能性，但它可能不是很有性能。我们可以很容易地用<code class="eh kf kg kh ki b">fetch</code>包装器中的<code class="eh kf kg kh ki b">async_execute</code>参数替换该机制，并让用户决定。</p><p id="26fe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">call_sync_fetch</code>和<code class="eh kf kg kh ki b">call_async_fetch</code>函数展示了用户如何调用我们的包装器。如您所见，不需要等待fetch调用，因为它是通过在一个单独的线程中运行自动完成的。</p><p id="ceab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这对于任何想要在支持遗留代码的同时增加异步执行支持的python包来说都是有用的。我敢肯定有利弊，请在下面的评论中开始讨论。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><figure class="lk ll lm ln fq iv fe ff paragraph-image"><a href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fpublish.twitter.com%2F&amp;ref_src=twsrc%5Etfw&amp;region=follow_link&amp;screen_name=tryexceptpass&amp;tw_p=followbutton"><div class="fe ff me"><img src="../Images/4e728960fa1d1a8a3847021955abc3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*_04PhhMqHB3qXQnOQNP5ag.png"/></div></a></figure><p id="4316" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这篇文章，并想了解我正在做的事情，请推荐它，访问<a class="ae jg" href="http://tryexceptpass.org" rel="noopener ugc nofollow" target="_blank">tryexecptpass.org</a>了解更多主题，并<a class="ae jg" href="https://twitter.com/intent/follow?original_referer=https%3A%2F%2Fpublish.twitter.com%2F&amp;ref_src=twsrc%5Etfw&amp;region=follow_link&amp;screen_name=tryexceptpass&amp;tw_p=followbutton" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>。</p></div></div>    
</body>
</html>