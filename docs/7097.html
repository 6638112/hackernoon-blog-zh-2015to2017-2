<html>
<head>
<title>Infinite Scrolling In Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase中的无限滚动</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/infinite-scrolling-in-firebase-e28bfbc53578?source=collection_archive---------11-----------------------#2017-10-17">https://medium.com/hackernoon/infinite-scrolling-in-firebase-e28bfbc53578?source=collection_archive---------11-----------------------#2017-10-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9434" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文将向您展示如何在JavaScript和firebase中实现无限滚动，而无需修改现有的firebase数据结构。</p><p id="7a91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我试图让这篇文章尽可能地通用并适用于您选择的任何框架/库，所以希望它能让您很好地理解在自己的项目中实现它所需要经历的步骤。</p><p id="dfae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意:如果你不想继续下去，并急于看到代码，你可以跳到文章的底部。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/2c2ff82926d78dee23ae553b331ebb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hyRM50LJZP5sgEg3a76Xw.png"/></div></div></figure><h2 id="0c99" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak">概要</strong></h2><p id="d4d0" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">开始之前，让我们定义一下预期行为:</p><ul class=""><li id="16b1" class="lb lc hu it b iu iv iy iz jc ld jg le jk lf jo lg lh li lj dt translated">初始获取:检索5个最新的项目</li><li id="57ec" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated">后续获取:检索接下来的5个最新项目</li></ul><p id="51e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们还定义我们将假装从firebase中获取的测试数据——使用假数据将更容易可视化查询发生了什么:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="072a" class="kb kc hu lq b fv lu lv l lw lx">// our firebase database<br/>items: { <br/>   firstInsertedItem: { … }, // oldest<br/>   SecondInsertedItem: { … }, <br/>   ThirdInsertedItem: { … },<br/>   FourthInsertedItem: { … }, <br/>   FifthInsertedItem: { … }, <br/>   SixthInsertedItem: { … }, <br/>   SeventhInsertedItem: { … },<br/>   EighthInsertedItem: { … }, <br/>   NinethInsertedItem: { … }, <br/>   TenthInsertedItem: { … }, // newest<br/> }</span><span id="84d5" class="kb kc hu lq b fv ly lv l lw lx">// in case you were wondering about the order that I put the items // in, that's just to make it easier to follow along<br/>// and it would make no difference to us if firebase actually <br/>// stored those items in a different order internally</span></pre><h2 id="8af6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak"> Firebase按键</strong></h2><p id="5ac5" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">让我们首先介绍firebase按键背后的魔力，以及它们如何让这一切成为可能。</p><p id="7bab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实证明，firebase按键不仅仅是一些随机的字符序列。事实上，所有的<a class="ae lz" href="https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html" rel="noopener ugc nofollow" target="_blank"> firebase按键</a>都由时间戳和随机数据组成，这些数据以修改后的base64字母表编码，以<strong class="it hv">保存</strong>它们的<strong class="it hv">时间顺序</strong> <strong class="it hv">顺序</strong>——即它们的插入顺序。</p><p id="0621" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个强大的特性，因为它允许我们利用firebase的排序查询。</p><p id="9372" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">既然我们已经定义了这个重要的特性，我们就可以继续学习教程了。</p><h2 id="ae5d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak">第一步</strong></h2><p id="7022" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">为了让我们所有的获取，在第一次之后，返回我们期望它们返回的内容，我们需要保存某种对最早的先前获取的键的引用。</p><p id="0b4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以让我们定义一个变量，叫做:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="cb68" class="kb kc hu lq b fv lu lv l lw lx">let referenceToOldestKey = ‘’;</span></pre><h2 id="158d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak">初始获取</strong></h2><p id="b063" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">接下来，让我们创建一个查询来获取前5个最新插入的项目:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="538d" class="kb kc hu lq b fv lu lv l lw lx">firebase.database().ref(‘items’)<br/> .orderByKey()<br/> .limitToLast(5)<br/> .once(‘value’)<br/> .then((snapshot) =&gt; { … } )<br/> .catch((error) =&gt; { … } );</span></pre><p id="9d0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该查询执行以下操作:</p><p id="a6d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">- <strong class="it hv"> <em class="ma"> orderByKey </em> </strong>将项目按其关键字按时间顺序排序(从最老到最新)<br/>-<strong class="it hv"><em class="ma">limit to last</em></strong>从末尾选择5个项目(从第5个开始)</p><p id="648a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">返回的对象将如下所示:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="9d18" class="kb kc hu lq b fv lu lv l lw lx">{ <br/>   SixthItemFromTheEnd: { … },<br/>   SeventhItemFromTheEnd: { … },<br/>   EighthInsertedItem: { … },<br/>   NinethInsertedItem: { … },<br/>   TenthInsertedItem: { … },<br/> }</span></pre><p id="2291" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们需要颠倒这个对象的顺序，使最新的项目在顶部而不是底部。</p><p id="94aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们这里有几个选项，取决于您喜欢如何管理您的应用程序状态:</p><ul class=""><li id="05a5" class="lb lc hu it b iu iv iy iz jc ld jg le jk lf jo lg lh li lj dt translated">反转对象</li><li id="c3e9" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated">将对象转换为对象数组并反转数组</li><li id="fc88" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated">保持对象原样，但在向用户显示时进行浅复制并当场反转</li></ul><p id="f2be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将选择第二个选项，因为这是存储这类数据最流行的方式。</p><p id="e9ec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我们给<strong class="it hv">补充以下内容。那么我们的获取函数的</strong>:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="e210" class="kb kc hu lq b fv lu lv l lw lx">let arrayOfKeys = Object.keys(snapshot.val())<br/>   .sort()<br/>   .reverse();</span><span id="7f8c" class="kb kc hu lq b fv ly lv l lw lx">let results = arrayOfKeys<br/>   .map((key) =&gt; snapshot.val()[key]);</span></pre><p id="98f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意，我们在反转键的顺序之前对它们进行了排序——这样做是为了确保正确的顺序，因为JavaScript不保证对象键的顺序。</p><p id="91f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们需要用5个键中最老的键来初始化我们的引用，以便当用户滚动到页面底部时，我们的下一个获取函数知道从哪里继续:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="5e19" class="kb kc hu lq b fv lu lv l lw lx">referenceToOldestKey = arrayOfKeys[arrayOfKeys.length-1];</span></pre><p id="2011" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(最老的键在最后一个位置，因为记住<strong class="it hv"> <em class="ma"> limitToLast </em> </strong>按时间顺序返回项目，我们颠倒了它。)</p><p id="d4c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经完成了第一次提取:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="3ae1" class="kb kc hu lq b fv lu lv l lw lx">// You can do what you want to do with the data, i.e.<br/>// append to page or dispatch({ … }) if using redux</span></pre><h2 id="80b9" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak">下一次取货</strong></h2><p id="4ac1" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">好了，我们的用户刚刚点击了页面底部，让我们通过创建以下查询为他们获取接下来的5个最新项目:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="deca" class="kb kc hu lq b fv lu lv l lw lx">firebase.database().ref(‘items’)<br/> .orderByKey()<br/> .endAt(referenceToOldestKey)<br/> .limitToLast(6)<br/> .once(‘value’)<br/> .then((snapshot) =&gt; { … } )<br/> .catch((error) =&gt; { … } );</span></pre><p id="3dfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该查询执行以下操作:</p><ul class=""><li id="9152" class="lb lc hu it b iu iv iy iz jc ld jg le jk lf jo lg lh li lj dt translated"><strong class="it hv"> <em class="ma"> orderByKey </em> </strong>按关键字按时间顺序(从最早到最新)对项目进行排序</li><li id="c956" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv"> <em class="ma"> endAt </em> </strong>选择从第一个添加到我们的引用变量(<strong class="it hv">含</strong>)中的所有项目</li><li id="ae5a" class="lb lc hu it b iu lk iy ll jc lm jg ln jk lo jo lg lh li lj dt translated"><strong class="it hv"> <em class="ma"> limitToLast </em> </strong>从末尾选择6个项目(从第6个开始)</li></ul><p id="e898" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">返回的对象将如下所示:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="7052" class="kb kc hu lq b fv lu lv l lw lx">{ <br/>   firstInsertedItem: { … },<br/>   SecondInsertedItem: { … },<br/>   ThirdInsertedItem: { … },<br/>   FourthInsertedItem: { … },<br/>   FifthInsertedItem: { … },<br/>   SixthInsertedItem: { … },  // our reference is included!<br/> }</span></pre><ul class=""><li id="8385" class="lb lc hu it b iu iv iy iz jc ld jg le jk lf jo lg lh li lj dt translated">但是，为什么我们限制到6个最新的项目，而不是5个，就像我们在第一次获取中做的那样？</li></ul><p id="4379" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为<strong class="it hv"> <em class="ma"> endAt </em> </strong>是<strong class="it hv"> inclusive </strong>这意味着我们的<strong class="it hv">引用键</strong>包含在返回的对象中。因此，如果我们限制为5个，我们将最终只有4个新项目，因为1个将是重复的，因此我们需要请求6个，然后在客户端处理第6个的删除。</p><p id="b391" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，现在我们看到了查询是如何工作的，让我们反转返回的对象，然后删除重复的对象。</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="e290" class="kb kc hu lq b fv lu lv l lw lx">let arrayOfKeys = Object.keys(snapshot.val())<br/>   .sort()<br/>   .reverse()<br/>   .slice(1);</span><span id="419d" class="kb kc hu lq b fv ly lv l lw lx">let results = arrayOfKeys<br/>   .map((key) =&gt; snapshot.val()[key]);</span></pre><p id="4b82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为什么<strong class="it hv"> <em class="ma">切①</em></strong>？因为在<strong class="it hv"> <em class="ma">反转()</em> </strong>之后，我们的副本从最后一个位置移到了第一个位置。我们怎么知道它一开始是在最后的位置？因为记住钥匙是按时间顺序归还的。</p><p id="5550" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们需要用当前获取的最旧的键来更新我们的引用:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="3871" class="kb kc hu lq b fv lu lv l lw lx">referenceToOldestKey = arrayOfKeys[arrayOfKeys.length-1];</span></pre><p id="53f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们已经完成了第二次提取:</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="7ec9" class="kb kc hu lq b fv lu lv l lw lx">// You can do what you want to do with the data, i.e.<br/>// append to page or dispatch({ … }) if using redux</span></pre><p id="1ea8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本教程到此结束，感谢您的阅读，希望您学到了一些新东西。下面是完整的代码示例。</p><h2 id="a20a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated"><strong class="ak">完整的代码示例</strong></h2><p id="3ec2" class="pw-post-body-paragraph ir is hu it b iu kw iw ix iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo hn dt translated">注意:<strong class="it hv">内代码重复。然后，两个查询中的</strong>是有意使其更容易阅读，不需要到处寻找相关代码，如果代码被移到一个单独的函数中，则需要这样做。</p><pre class="jq jr js jt fq lp lq lr ls aw lt dt"><span id="79de" class="kb kc hu lq b fv lu lv l lw lx">let referenceToOldestKey = ‘’;</span><span id="c8bb" class="kb kc hu lq b fv ly lv l lw lx">if (!referenceToOldestKey) { // if initial fetch<br/> <br/>  firebase.database().ref(‘items’)<br/>   .orderByKey()<br/>   .limitToLast(5)<br/>   .once(‘value’)<br/>   .then((snapshot) =&gt; { </span><span id="c5b8" class="kb kc hu lq b fv ly lv l lw lx">      // changing to reverse chronological order (latest first)<br/>      let arrayOfKeys = Object.keys(snapshot.val())<br/>         .sort()<br/>         .reverse();</span><span id="8c20" class="kb kc hu lq b fv ly lv l lw lx">      // transforming to array<br/>      let results = arrayOfKeys<br/>         .map((key) =&gt; snapshot.val()[key]);</span><span id="ae06" class="kb kc hu lq b fv ly lv l lw lx">      // storing reference<br/>      referenceToOldestKey = arrayOfKeys[arrayOfKeys.length-1];<br/> <br/>      // Do what you want to do with the data, i.e.<br/>      // append to page or dispatch({ … }) if using redux</span><span id="3f4d" class="kb kc hu lq b fv ly lv l lw lx">   })<br/>   .catch((error) =&gt; { … } );<br/> <br/> } else {<br/> <br/>  firebase.database().ref(‘items’)<br/>   .orderByKey()<br/>   .endAt(oldestKeyReference)<br/>   .limitToLast(6)<br/>   .once(‘value’)<br/>   .then((snapshot) =&gt; {</span><span id="7d6c" class="kb kc hu lq b fv ly lv l lw lx">     // changing to reverse chronological order (latest first)<br/>     // &amp; removing duplicate<br/>     let arrayOfKeys = Object.keys(snapshot.val())<br/>         .sort()<br/>         .reverse()<br/>         .slice(1);</span><span id="d635" class="kb kc hu lq b fv ly lv l lw lx">      // transforming to array<br/>      let results = arrayOfKeys<br/>         .map((key) =&gt; snapshot.val()[key]);</span><span id="6bbb" class="kb kc hu lq b fv ly lv l lw lx">      // updating reference<br/>      referenceToOldestKey = arrayOfKeys[arrayOfKeys.length-1];</span><span id="3fa7" class="kb kc hu lq b fv ly lv l lw lx">      // Do what you want to do with the data, i.e.<br/>      // append to page or dispatch({ … }) if using redux</span><span id="9238" class="kb kc hu lq b fv ly lv l lw lx">   })<br/>   .catch((error) =&gt; { … } );<br/> <br/> }</span></pre><p id="4ce1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望这篇文章没有完全浪费你的时间，你实际上从中学到了一些东西:)。</p><p id="dc8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">顺便说一下，如果你是一个推特用户，你可以通过<a class="ae lz" href="https://twitter.com/linasmnew" rel="noopener ugc nofollow" target="_blank"> linasmnew </a>，<em class="ma">联系我(我是那里的新成员</em>😅 😄)</p></div></div>    
</body>
</html>