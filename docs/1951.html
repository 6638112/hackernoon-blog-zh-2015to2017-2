<html>
<head>
<title>How To Build A Multiplayer Browser Game (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个多人浏览器游戏(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-build-a-multiplayer-browser-game-4a793818c29b?source=collection_archive---------0-----------------------#2016-12-23">https://medium.com/hackernoon/how-to-build-a-multiplayer-browser-game-4a793818c29b?source=collection_archive---------0-----------------------#2016-12-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d1f0ab519fdb449629bfbbd49f60d36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3rcGzbireyIUoaNtJRoxg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Tank Anarchy</figcaption></figure><p id="8006" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">回到2014年，我参加了我在纽约的第一次代码日。虽然CodeDay不完全是一个黑客马拉松，但这是我第一次体验类似黑客马拉松的活动。在这次活动中，我和我的朋友肯尼斯·李(Kenneth Li)一起制作了一个多人坦克战斗游戏。由于我的一些朋友对我如何构建它表示了兴趣，我想我应该在这里记录这个过程。</p><p id="dce0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这篇文章中，我将快速回顾一下我的思考过程，并给出一个如何复制架构的演示，如果你想自己尝试的话，还会提供一些提示和技巧。这篇文章假设你已经掌握了JavaScript和node.js的基础知识。如果你没有，有很多<a class="ae ke" href="https://nodeschool.io/" rel="noopener ugc nofollow" target="_blank">很棒的在线资源</a>可以学习以上内容。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><p id="75a7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我在node.js后端构建了这个游戏，使用WebSockets提供客户端和服务器之间的实时通信。游戏本身呈现在客户端的HTML5画布上。要开始，你当然需要node.js。对于这篇文章，我将使用node . js 6 . 3 . 1版，但你可以使用几乎任何版本(0.12以上)，应该没问题。</p><p id="7f67" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们先从依赖关系开始。为您的项目创建一个目录，并在其中运行以下内容:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="0754" class="kv kw hu kr b fv kx ky l kz la">npm init<br/>npm install --save express socket.io</span></pre><p id="2be6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将使用<a class="ae ke" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express framework </a>来快速设置服务器，并使用<a class="ae ke" href="http://socket.io" rel="noopener ugc nofollow" target="_blank"> socket.io </a>包来处理服务器上的WebSockets。将以下内容放入名为<code class="eh lb lc ld kr b">server.js</code>的文件中:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="1ec0" class="kv kw hu kr b fv kx ky l kz la">// Dependencies<br/>var express = require('express');<br/>var http = require('http');<br/>var path = require('path');<br/>var socketIO = require('socket.io');</span><span id="911e" class="kv kw hu kr b fv le ky l kz la">var app = express();<br/>var server = http.Server(app);<br/>var io = socketIO(server);</span><span id="a6a4" class="kv kw hu kr b fv le ky l kz la">app.set('port', 5000);<br/>app.use('/static', express.static(__dirname + '/static'));</span><span id="11c1" class="kv kw hu kr b fv le ky l kz la">// Routing<br/>app.get('/', function(request, response) {<br/>  response.sendFile(path.join(__dirname, 'index.html'));<br/>});</span><span id="03df" class="kv kw hu kr b fv le ky l kz la">// Starts the server.<br/>server.listen(5000, function() {<br/>  console.log('Starting server on port 5000');<br/>});</span></pre><p id="dd14" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上面的代码是一个使用Express框架的非常标准的node.js服务器。它为服务器设置依赖关系和基本路由。对于这个演示应用程序，我们将只为单个的<code class="eh lb lc ld kr b">index.html</code>和<code class="eh lb lc ld kr b">static</code>目录服务。在根项目文件夹中创建一个名为<code class="eh lb lc ld kr b">static</code>的目录和一个<code class="eh lb lc ld kr b">index.html</code>文件。HTML文件非常简单，所以我们现在就写:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="e6f9" class="kv kw hu kr b fv kx ky l kz la">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;A Multiplayer Game&lt;/title&gt;<br/>    &lt;style&gt;<br/>      canvas {<br/>        width: 800px;<br/>        height: 600px;<br/>        border: 5px solid black;<br/>      }<br/>    &lt;/style&gt;<br/>    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;canvas id="canvas"&gt;&lt;/canvas&gt;<br/>  &lt;/body&gt;<br/>  &lt;script src="/static/game.js"&gt;&lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="2d45" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于较大规模的项目，应该将CSS样式放在单独的专用样式表中。您可能还会有更多的UI和显示元素。为了简单起见，我将CSS保留在HTML代码中。注意，我还包含了一个<code class="eh lb lc ld kr b">socket.io.js</code>脚本。这是在托管服务器时由socket.io包自动提供的。</p><p id="11c5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在我们将在服务器上为WebSockets做一些设置。将此行添加到<code class="eh lb lc ld kr b">server.js</code>的末尾:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="6ae2" class="kv kw hu kr b fv kx ky l kz la">// Add the WebSocket handlers<br/>io.on('connection', function(socket) {<br/>});</span></pre><p id="b742" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还没有它的任何功能，所以现在就让它保持原样吧。为了进行测试，在<code class="eh lb lc ld kr b">server.js</code>的末尾添加以下几行:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="7cdd" class="kv kw hu kr b fv kx ky l kz la">setInterval(function() {<br/>  io.sockets.emit('message', 'hi!');<br/>}, 1000);</span></pre><p id="ae6e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将向所有连接的套接字发送名为“message”和内容为“hi”的消息。记住稍后删除这段代码，因为它只是用于测试。</p><p id="b7d6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh lb lc ld kr b">static</code>目录下创建一个名为<code class="eh lb lc ld kr b">game.js</code>的文件。我们可以编写一个快速函数来记录来自服务器的消息，以便验证我们正在接收它们。将以下内容放入<code class="eh lb lc ld kr b">static/game.js</code>:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="7adf" class="kv kw hu kr b fv kx ky l kz la">var socket = io();<br/>socket.on('message', function(data) {<br/>  console.log(data);<br/>});</span></pre><figure class="km kn ko kp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lf"><img src="../Images/4380e59fca5377777c65b750ca548fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIUN3v-TfazP2H_lfj1VyQ.png"/></div></div></figure><p id="4a55" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行服务器(使用命令<code class="eh lb lc ld kr b">node server.js</code>)并在任何web浏览器中导航到<a class="ae ke" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>。如果您打开开发人员控制台，您会注意到每秒钟都会出现一条消息(右键单击- &gt; Inspect)。</p><p id="b3d8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一般来说，<code class="eh lb lc ld kr b">socket.emit(name,data)</code>如果在客户端被调用，会向服务器端发送一条带有给定名称和数据的消息，反之亦然。要侦听具有特定名称的消息，您需要创建一个如下所示的事件处理程序:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="7420" class="kv kw hu kr b fv kx ky l kz la">socket.on('name', function(data) {<br/>  // data is a parameter containing whatever data was sent<br/>});</span></pre><p id="730b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可以使用<code class="eh lb lc ld kr b">socket.emit()</code>发送任何东西。您还可以将JSON对象传递给数据参数，这对我们来说非常方便。这允许我们在服务器和客户端之间即时地来回发送游戏信息，形成了大多数多人游戏功能的主干。</p><p id="062c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让客户端发送一些键盘状态。将以下代码放在<code class="eh lb lc ld kr b">static/game.js</code>的末尾:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="ed7a" class="kv kw hu kr b fv kx ky l kz la">var movement = {<br/>  up: false,<br/>  down: false,<br/>  left: false,<br/>  right: false<br/>}<br/>document.addEventListener('keydown', function(event) {<br/>  switch (event.keyCode) {<br/>    case 65: // A<br/>      movement.left = true;<br/>      break;<br/>    case 87: // W<br/>      movement.up = true;<br/>      break;<br/>    case 68: // D<br/>      movement.right = true;<br/>      break;<br/>    case 83: // S<br/>      movement.down = true;<br/>      break;<br/>  }<br/>});<br/>document.addEventListener('keyup', function(event) {<br/>  switch (event.keyCode) {<br/>    case 65: // A<br/>      movement.left = false;<br/>      break;<br/>    case 87: // W<br/>      movement.up = false;<br/>      break;<br/>    case 68: // D<br/>      movement.right = false;<br/>      break;<br/>    case 83: // S<br/>      movement.down = false;<br/>      break;<br/>  }<br/>});</span></pre><p id="f8cf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一些输入处理程序的基本代码，用来跟踪WASD键何时被按下。在这之后，我们将添加一条消息来提醒服务器有新玩家加入，并创建一个循环来不断地向服务器发送他们的键盘输入。</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="f340" class="kv kw hu kr b fv kx ky l kz la">socket.emit('new player');<br/>setInterval(function() {<br/>  socket.emit('movement', movement);<br/>}, 1000 / 60);</span></pre><p id="c961" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这将每秒钟向服务器发送60次该客户端的键盘状态。现在我们需要在服务器上处理这个输入。将以下内容添加到<code class="eh lb lc ld kr b">server.js</code>的末尾:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="3ed7" class="kv kw hu kr b fv kx ky l kz la">var players = {};<br/>io.on('connection', function(socket) {<br/>  socket.on('new player', function() {<br/>    players[socket.id] = {<br/>      x: 300,<br/>      y: 300<br/>    };<br/>  });<br/>  socket.on('movement', function(data) {<br/>    var player = players[socket.id] || {};<br/>    if (data.left) {<br/>      player.x -= 5;<br/>    }<br/>    if (data.up) {<br/>      player.y -= 5;<br/>    }<br/>    if (data.right) {<br/>      player.x += 5;<br/>    }<br/>    if (data.down) {<br/>      player.y += 5;<br/>    }<br/>  });<br/>});</span><span id="6618" class="kv kw hu kr b fv le ky l kz la">setInterval(function() {<br/>  io.sockets.emit('state', players);<br/>}, 1000 / 60);</span></pre><p id="0153" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们来分析一下。我们将把所有连接的玩家存储为JavaScript字典(JSON对象)。因为连接到服务器的每个套接字都有一个唯一的ID，所以我们也可以使用这个ID来标识玩家。字典中的每个键将是所连接的播放器的套接字的套接字ID，值将是包含x和y位置的另一个字典。</p><p id="94f9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当服务器接收到“新玩家”消息时，它将使用发送该消息的套接字的ID在玩家对象中添加一个新条目。当服务器收到“移动”消息时，它将更新与该套接字关联的播放器(如果存在的话)。</p><p id="88a8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh lb lc ld kr b">io.sockets.emit()</code>是一个调用，它将给定的消息和数据发送到所有连接的套接字。服务器将每秒60次向所有连接的客户端发送其状态。</p><p id="2a43" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这一点上，客户端实际上并没有对这些信息做任何事情，所以让我们在客户端添加一个处理程序，将服务器上的数据绘制到HTML5画布上。将此代码添加到<code class="eh lb lc ld kr b">static/game.js</code>的末尾:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="d87c" class="kv kw hu kr b fv kx ky l kz la">var canvas = document.getElementById('canvas');<br/>canvas.width = 800;<br/>canvas.height = 600;<br/>var context = canvas.getContext('2d');<br/>socket.on('state', function(players) {<br/>  context.clearRect(0, 0, 800, 600);<br/>  context.fillStyle = 'green';<br/>  for (var id in players) {<br/>    var player = players[id];<br/>    context.beginPath();<br/>    context.arc(player.x, player.y, 10, 0, 2 * Math.PI);<br/>    context.fill();<br/>  }<br/>});</span></pre><p id="05bd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这段代码访问画布并在其上进行绘制。每次从服务器收到“状态”消息时，客户端将清空画布，并将所有玩家重新绘制为画布上的绿色圆圈。</p><p id="f4e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">任何连接的客户端现在都可以将所有连接的玩家的状态绘制到画布上。运行服务器(再次使用命令<code class="eh lb lc ld kr b">node server.js</code>)并在web浏览器中打开两个选项卡。如果您导航到<a class="ae ke" href="http://localhost:5000," rel="noopener ugc nofollow" target="_blank"> http://localhost:5000，</a>，您应该会看到类似这样的行为:</p><figure class="km kn ko kp fq iv"><div class="bz el l di"><div class="lg lh l"/></div></figure><p id="6e8a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">差不多就是这样！如果你跟不上，这里有一个到包含这个最小实现的库的链接。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="dd5a" class="kv kw hu bd li lj lk ll lm ln lo lp lq jr lr ls lt jv lu lv lw jz lx ly lz ma dt translated">提示和技巧</h2><p id="5a6f" class="pw-post-body-paragraph jg jh hu ji b jj mb jl jm jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">如果您正在制作一个真实的游戏，那么将本演示中使用的大量代码重构到它们自己的文件中会是一个更好的主意。</p><p id="7d6e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这些多人游戏是MVC架构的很好的例子。所有的游戏逻辑都应该在服务器上处理，客户端唯一应该做的事情就是将用户输入发送到服务器，并呈现服务器发送的信息。</p><p id="b613" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">尽管这个演示项目有一些缺陷。游戏更新依赖于套接字监听器。如果我想改变游戏状态，我可以在检查器中输入以下内容:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="1e3b" class="kv kw hu kr b fv kx ky l kz la">while (true) {<br/>  socket.emit('movement', { left: true });<br/>}</span></pre><p id="b4db" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">根据电脑的不同，运动数据现在每秒钟被发送到服务器超过60次，导致玩家开始疯狂地快速移动。这让我想到了另一个被称为权威服务器确定的概念。</p><p id="b942" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在任何时候，客户端都不应该控制服务器上的任何数据。例如，您不应该在服务器上编写允许客户端根据通过套接字传递的数据来设置其位置/健康状况的代码，因为用户可以很容易地伪造从套接字发出的消息，如上所述。</p><p id="c8d6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我构建我的第一个多人游戏时，我对它进行了编码，这样每当发送“射击”消息时，玩家就会射击，这与客户端的鼠标按下事件相关联。<a class="ae ke" href="http://jjl.nu/" rel="noopener ugc nofollow" target="_blank">一个聪明的玩家</a>能够通过注入一行与上面非常相似的JavaScript来利用这一点，从而获得近乎无限的拍摄速度。</p><p id="0994" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我能做的最好的类比是，客户端应该只发送<em class="mg">意图</em>到服务器，然后被处理并用于修改玩家的状态，如果它们是有效的。</p><p id="2c18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">理想情况下，客户机和服务器上的更新循环应该独立于套接字。尽量不要让你的游戏在一个<code class="eh lb lc ld kr b">socket.on()</code>块中更新，因为你会有很多不稳定的行为，因为你的游戏更新将与你的套接字更新绑定在一起。</p><p id="0d96" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此外，尽量避免类似这样的代码:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="6ce3" class="kv kw hu kr b fv kx ky l kz la">setInterval(function() {<br/>  // code ...<br/>  player.x += 5;<br/>  // code ...<br/>}, 1000 / 60);</span></pre><p id="06ad" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这个代码片段中，玩家的x位置更新与游戏的帧速率相关联。<code class="eh lb lc ld kr b">setInterval()</code>并不总是保证在给定的时间间隔内运行，特别是当运行的函数计算量很大并且运行时间超过60秒时。相反，您应该这样做:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="9156" class="kv kw hu kr b fv kx ky l kz la">var lastUpdateTime = (new Date()).getTime();<br/>setInterval(function() {<br/>  // code ...<br/>  var currentTime = (new Date()).getTime();<br/>  var timeDifference = currentTime - lastUpdateTime;<br/>  player.x += 5 * timeDifference;<br/>  lastUpdateTime = currentTime;<br/>}, 1000 / 60);</span></pre><p id="51d2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是很多沉闷，但将保证更平滑和更一致的行为，通过计算时间之间的最后一次更新和当前时间，以计算出适当的距离来移动球员。派生演示项目并尝试实现上面的代码。加入一些功能，尝试制作一款成熟的游戏。</p><p id="a6b1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">另一件要实现的事情可能是移除断开连接的播放器。当套接字断开连接时，会自动发送一条名为“disconnect”的消息，因此您可以使用:</p><pre class="km kn ko kp fq kq kr ks kt aw ku dt"><span id="684a" class="kv kw hu kr b fv kx ky l kz la">io.on('connection', function(socket) {<br/>  // other handlers ...<br/>  socket.on('disconnect', function() {<br/>    // remove disconnected player<br/>  });<br/>});</span></pre><p id="d05d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">试着在服务器上写你自己的物理引擎，这很有趣，也是一个很大的挑战。如果你想试试这个，我强烈推荐阅读<a class="ae ke" href="http://natureofcode.com/book/" rel="noopener ugc nofollow" target="_blank">《代码的本质》</a>，因为它提供了很多有用的见解。</p><p id="c044" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你想看一个更高层次的例子，这里有一个我做的多人游戏，以及一个链接到它的<a class="ae ke" href="https://github.com/penumbragames/tankanarchy" rel="noopener ugc nofollow" target="_blank">源代码</a>，如果你想细读我是怎么做的。我目前只有这些了。感谢阅读！如果你喜欢这篇文章，请点击下面的拍手按钮:)</p><p id="5883" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">编辑:<a class="ae ke" rel="noopener" href="/@omgimanerd/how-to-build-a-multiplayer-browser-game-part-2-2edd112aabdf#.imv6b3b33">我已经发表了这篇文章的第2部分！</a></p><p id="5456" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在推特上关注我:<a class="ae ke" href="http://twitter.com/omgimanerd" rel="noopener ugc nofollow" target="_blank"> @omgimanerd </a></p><div class="km kn ko kp fq ab cb"><figure class="mh iv mi mj mk ml mm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mh iv mi mj mk ml mm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mh iv mi mj mk ml mm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mn mo mp"><p id="f922" class="jg jh mg ji b jj jk jl jm jn jo jp jq mq js jt ju mr jw jx jy ms ka kb kc kd hn dt translated"><a class="ae ke" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ke" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ke" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ke" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jg jh mg ji b jj jk jl jm jn jo jp jq mq js jt ju mr jw jx jy ms ka kb kc kd hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ke" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ke" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="km kn ko kp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mt"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="km kn ko kp fq iv"><div class="bz el l di"><div class="mu lh l"/></div></figure></div></div>    
</body>
</html>