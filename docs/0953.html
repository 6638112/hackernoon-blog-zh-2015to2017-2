<html>
<head>
<title>How to log in Apache Spark, a functional approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何登录Apache Spark，一种函数式方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-log-in-apache-spark-a-functional-approach-e48ffbbd935b?source=collection_archive---------0-----------------------#2016-07-23">https://medium.com/hackernoon/how-to-log-in-apache-spark-a-functional-approach-e48ffbbd935b?source=collection_archive---------0-----------------------#2016-07-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="305f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">登录Apache Spark非常容易，因为Spark提供了对开箱即用的<em class="jp"> log </em>对象的访问。只需要完成一些配置设置。在上一篇<a class="ae jq" rel="noopener" href="/@anicolaspp/how-to-log-in-apache-spark-f4204fad78a#.7asl0yplw"><strong class="it hv"><em class="jp"/></strong></a><strong class="it hv"><em class="jp"/></strong>中，我们已经看到了如何做到这一点，同时也展示了一些可能出现的问题。然而，当我们想要收集日志时，所提出的解决方案可能会导致一些问题，因为它们分布在整个集群中。即使我们利用<strong class="it hv"> Yarn </strong>日志聚合功能，也会有一些可能影响性能的争用，甚至更糟，在某些情况下，我们可能会以日志交错破坏日志本身的性质而告终，它们应该呈现时间排序属性。</p><p id="2119" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了解决这些问题，需要采取一种不同的方法，一种功能性的方法。</p><h2 id="6b67" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">单子作者</h2><p id="a193" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我不打算讨论关于单子的细节，或者在这种特殊情况下，单子作者，如果你有兴趣了解更多，看看这个链接(<a class="ae jq" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="jp">函子，应用，和单子</em> </strong> </a>),它提供了关于这个主题的很多信息。</p><p id="294b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了便于理解，我们假设monad writer(<strong class="it hv"><em class="jp">【writer】</em></strong>)是一个容器，除了保存值的历史记录(log)之外，还保存计算的当前值(值的转换集)。</p><p id="d207" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为<strong class="it hv"> <em class="jp"> writer </em> </strong>的单子属性，它允许我们做函数转换，我们很快就会看到一切是如何粘在一起的。</p><h2 id="c555" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">简单的日志</h2><p id="a2c4" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">下面的代码演示了一个简单的日志。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="7b79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">唯一需要注意的是，日志记录实际上发生在Spark驱动程序上，所以我们没有同步或争用问题。一旦我们开始分配计算，一切都开始变得复杂。</p><p id="b811" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下代码行不通(看<a class="ae jq" rel="noopener" href="/@anicolaspp/how-to-log-in-apache-spark-f4204fad78a#.7asl0yplw"> <strong class="it hv"> <em class="jp">上一篇</em> </strong> </a>就知道为什么了)</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="dcc8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<a class="ae jq" rel="noopener" href="/@anicolaspp/how-to-log-in-apache-spark-f4204fad78a#.7asl0yplw"> <strong class="it hv"> <em class="jp">之前的文章</em> </strong> </a>中也提出了一个解决方案，但是需要额外的工作来管理日志。</p><p id="7b80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们开始登录集群的每个节点，我们需要转到每个节点，收集每个日志文件，以便理解日志中的内容。希望您正在使用某种工具来帮助您完成这项任务，例如Splunk、Datalog等，但是您仍然需要了解很多东西才能将这些日志输入到您的系统中。</p><h2 id="b17f" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">我们的数据集</h2><p id="b5b9" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我们的数据集是Person类的集合，它将被转换，同时保持对数据集操作的统一日志。</p><p id="beb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">假设我们希望加载数据集，然后过滤每个年龄小于20岁的人，最后提取其姓名。这是一个非常愚蠢的例子，但它将演示日志是如何产生的。您可以替换这些计算，但是构建统一日志的想法将会保留。</p><h2 id="2b96" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">获取编写器</h2><p id="4202" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我们将使用<a class="ae jq" href="http://typelevel.org/projects/" rel="noopener ugc nofollow" target="_blank"><em class="jp">type level/Cats</em></a><em class="jp"/>库来导入monad writer，为此我们将下面一行添加到我们的<strong class="it hv"> <em class="jp"> build.sbt </em> </strong>文件中。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><h2 id="0424" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">玩弄我们的数据</h2><p id="f54c" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">现在，让我们定义将要使用的转换。</p><p id="472e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们加载数据。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="7ae9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里的<strong class="it hv"> <em class="jp"> ~ &gt; </em> </strong>操作通过隐式转换定义如下。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="ddf8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你仔细观察，我们的加载操作不是返回一个RDD，事实上，它返回的是跟踪日志的monad writer。</p><p id="25dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们定义要应用于用户集合的过滤器。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="baac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样，我们应用相同的函数(<strong class="it hv"> ~ &gt; </strong>)来跟踪这个转换。</p><p id="b90b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们定义映射，它遵循我们刚刚看到的相同模式。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><h2 id="a1d0" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">把它放在一起</h2><p id="db37" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">到目前为止，我们只定义了我们的转换，但是我们需要把它们粘在一起。Scala <strong class="it hv"> <em class="jp"> for </em> </strong>是一种非常方便的处理一元结构的方式。让我们看看怎么做。</p><figure class="kr ks kt ku fq kv"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="ab50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，<strong class="it hv">结果</strong>是类型:<strong class="it hv"> <em class="jp">作家【列表【字符串】，RDD【字符串】</em> </strong>。</p><p id="34a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调用<strong class="it hv"> result.run </strong>会给我们<strong class="it hv">log:List【String】</strong>和最终计算用<strong class="it hv">rdd</strong>:<strong class="it hv"><em class="jp">RDD【String】</em></strong>表示。</p><p id="7ed8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，我们可以使用<em class="jp"> Spark logger </em>来写下由转换链生成的日志。请注意，该操作将在Spark master上执行，这意味着将创建一个包含所有日志信息的日志文件。此外，我们正在消除日志写入期间潜在的争用问题。此外，我们没有锁定日志文件，这通过以串行方式创建和写入文件来避免性能问题。</p><h2 id="034d" class="jr js hu bd jt ju jv jw jx jy jz ka kb jc kc kd ke jg kf kg kh jk ki kj kk kl dt translated">结论</h2><p id="c5cb" class="pw-post-body-paragraph ir is hu it b iu km iw ix iy kn ja jb jc ko je jf jg kp ji jj jk kq jm jn jo hn dt translated">我们已经通过使用<em class="jp"> Monad Writer </em>改进了我们登录Apache Spark的方式。这种函数式方法允许我们将日志的创建与我们的计算一起分发，这是Spark非常熟悉的。但是，我们没有将日志写在每个worker节点上，而是将它们收集回主节点上进行记录。这种机制比我们以前的实现有一定的优势。现在，我们可以精确控制日志的写入方式和写入时间，通过消除工作节点上的IO操作来提高性能，通过以串行方式写入日志来消除同步问题，并且避免了在整个集群中记录日志的风险。</p><blockquote class="ky kz la"><p id="4cff" class="ir is jp it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated"><a class="ae jq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is jp it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">要了解更多信息，<a class="ae jq" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">请阅读我们的“关于”页面</a>，<a class="ae jq" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jq" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>