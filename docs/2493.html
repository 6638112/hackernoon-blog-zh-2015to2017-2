<html>
<head>
<title>Selenium testing: a new hope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">硒测试:新的希望</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/selenium-testing-a-new-hope-7fa87a501ee9?source=collection_archive---------1-----------------------#2017-01-31">https://medium.com/hackernoon/selenium-testing-a-new-hope-7fa87a501ee9?source=collection_archive---------1-----------------------#2017-01-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><h1 id="24d4" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">第一部分.问题和初步解决办法。</h1><p id="8cb6" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">2004年启动的Selenium项目现在已经成为浏览器自动化的行业标准。然而如果你的QA部门相对较大，你迟早会面临到推荐<a class="ae kn" href="https://hackernoon.com/tagged/selenium" rel="noopener ugc nofollow" target="_blank">硒</a>T4】架构的局限。在本文中，我将告诉您如何轻松创建一个可伸缩且容错的Selenium解决方案。</p><h1 id="da59" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">问题</h1><p id="7947" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">自2004年创建第一个原型以来，Selenium架构发生了几次根本性的变化。当前在2.0分支中引入的Selenium架构被称为Selenium Grid。它的工作原理如下:</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/68e21802964fed714417c2a3282e1555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlbOhAwUBU7gil56Mx7jqw.png"/></div></div></figure><p id="4985" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">通常一个集群由两个守护程序应用程序组成:Selenium Hub和Selenium Node。一个<strong class="jr hv"> hub </strong>是一个API，它处理用户请求并将它们重定向到各自的节点。一个<strong class="jr hv">节点</strong>是一个实际的请求执行器，它启动浏览器进程并向它们请求所需的测试步骤。理论上，一个Selenium Hub可以连接无限数量的Selenium节点，每个节点都可以启动任何已安装的浏览器。但是实际上呢？</p><ol class=""><li id="b91d" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km lk ll lm ln dt translated">这样的架构有一个薄弱的部分。Selenium Hub是一个单一的浏览器访问点。如果它关闭或没有响应，所有浏览器都不可用。如果带有集线器的数据中心断电或网络出现故障，也会发生同样的情况。</li><li id="b4c2" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">Selenium Grid的伸缩性不好。我们5年多的Selenium集群专业经验表明，即使在中等负载下，一个集线器也可以与有限数量的连接节点一起工作。根据硬件的不同，即使有几十个连接的节点也会显著增加集线器的响应时间。</li><li id="c5db" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">没有报价功能。您不能创建用户和指定浏览器消费限制。</li></ol><h1 id="41fa" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">解决方法</h1><p id="a0ce" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最简单的可扩展方法是使用分布在多个数据中心的多个Selenium Hubs。然而，标准的Selenium库只能与一个Selenium hub一起工作。我们需要教会他们使用这样的分布式系统。</p><h1 id="b65c" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">客户端负载平衡</h1><p id="a1cb" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">几年前，我们成功使用的一个初始方法是客户端负载平衡的客户端库。它是这样工作的:</p><ol class=""><li id="0881" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km lk ll lm ln dt translated">我们在多个数据中心推出了多个Selenium Hubs和相应的节点。</li><li id="ea1f" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">支持浏览器的集线器主机名列表保存到文件中。</li><li id="d3cf" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">Selenium用户将一个小型客户端库作为其测试的依赖项，并使用该库请求一个selenium会话。</li><li id="fe18" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">库通过集线器读取文件，并随机选择其中一个具有所需浏览器的文件。然后，它请求使用标准Selenium客户端的浏览器。</li><li id="ec54" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">如果会话创建成功，那么测试步骤开始执行。否则，库会尝试另一个集线器主机，直到创建了会话。不同的集线器可以包含不同数量的浏览器。为了实现均匀的负载分布，我们需要为集线器主机分配不同的权重，然后根据权重选择这些主机。</li><li id="c017" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">如果客户机无法在列表中的每个集线器上创建会话，它应该会抛出一个错误。</li></ol><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/78351861444a0932c6ddf3e850d77129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdDlRHf-0knRXSJ2WFSv1g.png"/></div></div></figure><p id="3772" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">应该更改一行测试代码(新的会话请求)来支持该库。例如，在Java测试中，一个新的会话请求可能如下所示:</p><pre class="kp kq kr ks fq lt lu lv lw aw lx dt"><span id="c66b" class="ly is hu lu b fv lz ma l mb mc">WebDriver driver = <br/> new RemoteWebDriver("http://my-hub.example.com:4444/wd/hub", caps);</span></pre><p id="a7f0" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">这段代码中的所有类都来自一个标准的Selenium Java客户端。例如，如果客户端库被称为SeleniumHubFinder，则新的会话请求将如下所示:</p><pre class="kp kq kr ks fq lt lu lv lw aw lx dt"><span id="99bb" class="ly is hu lu b fv lz ma l mb mc">WebDriver driver = SeleniumHubFinder.find(caps);</span></pre><p id="6bab" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">更新后的代码中没有使用Selenium hub URL该信息存储在客户端库中。就是这样！这种方法多年来一直有效。我们公司的数百名软件测试人员都很满意。使用客户端库有什么弊端？</p><ol class=""><li id="15d9" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km lk ll lm ln dt translated">应该向每个测试项目添加一个补充库。没有这个库，您无法启动您的测试。</li><li id="18af" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">应该为每种语言实现单独的客户端库。例如，您的公司中可能存在Javascript、Java或Python Selenium测试。在这种情况下，您需要支持多个客户端库，并确保中心列表同步。这就是为什么服务器端解决方案是必要的。</li></ol><h1 id="5df0" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">服务器端负载平衡</h1><p id="0846" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">根据我们在客户端解决方案方面的经验，我们向服务器端解决方案引入了以下自然需求:</p><ol class=""><li id="ffd5" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km lk ll lm ln dt translated">对于客户端库来说，服务器应该看起来像Selenium hub。为此，它应该实现<a class="ae kn" href="https://w3c.github.io/webdriver/webdriver-spec.html" rel="noopener ugc nofollow" target="_blank"> Selenium JsonWire协议</a>。</li><li id="3854" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">可以在任何数据中心安装任意数量的服务器节点。它们可以安装在任何软件或硬件负载平衡器的后面。</li><li id="988b" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">服务器实例是无状态的。它们既不使用数据库服务器也不使用队列服务器来共享状态。</li><li id="e5f3" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">服务器应支持多用户和报价。</li></ol><p id="f4c8" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">我们称这个服务器为GridRouter，因为它唯一做的事情就是将用户请求路由到正确的Selenium网格中心。这是新的架构:</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/39d766276b74b45a19ad2c1cde02abd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lozUzrS_1HY00034h4IDyQ.png"/></div></div></figure><ul class=""><li id="3352" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km md ll lm ln dt translated">负载平衡器将用户请求分布在多个GridRouter实例中。</li><li id="8561" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km md ll lm ln dt translated">每个GridRouter实例都像客户端库一样存储所有可用Selenium Hubs的信息。</li><li id="fa55" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km md ll lm ln dt translated">为了处理新的会话请求，GridRouter使用相同的随机分配算法。</li><li id="3172" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km md ll lm ln dt translated">您可能知道，Selenium中的每个新浏览器会话都会自动获得一个名为会话ID的ID。根据Selenium JSONWire协议，这个ID总是被传递给请求。GridRouter将有关所选Selenium Hub的信息附加到该会话中，并将丰富的会话ID返回给用户。</li><li id="a85b" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km md ll lm ln dt translated">在获得会话之后，GridRouter在每个后续请求上从丰富的会话ID中提取所使用的Selenium Hub信息，并简单地将其代理给相应的Hub。因为所有会话信息都存储在它的ID中，所以不需要同步GridRouter实例。这就是为什么GridRouter是无状态的。</li></ul><h1 id="88bf" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">栅格路由器</h1><p id="62c3" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">最初我们使用Java、<a class="ae kn" href="https://eclipse.org/jetty/" rel="noopener ugc nofollow" target="_blank"> Jetty </a>和<a class="ae kn" href="http://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Framework </a>实现了GridRouter。它的源代码可以在<a class="ae kn" href="https://github.com/seleniumkit/gridrouter" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。这个实现使用一个纯文本属性文件来存储用户列表，使用一个XML文件来保存每个用户的Selenium hubs列表。典型的用户列表(默认为<strong class="jr hv">/etc/grid-router/users . properties</strong>)如下所示:</p><pre class="kp kq kr ks fq lt lu lv lw aw lx dt"><span id="44be" class="ly is hu lu b fv lz ma l mb mc">user:password, user<br/>user2:password2, user</span></pre><p id="bd9b" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">每行对应一个用户。当前实现中的密码是在没有任何加密的情况下存储的。这是因为我们考虑到用户主要需要考虑不同团队的浏览器消耗。Selenium hub列表存储在以下格式的XML文件中(默认为<strong class="jr hv"> /etc/grid-router/quota/*)。xml </strong>):</p><pre class="kp kq kr ks fq lt lu lv lw aw lx dt"><span id="4faa" class="ly is hu lu b fv lz ma l mb mc">&lt;qa:browsers xmlns:qa="urn:config.gridrouter.qatools.ru"&gt;<br/>  &lt;browser name="firefox" defaultVersion="33.0"&gt;<br/>    &lt;version number="33.0"&gt;<br/>      &lt;region name="us-west"&gt;<br/>        &lt;host name="ff33-hub-1.example.com" port="4444" count="5"/&gt;<br/>      &lt;/region&gt;<br/>      &lt;region name="us-east"&gt;<br/>        &lt;host name="ff33-hub-2.example.com" port="4444" count="5"/&gt;<br/>      &lt;/region&gt;<br/>    &lt;/version&gt;<br/>    &lt;version number="37.0"&gt;<br/>      &lt;region name="us-west"&gt;<br/>        &lt;host name="ff37-hub-1.example.com" port="4444" count="3"/&gt;<br/>        &lt;host name="ff37-hub-2.example.com" port="4444" count="4"/&gt;<br/>      &lt;/region&gt;<br/>      &lt;region name="us-east"&gt;<br/>        &lt;host name="ff37-hub-3.example.com" port="4444" count="2"/&gt;<br/>      &lt;/region&gt;<br/>    &lt;/version&gt;<br/>  &lt;/browser&gt;<br/>  &lt;browser name="chrome" defaultVersion="42.0"&gt;<br/>    &lt;version number="42.0"&gt;<br/>      &lt;region name="us-west"&gt;<br/>        &lt;host name="ch42-hub-1.example.com" port="4444" count="10"/&gt;<br/>      &lt;/region&gt;<br/>      &lt;region name="us-east"&gt;<br/>        &lt;host name="ch42-hub-2.example.com" port="4444" count="10"/&gt;<br/>      &lt;/region&gt;<br/>    &lt;/version&gt;<br/>  &lt;/browser&gt;<br/>&lt;/qa:browsers&gt;</span></pre><p id="a649" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">您可以看到，我们定义了可用的浏览器名称、它们的版本以及分布在多个地区的一组主机。在我们看来，一个区域就是一个数据中心。如果一个数据中心出现故障，主要需要有关数据中心的信息。如果第一次会话尝试失败，我们将从另一个数据中心选择主机。这种方法增加了更快创建Selenium会话的可能性。</p><h1 id="062f" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">在测试中使用GridRouter</h1><p id="fc09" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">正如我前面说过的，GridRouter实现了标准的Selenium协议，并且与所有现有的客户端库完全兼容。我们剩下的主题是如何在GridRouter中进行身份验证，即指定我们想要使用的配额。所有Selenium客户端库都只支持一种认证方法— <a class="ae kn" href="https://en.wikipedia.org/wiki/Basic_access_authentication" rel="noopener ugc nofollow" target="_blank">基本HTTP认证</a>。这就是为什么GridRouter也只支持这种方法。通常Selenium hub的url如下:</p><pre class="kp kq kr ks fq lt lu lv lw aw lx dt"><span id="53c9" class="ly is hu lu b fv lz ma l mb mc">http://example.com:4444/wd/hub</span></pre><p id="40d1" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">您可能知道，基本的HTTP验证用户名和密码可以编码为URL，如下所示:</p><pre class="kp kq kr ks fq lt lu lv lw aw lx dt"><span id="b0dd" class="ly is hu lu b fv lz ma l mb mc">http://username:password@example.com:4444/wd/hub</span></pre><p id="cd4d" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">这是您在代码中使用GridRouter代替Selenium Hub所需要做的唯一更改。大多数Selenium客户端库(包括Java和Python实现)都使用这种符号。然而，一些基于Selenium的Javascript工具要求您将用户名和密码指定为单独的配置选项。</p><h1 id="fcb4" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">月球表面图</h1><p id="38c1" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">GridRouter允许我们停止使用客户端库。它让使用不同语言的用户可以访问可伸缩的Selenium安装。要扩展GridRouter的安装，只需向它的XML配置中添加更多Selenium hubs所有的更改都会自动应用，无需重启服务。为了每秒处理更多的请求，您还需要在负载均衡器后面添加GridRouter主机。我们的经验表明，当任何版本的浏览器的总使用百分比低于80%时，GridRouter都可以很好地工作。当峰值负载到来，浏览器消耗增长到总容量的90–100%时，问题就出现了。在这种情况下，随机统一会话尝试分布变得低效。</p><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff ko"><img src="../Images/bc9432bdfffc122162ff53ce89bf21ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxcYFUu4qFBdF8tyUsRJjQ.png"/></div></div></figure><p id="593b" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">我们太频繁地试图在完全占用的集线器上获取Selenium会话，并在将会话返回给用户之前尝试几个集线器。这增加了会话开始时间并降低了测试速度。我们在Selenium cluster开发中的下一个阶段旨在解决上述问题，这是一个名为<a class="ae kn" href="https://github.com/seleniumkit/selenograph" rel="noopener ugc nofollow" target="_blank">selenio graph</a>的新产品。Selenograph是一个基于GridRouter源代码的Java服务器，与它的配置文件完全兼容。主要区别是:</p><ol class=""><li id="2e50" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km lk ll lm ln dt translated">它是有状态的。为了在高负载下更高效，Selenograph使用了更复杂的算法来选择集线器主机。主要思想是通过考虑已经运行的会话总数来动态调整集线器主机权重。这个数字应该保存到月图节点之间共享的存储器中。我们使用<a class="ae kn" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>作为这样的存储。</li><li id="0622" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">它提供了更多的统计数据和用户友好的界面。例如，Selenograph API可以返回每个时刻并发运行的会话总数。虽然Selenograph是一个有状态的解决方案，但它被证实在高负载下可以正确工作，允许每秒钟为每个实例服务数百个请求。</li></ol><h1 id="4ff9" class="ir is hu bd it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo dt translated">结论</h1><p id="3870" class="pw-post-body-paragraph jp jq hu jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在这一部分中，我向您介绍了标准的Selenium可伸缩性问题，以及如何通过对集群架构进行少量更改来解决这些问题。在下一部分，我们将讨论以下主题:</p><ol class=""><li id="d747" class="lf lg hu jr b js la jw lb ka lh ke li ki lj km lk ll lm ln dt translated">如何为大型集群准备工作节点，使其能够很好地扩展</li><li id="cf5c" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">关于最近硒未来的一些思考</li><li id="3fc8" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">如何在Docker容器中运行Selenium</li><li id="92de" class="lf lg hu jr b js lo jw lp ka lq ke lr ki ls km lk ll lm ln dt translated">有哪些新的开源工具可以帮助您部署一个高效的低资源消耗的Selenium集群</li></ol><p id="f9c0" class="pw-post-body-paragraph jp jq hu jr b js la ju jv jw lb jy jz ka lc kc kd ke ld kg kh ki le kk kl km hn dt translated">敬请关注…</p><div class="kp kq kr ks fq ab cb"><figure class="me kt mf mg mh mi mj paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="me kt mf mg mh mi mj paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="me kt mf mg mh mi mj paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mk ml mm"><p id="f922" class="jp jq mn jr b js la ju jv jw lb jy jz mo lc kc kd mp ld kg kh mq le kk kl km hn dt translated"><a class="ae kn" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae kn" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae kn" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae kn" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jp jq mn jr b js la ju jv jw lb jy jz mo lc kc kd mp ld kg kh mq le kk kl km hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae kn" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae kn" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kp kq kr ks fq kt fe ff paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="fe ff mr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kp kq kr ks fq kt"><div class="bz el l di"><div class="ms mt l"/></div></figure></div></div>    
</body>
</html>