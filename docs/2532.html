<html>
<head>
<title>Lighting by hand #1: the thin dark line</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">手工照明#1:细黑线</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/pico-8-lighting-part-1-thin-dark-line-8ea15d21fed7?source=collection_archive---------0-----------------------#2017-02-02">https://medium.com/hackernoon/pico-8-lighting-part-1-thin-dark-line-8ea15d21fed7?source=collection_archive---------0-----------------------#2017-02-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="774c" class="hs ht hu bd b gc hv hw hx hy hz ia ek ib translated" aria-label="kicker paragraph">皮科-8</h2><div class=""/><p id="e678" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">两周前，我对在微型幻想控制台<a class="ae jy" href="http://www.lexaloffle.com/pico-8.php" rel="noopener ugc nofollow" target="_blank"> PICO-8 </a>上进行某种形式的实时照明的想法产生了兴趣。我想我会摆弄它一段时间，并决定它不可能在弱小的模拟CPU上，但这被证明是错误的——<a class="ae jy" href="https://hackernoon.com/tagged/pico-8" rel="noopener ugc nofollow" target="_blank">PICO-8</a>毕竟被证明是一个相当强大的机器！从事这项工作是如此有趣，以至于我无法停止推动它，添加新功能并优化它背后的引擎，直到我达到这一点:</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff jz"><img src="../Images/750376dd66388ea28a73288433733ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*9suDQZVNPDgrrkgEoJWZfw.gif"/></div></figure><p id="e048" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我已经为此工作了很长一段时间，并愉快地在推特上发布了它，慢慢地将这个引擎变成了一个<a class="ae jy" href="https://krajzeg.itch.io/dank-tomb" rel="noopener ugc nofollow" target="_blank">游戏</a>。然而，我最近让它以60 FPS运行，并开始得到一些令人不安的响应。</p><figure class="ka kb kc kd fq ke"><div class="bz el l di"><div class="kh ki l"/></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">And I’m all out of fairy dust.</figcaption></figure><p id="ae69" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">决心证明我不是一个女巫，我决定以<a class="ae jy" href="http://www.lexaloffle.com/bbs/?tid=28785" rel="noopener ugc nofollow" target="_blank">弹药筒</a>的形式发布魔法印加…代码，以及这些完全科学且完全不深奥的关于其工作原理的解释。</p><p id="ede0" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这里的一些东西将非常特定于引擎，而其他技术将有望更加通用，并适用于您想要大量优化的任何一段PICO-8代码。我试图保持帖子的可访问性，但我必须假设自己对<a class="ae jy" href="https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/hexadecimal-number-system" rel="noopener ugc nofollow" target="_blank">十六进制表示法</a>和<a class="ae jy" href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="noopener ugc nofollow" target="_blank">位运算</a>有些熟悉，只是为了将已经膨胀的字数保持在一个合理的水平。</p><h2 id="c5e6" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">当你只有一个调色板时，一切都是钉子</h2><p id="8f29" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">在现代游戏中，光照是由着色器在GPU上完成的，着色器具有24位色彩空间和每像素进行大量计算的能力。在PICO-8上，事情更离奇一些——任何与操纵颜色有关的事情通常都可以归结为一件事:<strong class="jc ie">调色板效果</strong>将16种颜色映射到不同的颜色。这是做基本淡入淡出的方法，灯光效果只是更复杂的淡入淡出。我们不是将所有像素均匀地向黑色移动相同的量，而是根据亮度来选择这个量。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/64a28a9b9da2ce98069b41189d8e5712.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*ZrEFgwuv9_6XlxmaFF0lyg.png"/></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">Palette: The Darkening</figcaption></figure><p id="e41b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">因此，我们知道我们的效果的基础将是设置几个调色板——每个调色板对应一个我们支持的照明等级。对于<em class="ln">阴湿的坟墓</em>，调色板#1基本上是一个什么也不做的调色板，因为它代表“全亮”。然后，我们有一些中间调色板，每个调色板中的颜色逐渐变暗。最后一个调色板将用于完全无光的区域——该调色板将每种颜色映射为黑色。</p><p id="6703" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我选择了六个照明级别，包括全亮度和全黑。每增加一个照明级别都是一个显著的性能提升——所以选择6作为最佳点。调色板保存在sprite内存中，并在初始化期间从其中读取—这样它们便于编辑，并且很容易看出什么颜色应该放在哪里才能正常工作。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/5966a8ec2ce77f0eb0600a28a1fae3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*g1loRQV3_0FPJxvIZZVzyw.png"/></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">The palettes (left-side for lighting, right side for fades)</figcaption></figure><h2 id="9671" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">选项，选项</h2><p id="6615" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">使用这些调色板时，基本上有两种选择:</p><ol class=""><li id="7a5f" class="lo lp hu jc b jd je jh ji jl lq jp lr jt ls jx lt lu lv lw dt translated">对于每一个要画的东西，首先设置正确的调色板(基于它是如何被照亮的)，然后画它。</li><li id="cc24" class="lo lp hu jc b jd lx jh ly jl lz jp ma jt mb jx lt lu lv lw dt translated">首先绘制完全照亮的一切，然后操纵屏幕上的像素来应用灯光效果。</li></ol><p id="6c04" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">第一种选择看起来更有吸引力，因为这正是PICO-8通过<code class="eh mc md me mf b">pal()</code>函数支持的。这种想法的问题是，光照水平的变化发生在对象的中间——所以我们要么不能让它看起来很正确(每个对象只支持一个光照水平)，要么我们必须用达到拜占庭复杂程度的遮罩/剪裁设置多次绘制每个对象。让我们甚至不去想需要什么来处理背景— <code class="eh mc md me mf b">map()</code>当每块瓷砖的灯光都改变一次时，肯定是不行的。</p><p id="093f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们只剩下第二种选择，相比之下，它简单得令人耳目一新。我们像平常一样先画出所有的东西，充分享受使用<code class="eh mc md me mf b">map()</code>和<code class="eh mc md me mf b">spr()</code>的乐趣。一旦我们完成了这些，我们就操纵屏幕上的每个像素来应用正确的调色板。</p><div class="ka kb kc kd fq ab cb"><figure class="mg ke mh mi mj mk ml paragraph-image"><img src="../Images/52b5d9c8708052dfbfa05ca2fe5ee7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*dEvI4BEHbm7a8yVnTTdqwg.png"/></figure><figure class="mg ke mm mi mj mk ml paragraph-image"><img src="../Images/cca3f59d6be85b6e974992325a460a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*D6a1pe0koKfqkfWh-isH1g.png"/><figcaption class="kj kk fg fe ff kl km bd b be z ek mn di mo mp">Before and after applying the filter</figcaption></figure></div><h2 id="564a" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">关于划分、征服和转移话题</h2><p id="9b3e" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">在我们深入编码之前，有必要花点时间考虑一下我们的过滤器是如何工作的。作为一个核心概念，它将是一系列以光为中心的同心圆盘——随着我们远离中心，每个圆盘应用更暗的照明水平。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/2941e8573e7380d33ed271bf4ea3c434.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*aGs64wYaC7iaDf25Ep372g.png"/></div></figure><p id="b405" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">编写代码一下子做到这一点有点令人生畏，但是每个复杂的任务都可以分解成简单的任务。在图形<a class="ae jy" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>中，有一个处理复杂形状的标准方法——将它们分解成<strong class="jc ie">条水平线</strong>。画一条水平线很简单，所以我们可以集中精力在一个紧凑的循环中实现我们想要的任何效果。与此同时，复杂的计算，包括确定在哪里画线，可以在一个单独的地方完成。</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div class="fe ff lm"><img src="../Images/52576c802022952aef2efdb382d4f6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*8SBfBgx7WANB1-Mj6idDFw.png"/></div></figure><p id="aa36" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这就是引擎的工作方式，本系列的第1部分将集中于尽可能快地淡化一条水平线，将可怕的细节留到以后的文章中讨论。这里我将主要使用伪代码——对于实际的、最终的代码，请在插件中查找<code class="eh mc md me mf b">fl_blend()</code>函数。</p><h2 id="68e8" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">如果你想把它做好，就自己动手</h2><p id="fbc2" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">在我进入三个完整段落的一般编程原则之前，我们决定在将所有东西都绘制到屏幕上之后，应用我们的效果<em class="ln">。</em></p><p id="b42e" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这种方法的问题是内置的PICO-8对调色板的支持不能帮助我们。如果我们有一个像<code class="eh mc md me mf b">spr()</code>一样工作的函数，但是从屏幕内存中复制数据，我们可以使用它——但是，唉，没有这样的东西。我们真不幸。</p><p id="af99" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这意味着我们必须手动完成所有工作。调色板只是将一种颜色的像素替换为一种新的颜色，因此应用调色板的简单方法如下:</p><pre class="ka kb kc kd fq mq mf mr ms aw mt dt"><span id="f6ba" class="kn ko hu mf b fv mu mv l mw mx"><strong class="mf ie">for each x, y we want to change:</strong><br/>  local pixel = pget(x, y)<br/>  local mapped_pixel = palette[pixel]<br/>  pset(x, y, mapped_pixel)</span></pre><p id="9162" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这非常简单，就像大多数琐碎的算法一样，非常慢。以这种方式对超过32x32的区域应用效果已经让我们丢帧了。这是因为<code class="eh mc md me mf b">pset()</code>和<code class="eh mc md me mf b">pget()</code>有很多额外的工作要做:他们必须裁剪坐标，应用相机位置，他们还必须处理一件额外的事情——我现在将更详细地解释这一点，因为这也将是我们解决问题背后的想法。</p><h2 id="7351" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">走向极端:PICO-8屏幕内存</h2><p id="2d1d" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">PICO-8模拟了一个老式的计算系统。我们的像素不存在于通过200MB驱动程序访问的独立GPU卡上的匿名屏幕缓冲纹理中。相反，它们只是在我们模拟的<a class="ae jy" href="http://pico-8.wikia.com/wiki/Memory" rel="noopener ugc nofollow" target="_blank"> RAM </a>中的地址0x6000处冷却，等待被直接操纵。</p><p id="d674" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">由于PICO-8只有16种颜色可用，16*16=256，我们虚拟硬件的设计者做出了明智的决定，在每个内存字节中存储两个像素。每个屏幕行的长度为64个字节，每个字节存储两个像素，如下所示:byte =(左像素)+ 16 *(右像素)。看起来是这样的:</p><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff my"><img src="../Images/0cc2d097a961c946e0662a5923170164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7is57BLgi-qAc7MJSjoYHw.png"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek">How it all fits (artist’s impression)</figcaption></figure><p id="5aaf" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这意味着<code class="eh mc md me mf b">pset()</code>有它的工作要做——它不仅处理剪辑/相机/调色板，它实际上必须进入正确的字节，并且只处理它的一半。这就是为什么它被模拟得非常慢的部分原因，也是为什么如果PICO-8是真正的硅，它会很慢。</p><h2 id="801f" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">偷看和抬头</h2><p id="3c13" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">幸运的是，我们可以避免<code class="eh mc md me mf b">pset()</code>所做的所有额外工作——我们可以在那个东西上疯狂科学家，直接操纵屏幕内存！由于超快的<code class="eh mc md me mf b">peek()</code>和<code class="eh mc md me mf b">poke()</code>功能，这变得很容易。</p><p id="1984" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">如果我们仔细想想，我们的过滤器没有理由一次只能处理一个像素。调色板基本上是一个16条目的表格，上面写着:对于颜色X，使用颜色Y。我们可以创建一个类似的表，但是有256个条目。这样，每个条目可以处理包含两个像素的整个字节(就像上面图像中代表红黄对的<code class="eh mc md me mf b">A8</code>),并同时对两者应用调色板，返回一个具有两种新颜色的新字节。</p><p id="1e34" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这是一种非常通用的技术，称为查找表，通过预先计算结果并在运行时在表中查找，可以加速各种效果。</p><p id="86d6" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">一旦我们在初始化期间根据sprite内存中的调色板准备好查找表，解决方案的第一个草图应该是这样的:</p><pre class="ka kb kc kd fq mq mf mr ms aw mt dt"><span id="b175" class="kn ko hu mf b fv mu mv l mw mx">local start = calculate_address(x1, y)<br/>local end = calculate_address(x2, y)<br/>for address = start, end do<br/>  poke(address, lookup[peek(address)])<br/>end</span></pre><p id="0878" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">这比<code class="eh mc md me mf b">pset()</code>快多了，但是因为我们是疯狂的科学家，我们不想要快——我们想要疯狂的快！</p><h2 id="6c9e" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">做更多的工作，做更少的工作</h2><p id="3eb7" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">就像以前一样，上面的一行程序有一个隐藏了大量额外工作的地方:<code class="eh mc md me mf b">lookup[…]</code>是一个秘密的性能猪。</p><p id="e8d6" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在像C这样的编译语言中，数组只是连续内存块。访问元素很简单:只需获取数组的地址，加上索引(乘以元素大小)，瞧！</p><p id="73e7" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在Lua中，表结构必须处理从简单数组到复杂嵌套对象的一切。我们知道我们的查找表只有整数作为索引，这并不重要。就Lua而言，我们可以在任何时候改变主意，比如说<code class="eh mc md me mf b">lookup[“banana”] = “cucumber”</code>毁了它的一天。这意味着Lua不能像C一样使用简单的数组表示，而是依赖较慢的哈希表。</p><p id="e7bb" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">作为疯狂的科学家，我们该怎么办？疯狂科学家总是做的事情——我们自己实现它！为了方便起见，PICO-8内存映射中保留了一大块内存，从0x4300开始。如果我们将查找表保存在内存中，我们可以用<code class="eh mc md me mf b">peek(tableaddr+index)</code>替换<code class="eh mc md me mf b">lookup[index]</code>，这样会快得多。</p><p id="8bfe" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">但是我们可以做得更好！我们的表正好有256字节长，所以如果我们把它们保持在“圆形”(0x？？00)地址，我们可以不用使用按位“或”(PICO-8上的<code class="eh mc md me mf b">bor()</code>)来代替加法，利用这个运算更快的优势。</p><p id="83dd" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">说了这么多，做了这么多，我们的循环现在看起来是这样的:</p><pre class="ka kb kc kd fq mq mf mr ms aw mt dt"><span id="3f17" class="kn ko hu mf b fv mu mv l mw mx">for screenaddr=start,end do<br/>  poke(screenaddr, <br/>    peek(<strong class="mf ie">bor(lutaddr,peek(screenaddr))</strong>)<br/>  )<br/>end</span></pre><p id="f970" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><em class="ln">看起来确实不像是一个进步</em>，但这不是第一次优化让事情变得丑陋。</p><h2 id="f542" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">排除万难</h2><p id="71db" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">我们的过滤器工作在可笑的速度，但像往常一样，还有一个问题。屏幕坐标就像人一样——大约有一半是奇数。当我们要画的线段在一个奇怪的X坐标上开始或结束时，我们不能改变整个字节——我们必须小心地只改变描述左(或右)像素的部分。</p><p id="3ef6" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">我们可以在循环中处理这个问题，但是在最经常重复的代码中添加条件句是最重要的优化。这就是为什么我们在主循环之外处理棘手的事情，小心翼翼地使用按位运算只改变半个字节:</p><pre class="ka kb kc kd fq mq mf mr ms aw mt dt"><span id="bbcf" class="kn ko hu mf b fv mu mv l mw mx">start = <strong class="mf ie">address of first full byte of our line</strong><br/><strong class="mf ie">if x1 is odd:</strong><br/>  local addr = start-1<br/>  local previous = peek(addr)<br/>  poke(addr, bor(<br/>   band(previous, 0xf),<br/>   band(<strong class="mf ie"><em class="ln">&lt;LUT[v]&gt;</em></strong>, 0xf0)<br/> ))</span></pre><p id="0142" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">对<code class="eh mc md me mf b">x2</code>也进行了类似的处理(但不幸的是当<code class="eh mc md me mf b">x2 </code>持平时)。真正的代码在这种情况下有一些额外的魔力，以便处理分数坐标，但是原理是一样的。</p><h2 id="958b" class="kn ko hu bd kp kq kr ks kt ku kv kw kx jl ky kz la jp lb lc ld jt le lf lg ia dt translated">行尾</h2><p id="60b1" class="pw-post-body-paragraph ja jb hu jc b jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt ll jv jw jx hn dt translated">第一部分到此结束。我们现在可以将一条水平线变暗，这可能还不足以给聚会上的人留下深刻印象。</p><p id="7c2f" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">但是不要害怕！下一篇帖子将会是关于我们的水平线的例行公事和把效果放在一起。所以，如果你有心情看更多疯狂的科学，请继续关注第2部分<a class="ae jy" href="https://hackernoon.com/lighting-by-hand-2-stitching-lines-together-24edc9f819bf#.nfio7en93" rel="noopener ugc nofollow" target="_blank"/>并在我的推特或lexaloffle.com论坛<a class="ae jy" href="http://www.lexaloffle.com/bbs/?cat=7" rel="noopener ugc nofollow" target="_blank"/>上寻找。如果您喜欢这个部分，请告诉我，如果您有任何问题，请随时在推特上与我联系。</p><p id="1c1b" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated">在那之前，祝你在PICO-8上玩得开心！</p><p id="519c" class="pw-post-body-paragraph ja jb hu jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx hn dt translated"><strong class="jc ie"> <em class="ln">第一部分</em> </strong> <em class="ln"> | </em> <a class="ae jy" href="https://hackernoon.com/lighting-by-hand-2-stitching-lines-together-24edc9f819bf#.nfio7en93" rel="noopener ugc nofollow" target="_blank"> <em class="ln">第二部分</em> </a> <em class="ln"> | </em> <a class="ae jy" href="https://hackernoon.com/lighting-by-hand-3-breath-of-life-7a775617697e#.tbtcy74bb" rel="noopener ugc nofollow" target="_blank"> <em class="ln">第三部分</em> </a> <em class="ln"> | </em> <a class="ae jy" href="https://hackernoon.com/lighting-by-hand-4-into-the-shadows-a92bc8bc6d97#.ff98yyjb0" rel="noopener ugc nofollow" target="_blank"> <em class="ln">第四部分</em> </a> <em class="ln"> | </em> <a class="ae jy" href="https://krajzeg.itch.io/dank-tomb" rel="noopener ugc nofollow" target="_blank"> <em class="ln">玩游戏</em> </a></p><div class="ka kb kc kd fq ab cb"><figure class="mg ke nd mi mj mk ml paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mg ke nd mi mj mk ml paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mg ke nd mi mj mk ml paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ne nf ng"><p id="f922" class="ja jb ln jc b jd je jf jg jh ji jj jk nh jm jn jo ni jq jr js nj ju jv jw jx hn dt translated"><a class="ae jy" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jy" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jy" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jy" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ja jb ln jc b jd je jf jg jh ji jj jk nh jm jn jo ni jq jr js nj ju jv jw jx hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jy" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jy" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="ka kb kc kd fq ke fe ff paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="fe ff nk"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="ka kb kc kd fq ke"><div class="bz el l di"><div class="nl ki l"/></div></figure></div></div>    
</body>
</html>