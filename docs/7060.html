<html>
<head>
<title>How to Organize CLEAN ARCHITECTURE to Modular Patterns in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在10分钟内将干净的架构组织成模块化模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/applying-clean-architecture-on-web-application-with-modular-pattern-7b11f1b89011?source=collection_archive---------0-----------------------#2017-10-16">https://medium.com/hackernoon/applying-clean-architecture-on-web-application-with-modular-pattern-7b11f1b89011?source=collection_archive---------0-----------------------#2017-10-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e2f9128b67cd46b0260bc745d9b89e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cZ47i4cm7hXiqCoZx4eEg.jpeg"/></div></div></figure></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><p id="dfcf" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">你现在还在关心什么是<strong class="jl hv">现代软件架构</strong>？你正在搜索<strong class="jl hv">最佳软件架构</strong>来申请你的项目。深入这篇文章，它会帮助你自己回答。</p><p id="b576" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">就软件开发而言，在我参与的许多项目中，为了<strong class="jl hv">维护和可重用性</strong>，项目的架构非常重要。软件架构确保您构建的软件有一个框架基础。它只是喜欢主机或者房子的背景。基于此，我们有自由去建造任何我们想要的东西。</p><p id="119f" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这些天我脑子里一直在想的问题是我们如何将干净的架构和模块化模式结合起来？我在代码中做了一些实验，最后，我决定在这篇文章中把它写出来。目的很简单，分享我学到的东西，并从反馈中了解更多。这篇文章是基于我在软件开发方面的经验，以及模块化方法如何带来好处并在上面应用<strong class="jl hv">干净架构概念</strong>。</p></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="1fe5" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated"><strong class="ak">模块化模式</strong></h1><p id="3c4d" class="pw-post-body-paragraph jj jk hu jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hn dt translated">架构的模块化方法也是我们公司经常谈论的话题。回到5年前，我参与了一个有很多人参与的大项目，在那个时候，我们已经按照模块化的方法组织了架构。到那时，我们知道通过模块化，我们可以<strong class="jl hv">将大块软件切割成许多垂直的小块软件</strong>和<strong class="jl hv">使团队工作更容易</strong>，因为<strong class="jl hv">每个团队只需要专注于他们工作的模块</strong>。有人记得大项目中的冲突代码吗？你能花半天(或更长时间)来合并代码吗？这真是一场噩梦，不是吗。</p><p id="cd77" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">因此，在模块化方法中，我们需要确保模块足够独立，以便它可以由不同团队中的唯一开发人员来工作。它应该在逻辑设计风格，给我们的优点</p><ul class=""><li id="19f1" class="lk ll hu jl b jm jn jq jr ju lm jy ln kc lo kg lp lq lr ls dt translated">帮助我们的软件系统能够<strong class="jl hv">扩展、重用、维护和适应</strong>。</li><li id="046e" class="lk ll hu jl b jm lt jq lu ju lv jy lw kc lx kg lp lq lr ls dt translated">将大型整体堆栈分解成协作模块的灵活组合(整体风格)。</li><li id="ca27" class="lk ll hu jl b jm lt jq lu ju lv jy lw kc lx kg lp lq lr ls dt translated">帮助<strong class="jl hv">的新人容易理解</strong>系统的业务特性和功能(因为它足够小)</li><li id="76da" class="lk ll hu jl b jm lt jq lu ju lv jy lw kc lx kg lp lq lr ls dt translated">打开<strong class="jl hv">迁移到微服务架构</strong>的大门(如果需要，但从我的角度来看不容易采用)</li></ul></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="6803" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated"><strong class="ak">干净的建筑</strong></h1><p id="a349" class="pw-post-body-paragraph jj jk hu jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hn dt translated"><a class="ae ly" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">自2012年以来，鲍勃大叔创造了清洁架构</a>，到那时，<strong class="jl hv">成为软件架构世界的重要事物</strong>。我们可以看到<a class="ae ly" href="https://github.com/android10/Android-CleanArchitecture" rel="noopener ugc nofollow" target="_blank"> Android </a>结合<a class="ae ly" href="https://msdn.microsoft.com/en-us/library/ff649571.aspx" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv"> MVP模式</strong> </a>使用它来构建移动应用的软件架构。那里有几篇文章也建议对web应用程序使用干净的架构。今年年初，Bob大叔出版了名为<strong class="jl hv"/><a class="ae ly" href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">清洁架构:软件结构与设计工匠指南</strong></a><strong class="jl hv"/>的书。如果你以前从未读过那本书，我强烈建议你看一看。这本书提到了很多使用<a class="ae ly" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"/></a><strong class="jl hv">设计模式</strong>时的最佳实践，以及部署工作中的一些<strong class="jl hv">技巧和诀窍。</strong></p><p id="001b" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">关于clean架构的一点概述，如果你已经知道，请跳过这一步，跳到实现部分。根据Clean Architecture，我们需要<strong class="jl hv">确保下面的一些要点</strong></p><blockquote class="lz ma mb"><p id="9fe4" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated">1.<strong class="jl hv">独立于框架</strong>。该体系结构不依赖于某个加载功能的软件库的存在。这允许您将这样的框架用作工具，而不是将您的系统塞进它们有限的约束中。</p><p id="f0fe" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated">2.<strong class="jl hv">可测试</strong>。可以在没有UI、数据库、Web服务器或任何其他外部元素的情况下测试业务规则。</p><p id="11d4" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated">3.<strong class="jl hv">独立于UI </strong>。用户界面可以很容易地改变，而不需要改变系统的其他部分。例如，Web用户界面可以用控制台用户界面代替，而不需要改变业务规则。</p><p id="2abd" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated">4.<strong class="jl hv">独立于数据库</strong>。您可以将Oracle或SQL Server换成Mongo、BigTable、CouchDB或其他。您的业务规则没有绑定到数据库。</p><p id="a32c" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated">5.<strong class="jl hv">独立于任何外部机构</strong>。事实上，你的业务规则根本不了解外部世界。</p></blockquote><p id="a241" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">它严格遵循图表</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/76080b31c8b1ffed64f29a6d4e392e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7LkQDyDqLN3rRSrNYkETA.jpeg"/></div></div></figure></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="53f8" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated"><strong class="ak">实施</strong></h1><blockquote class="lz ma mb"><p id="4686" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated"><em class="hu">“空谈是廉价的。给我看看代码。”——莱纳斯·托瓦尔兹</em></p></blockquote><p id="d5d8" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">让我们从今天的主要故事开始，任何项目都必须分析并询问客户关于<strong class="jl hv">他们想为他们的系统</strong>做什么以及<strong class="jl hv">他们需要他们的系统为</strong>做什么。他们会给我们一堆<strong class="jl hv">用例</strong>或者<strong class="jl hv">用户故事</strong>(如果有敏捷项目的话)。最后一步，我们必须画出用例图。对于那些到目前为止还不明白我说的话的人，我想分析一下博客引擎领域的一个例子。比方说，我们想建立一个博客网站，有一些功能，如阅读博客，看到这个博客的帖子，在公共界面上添加一些评论。而且我们肯定有办法在博客、帖子和评论上进行CRUD操作。除此之外，我们还需要登录系统，然后才能修改博客、帖子和评论。基于这个应用程序的特性需求，我们将以下面的用例图结束</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/09de705a97def4bde19dd6df87e5de99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjxItXhe93qx6rooYGGJvQ.png"/></div></div></figure><p id="6a28" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">现在是时候了，我将向您展示如何将模块化模式应用到这个示例中。如果你看上面的图表，你会注意到我们只有3个主要的东西需要管理，分别是认证、博客和文章。从领域驱动设计中获取一些想法(<a class="ae ly" href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" rel="noopener ugc nofollow" target="_blank">解决软件核心的复杂性</a>和<a class="ae ly" href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" rel="noopener ugc nofollow" target="_blank">实现领域驱动设计</a>书籍从我的角度来看是一个很好的起点)，在这种情况下是<strong class="jl hv">有界上下文模式</strong>，我将我的应用程序域分离为访问控制上下文、博客上下文和帖子上下文(我将其分为3个有界上下文，因为我的领域知识是这样的，由于不同的领域专家，它会与其他不同，但至少它需要整理业务需求)。让我们把它们放在一起，我们有一个图表</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/833e138cc2cd7869fac190019770cace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thlo6OUZ9U8cL41Jjt1jgw.png"/></div></div></figure><p id="013c" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">让我们解释一下上图，红色的访问控制上下文用于身份验证和授权任务。用绿色填充的博客上下文是用于博客管理的，包括设置博客、状态分配和主题…第三个是帖子上下文，它管理自己的评论和标签。如你所见，文章的内容与他人有关系。更多关于如何设计<strong class="jl hv">有界上下文</strong> ( <strong class="jl hv">根集合</strong>)的信息，请来到<a class="ae ly" href="https://vaughnvernon.co/?p=838" rel="noopener ugc nofollow" target="_blank">有效集合设计</a>文章，你将学到大量有用的东西。我向你保证:)</p><p id="8afd" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">理论讲得太多了，现在让我们直接进入代码。由于本文的限制，我只能向您展示一个有界上下文代码，我想选择Post上下文，因为我认为这是最感兴趣的。这个虎视眈眈，你可以看看我的GitHub代码— <strong class="jl hv"> <em class="mc">本文末尾的链接给你</em> </strong>。到目前为止，你们中的一些人会问，到底什么是干净的建筑？不要惊慌。让我给你看看项目结构，然后你有其余的。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/43c695861ba14ff906d08c7a33585f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*uVozyVYyjAopSg2FO5pQDw.png"/></div></figure><p id="58b0" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">它对于构建项目是否干净？到那时，我发现<strong class="jl hv">简单的结构</strong>不仅<strong class="jl hv">帮助新来者容易赶上并使用</strong>它，而且<strong class="jl hv">帮助代码读者容易理解我们想要做什么，并在</strong>庞大的代码库中导航。<br/> <br/>对于那些想要运行这个示例项目的人，我使用<strong class="jl hv">。NET Core 2.0 </strong>来实现，这样你至少需要安装<a class="ae ly" href="https://www.microsoft.com/net/download/core#/runtime" rel="noopener ugc nofollow" target="_blank">运行时环境</a>。</p><p id="4338" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">现在我开始解释上面的结构。首先，我们有图中的<strong class="jl hv">框架文件夹</strong>，它包含了所有与项目必需的工具包相关的东西。<strong class="jl hv">记住，我们将避免在代码中使用抽象，而是使用组合</strong>(OOP中的<a class="ae ly" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">组合超过继承</a>)。博客核心。Core不需要依赖任何框架或库，而是依赖于。NET SDK(有些情况我们称之为普通代码)。此外，我们有3个项目:BlogCore。基础设施，博客核心。基础设施。AspNetCore和BlogCore。EfCore将依赖于EntityFrameworkCore、AspNetCore和其他库，如Autofac、AutoMapper、FluentValidation、mediator……</p><p id="1104" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">第二，<strong class="jl hv"> Hosts文件夹</strong>在图的中间，我们用它来放置主机项目。您可以看到我有2台主机:一台用于API (BlogCore。API)和另一个用于单页面应用程序(BlogCore。App)。</p><p id="1adc" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">第三，<strong class="jl hv">迁移文件夹</strong>用于执行迁移工作，在本例中，我们迁移访问控制上下文、博客上下文和帖子上下文的数据。我们可以选择使用实体框架迁移来进行迁移，并为它们提供种子数据。否则，您也可以使用T-SQL脚本来进行迁移。你看着办吧，我不说哪个比别人好。</p><p id="cdfa" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">最后，我们有<strong class="jl hv">模块文件夹</strong>，它包含了这个应用程序的核心。我们在这里把它分成了有界的上下文文件夹，使我们的架构更加清晰。每个有界上下文有2个子项目，例如BlogCore。PostContext和blog core . post context . core . blog core。Core只包含域对象、契约和接口，这对于其他项目的引用来说是非常好的。规则是，如果我们有另一个模块想要使用一些类和对象，那么它应该引用&lt;模块名&gt;。核心和到这个项目内部的接口(<strong class="jl hv">只依赖于另一个模块中的接口</strong>)。这将使这些模块松散耦合。我们会从这种方法中获得很多好处)。</p><p id="561c" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">让我们在细节中查看后绑定上下文结构</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/319af62f85991bb7f21ba922bbad588f.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*QzvNXknzGsGHd7pu14HQng.png"/></div></figure><p id="6904" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我认为我们应该深入研究一些代码，以便更好地理解我们如何用这个项目的模块化模式实现干净的架构。</p><p id="f3a4" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们有<strong class="jl hv"> Post.cs实体</strong>，它在Post上下文中充当根聚合</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="1043" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">然后，我们有了<strong class="jl hv">post generic repository . cs</strong></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="ef7b" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们需要为<strong class="jl hv"> PostContext.cs </strong>创建DbContext</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="0a5f" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">在干净的架构中，用例非常重要，应该非常仔细地设计。在我的项目中，我将其命名为<strong class="jl hv">list outpost bybloginteractor . cs</strong></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="939f" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">在处理了Post有界上下文的业务案例之后，我们需要聚集一些与访问控制有界上下文相关的数据，在这种情况下，我们获得它的作者信息，并使用IUserRepository接口获得作者的详细信息。因此我们引入了另一个名为<strong class="jl hv">listboutpostblogpresenter . cs</strong>的类</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="7c7d" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们需要一个地方来注册这些依赖对象。所以<strong class="jl hv">依赖注入</strong>开始发挥作用，我们在这个项目中使用Autofac模块。这个想法是模块将注册它自己的所有依赖项。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="a311" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">是的，这就够了，然后我们只需要为我们所做的事情引入<strong class="jl hv">API</strong></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><p id="1378" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jl hv">重述</strong></p><p id="cdc4" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">今天，我将带你走完我们如何在干净的架构中做好模块化工作的旅程。我们至少知道什么是模块化，什么是真正重要的。我们浏览了一些关于清洁建筑的概述，以及它的一些优点。最后但同样重要的是，我们知道如何使用？网芯2.0。</p><p id="f5a6" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">这篇文章中没有涉及到的是<strong class="jl hv">数据流</strong>、<strong class="jl hv">有界上下文之间的同步</strong>、<strong class="jl hv">单元测试</strong>、<strong class="jl hv">部署</strong>对于Clean Architecture…如果你们感兴趣，我会写更多关于它们的内容，只需在下面的评论框中留言即可。</p><blockquote class="lz ma mb"><p id="5e2a" class="jj jk mc jl b jm jn jo jp jq jr js jt md jv jw jx me jz ka kb mf kd ke kf kg hn dt translated">这篇文章的源代码可以在https://github.com/thangchung/blog-core<a class="ae ly" href="https://github.com/thangchung/blog-core" rel="noopener ugc nofollow" target="_blank">找到</a></p></blockquote><p id="09bb" class="pw-post-body-paragraph jj jk hu jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">感谢阅读！如果你喜欢这篇文章，请点击👏符号，以便其他人可以看到它。</p></div></div>    
</body>
</html>