<html>
<head>
<title>Self Positioning React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定位反应元件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/self-positioning-react-components-7e5d99e9349f?source=collection_archive---------4-----------------------#2017-08-23">https://medium.com/hackernoon/self-positioning-react-components-7e5d99e9349f?source=collection_archive---------4-----------------------#2017-08-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/54eddf1ce634f667ba77a4fbffd0615a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDIj2SKAE-Bp32owLoHDjw.png"/></div></div></figure><div class=""/><p id="7a9c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常感谢<a class="ka kb gr" href="https://medium.com/u/10e7d71b6655?source=post_page-----7e5d99e9349f--------------------------------" rel="noopener" target="_blank">德克斯特</a>工程部，特别是<a class="ka kb gr" href="https://medium.com/u/5509cf8da295?source=post_page-----7e5d99e9349f--------------------------------" rel="noopener" target="_blank">丹尼尔·伊尔科维奇</a>和<a class="ka kb gr" href="https://medium.com/u/41dac176c234?source=post_page-----7e5d99e9349f--------------------------------" rel="noopener" target="_blank">胡大维</a>让我分享这段代码，以及他们在我们<a class="ae kc" href="http://rundexter.com" rel="noopener ugc nofollow" target="_blank">网站</a>上构建用户教程功能时提供的所有帮助和支持。</p><p id="3c6f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管React有办法打开舱门并直接操纵DOM，但这样做的理由很少。除非我们有非常好的理由，否则我们不应该直接操作DOM。当我们需要时，我们应该使用<code class="eh kd ke kf kg b">ref</code>属性。只有在万不得已的情况下，我们才应该直接操作DOM以及在渲染过程中改变状态。</p><h1 id="1ac6" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">问题是</h1><p id="0f09" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">栅格在1024像素处从固定栅格捕捉到流体栅格。我们希望我们的教程提示离它们的父元素有20px的距离，但是没有办法只用css做到这一点。如果尖端正确定位在固定网格中，当网格捕捉到流体视图时，尖端将关闭。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="ad86" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">教程元数据直接应用于具有最高css特异性的组件的内联样式中。这意味着媒体查询不能解决这个问题，因为媒体查询会被具有更高特异性的css覆盖。</p><h1 id="bf2f" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">解决方案</h1><p id="2738" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">解决方案需要一组元数据和一个知道它在哪里的组件，这样它就可以动态地改变它的定位。这是最终组件样式变化的视频。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="7fd5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">并且组件随着视口大小的调整而移动。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lo lp l"/></div></figure><h1 id="fcc4" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">Element.getClientRects()</h1><p id="9cf5" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">首先，我们需要知道父元素在页面上的位置，然后才能对它做任何事情。<code class="eh kd ke kf kg b">.getClientRects()</code> <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" rel="noopener ugc nofollow" target="_blank">方法</a>就是这么做的。如果你在DOM上查询一个元素并调用<code class="eh kd ke kf kg b">.getClientRects()</code>，它将返回一个值对象，该值对象包含该元素相对于浏览器视窗的位置、高度和宽度。在你那边试试吧。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lq"><img src="../Images/fe380d2d30e8caef4adf44aa4752b487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkU_yoIB4aWoSRX11jYIiw.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">querying an element on NYTimes.com</figcaption></figure><h1 id="f16b" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">使用有状态组件存储定位</h1><p id="eddd" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">我们需要组件随时知道它在哪里。考虑到这个需求，我们需要一个能够保持自身状态的<code class="eh kd ke kf kg b">class</code>组件，而不是一个无状态的功能组件。这是因为用户可以缩小或扩大他们的视口超过或小于1024像素的阈值，这将改变我们的网格到流体或固定位置。组件需要知道视窗的大小，这样它就可以在屏幕大小改变时保持动态生成的位置。</p><h1 id="abe9" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">Getters和Setters</h1><p id="3c35" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">该组件围绕动态定位有两个核心功能。根据父元素在屏幕上的位置动态设置样式，并让这些设置的样式呈现提示的位置。我们将这些函数方法命名为<code class="eh kd ke kf kg b">getStyles</code>和<code class="eh kd ke kf kg b">setStyles</code>。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lv lp l"/></div></figure><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lv lp l"/></div></figure><p id="e32d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个特定的用例中，我们为每个教程提示加载<code class="eh kd ke kf kg b">tutorialMeta</code> JSON数据，并相应地为每个提示定位类型加载<code class="eh kd ke kf kg b">setState</code>。<strong class="je ig">注意:</strong>这不是自定位组件本身的要求。只是教程的信息。例如说明文本和偏移定位，因此提示距离其父元素20px并居中。</p><p id="1b2c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，是时候利用这一功能并将其与React的生命周期方法挂钩了，这样组件就知道何时更新自己的定位。</p><h1 id="e008" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">连接React的生命周期方法</h1><p id="d771" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">让我们把getters和setters连接起来，这样我们的组件就知道什么时候触发它们，更新它的属性和状态。</p><p id="a3ce" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">初始化和销毁:</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lv lp l"/></div></figure><p id="4769" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">关于组件加载，我们需要<code class="eh kd ke kf kg b">setStyles</code>，因为我们目前没有任何样式可以获取！记住，组件将调用<code class="eh kd ke kf kg b">.getClientRect()</code>，它将动态设置定位值。此外，我们不希望每次调整视口大小时都查询DOM。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lv lp l"/></div></figure><p id="cb6d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们检查我们的道具或状态是否改变了。<code class="eh kd ke kf kg b">shouldComponentUpdate</code>的默认设置是，如果React的<a class="ae kc" href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">文档</a>中的任何状态发生变化，则返回true。因为我们也从容器组件中获取数据作为道具，所以我们也需要检查道具更新。<strong class="je ig">注意:</strong>像<code class="eh kd ke kf kg b">nextStep</code>和<code class="eh kd ke kf kg b">currentStep</code>一样，整个教程都有全球调度和数据。这不是每个用例的要求，只是我们正在解决的一个用例。</p><p id="edfb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一个<code class="eh kd ke kf kg b">componentWillRecieveProps</code>在一个安装的组件接收新的道具(<a class="ae kc" href="https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops" rel="noopener ugc nofollow" target="_blank">文档</a>)之前被触发。使用<code class="eh kd ke kf kg b">replaceState</code>而不是<code class="eh kd ke kf kg b">setState</code>清除状态并将组件设置为不显示。这也是一个非常具体和深思熟虑的用例，闪烁问题。</p><h1 id="55b2" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">有一个闪烁问题</h1><p id="0a68" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">可怕的闪烁！这是如此微妙，但它使我们的团队抽搐。在初始加载时有一个闪光，当转换教程提示时，它会在应该出现的地方前一个渲染步骤出现。</p><p id="3653" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">闪光灯闪烁:</strong>这就是<code class="eh kd ke kf kg b">-9999</code>位置的由来。如果没有给我们的组件定位，只需确保它完全离开页面。</p><p id="82fa" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">挂起闪烁:</strong>每次我们得到新的道具时，组件会将我们的显示设置为false，并在转换过程中将组件从DOM中完全移除。如果你查看<code class="eh kd ke kf kg b">componentWillRecieveProps</code>、<code class="eh kd ke kf kg b">setStyles</code>和<code class="eh kd ke kf kg b">getStyles</code>，你会看到如何移除和添加组件的参考，其中<code class="eh kd ke kf kg b">display</code>设置为假或真。</p><h1 id="a446" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">渲染</h1><p id="ffac" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">这个函数将获取我们动态生成的样式，在样式<code class="eh kd ke kf kg b">props</code>中调用。<strong class="je ig">注意:</strong> <code class="eh kd ke kf kg b">_.getClassNameFromObject</code>是我们自己的自定义函数，它将创建一个我们可以添加到组件类样式的字符串。我们不打算深究这个函数，因为它超出了本文的范围。但是，如果你感兴趣，请在帖子底部留下评论，我会尽力回答你的问题。</p><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lv lp l"/></div></figure><p id="1cd3" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们的组件生命周期、getters、setters和render方法的图表。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lw"><img src="../Images/afd2c55f219fa55842f33b9471fb923e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMWbkf4UI35QyiTOTl1WWA.png"/></div></div></figure><h1 id="b1fc" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">整个组件</h1><figure class="lk ll lm ln fq hw"><div class="bz el l di"><div class="lv lp l"/></div></figure><h1 id="9d12" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">等等，还有更多！</h1><p id="d238" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">我们还提出了一个有趣的解决方案，以避免在整个应用程序中添加组件。如果您需要像教程一样向应用程序添加一系列组件，这将非常有用。</p><p id="1666" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh kd ke kf kg b">setStyles</code>中，我们查询特定步骤的DOM，而不是多次包含组件。容器组件呈现组件一次，然后在每次步骤改变时，我们寻找不同的步骤类来呈现教程组件。</p><h1 id="14e9" class="kh ki if bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">这是所有的乡亲</h1><p id="bb3c" class="pw-post-body-paragraph jc jd if je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">希望这能帮助那些在React应用程序中需要这种动态定位功能的人。</p></div></div>    
</body>
</html>