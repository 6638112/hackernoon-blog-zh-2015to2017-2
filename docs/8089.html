<html>
<head>
<title>You don’t need to know “Dependency Injection”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不需要知道“依赖注入”</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-dont-need-to-know-dependency-injection-2e9d2ba1978a?source=collection_archive---------0-----------------------#2017-11-19">https://medium.com/hackernoon/you-dont-need-to-know-dependency-injection-2e9d2ba1978a?source=collection_archive---------0-----------------------#2017-11-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/bd8f691bfd3626087313b5a6cb340304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vz2KrbKrVjSnVGW1ZsVCtA.png"/></div></div></figure><div class=""/><p id="0447" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近参加了一个前端职位的面试，一位同事问应聘者——“你对依赖注入了解多少？”。</p><p id="0567" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我有一种感觉，这可能是一个“抓到你了”的问题，但当时我不太清楚为什么。从那以后，我们花了一些时间来讨论和解释为什么这不是一个问前端开发人员的好问题。我也将为那些在面试中遇到这个问题的人提供一些建议。</p><p id="ad0b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，什么是依赖注入呢？</p><p id="e747" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Martin Fowler最初在他2004年的文章“<a class="ae ka" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">Inversion of Control Containers and Dependency Injection pattern</a>”中创造了这个短语，用来解释Java社区中围绕控制反转(IoC)概念开发的模式，以及它如何适用于其他面向对象的环境。归结起来就是——尽可能地允许任何与模块功能无关的东西成为可插拔的，而不是将特定的实现内部化(从而紧密耦合)。</p><p id="ac64" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个概念是通过Angular引入前端的，在库开源的时候，Angular的创建者miko he very正在Google(很大程度上是一个Java商店)工作。</p><p id="3f65" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那时的前端场景看起来就像挥舞着jQuery和MooTools的野蛮人。Angular像Alexander一样横扫亚洲部落，带来了围绕“控制反转”和“依赖注入”的讨论浪潮。</p><p id="3b1c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在前端开发的现代，所有的框架都集中在“组件化”上，作为分离和连接复杂部分的单一解决方案，“依赖注入”现在是标准的操作过程。</p><p id="bec1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每一个通过props传入的函数都是“一个依赖项的注入”，每一个声明一个处理事件或用户交互的prop的组件都在观察“控制反转”。这些借用的术语现在已经因为无处不在而变得过时了，也许是为了给经历过Angular时代的JavaScripters人员用作术语。</p><p id="cad5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也就是说，如果你发现自己在一个面试房间里，面试官问你说一些依赖注入的事情，这里有一些关于它如何与现代前端框架相关的事情，至少会引起注意</p><blockquote class="kb"><p id="6cba" class="kc kd if bd ke kf kg kh ki kj kk jz ek translated">“依赖注入有三种主要类型[……]如果你在当前关于控制反转的讨论中读到这种东西，你会听到它们被称为类型1 IoC(接口注入)、类型2 IoC(设置器注入)和类型3 IoC(构造器注入)。我发现数字名称很难记住，这就是我在这里使用这些名称的原因。”— <a class="ae ka" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a></p></blockquote><p id="8e8d" class="pw-post-body-paragraph jc jd if je b jf kl jh ji jj km jl jm jn kn jp jq jr ko jt ju jv kp jx jy jz hn dt translated">数字名称确实很难记住，但在被问到依赖注入的面试中，适度地使用一些行话可能不是一个坏主意😉</p><p id="65b0" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看React中这三种类型的类似物是什么样子的。</p><h2 id="8a97" class="kq kr if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">类型3 IoC —构造函数注入</h2><p id="8e8b" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">顾名思义，这个组件将通过构造函数接收它的依赖项。下面是这样一个组件的样子:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="b478" class="kq kr if lv b fv lz ma l mb mc">class Knight extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      weapon: props.weapon<br/>    };<br/>  }<br/>  render() {<br/>    return `🐴 ${this.state.weapon}`;<br/>  }<br/>}</span></pre><p id="be08" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你会这样使用它:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="f0b4" class="kq kr if lv b fv lz ma l mb mc">&lt;Knight weapon={sword} /&gt;</span></pre><p id="752b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，你通常应该直接使用道具，而不是复制它。</p><h2 id="c98a" class="kq kr if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">2型IoC-Setter注射</h2><p id="d2e9" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">组件不需要在构造函数中设置依赖关系，而是在初始化后提供可以调用的方法，依赖关系作为参数传入。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="1f4e" class="kq kr if lv b fv lz ma l mb mc">class Knight extends React.Component {<br/>  state = {};<br/>  setWeapon = (weapon) =&gt; this.setState({ weapon });<br/>  render() {<br/>    return `🐴 ${this.state.weapon}`;<br/>  }<br/>}</span></pre><p id="ba64" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用法:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="e474" class="kq kr if lv b fv lz ma l mb mc">componentDidMount () {<br/>  this.knight.setWeapon(sword);<br/>}<br/>render () {<br/>  return &lt;Knight ref={c =&gt; this.knight = c} /&gt;;<br/>}</span></pre><p id="29e2" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，您几乎肯定不希望这样做，而是直接通过props传递依赖关系。</p><h2 id="0a2c" class="kq kr if bd ks kt ku kv kw kx ky kz la jn lb lc ld jr le lf lg jv lh li lj lk dt translated">1型IoC——界面注射</h2><p id="3bcf" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">组件的道具是它与客户端的接口，因此“必需的道具”与React的接口注入最为相似:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="4b4d" class="kq kr if lv b fv lz ma l mb mc">class Knight extends React.Component {<br/>  static propTypes = {<br/>    weapon: PropTypes.any.isRequired<br/>  };<br/>  render() {<br/>    return `🐴 ${this.props.weapon}`;<br/>  }<br/>}</span></pre><p id="c0e8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以简单地把它当作</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="79f4" class="kq kr if lv b fv lz ma l mb mc">&lt;Knight weapon={sword} /&gt;</span></pre><p id="cabd" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这些例子能够说明依赖注入已经变得多么普遍，并在这个话题出现时为您提供一些话题。</p><p id="0429" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Component + Props模式在构造中注入依赖关系，在初始化之后继续更新(设置)依赖关系，并且可以强制依赖关系通过Props接口传递。这是三种模式的结合，至少在React中是这样。<em class="md">(构造函数注入在现代Angular中确实仍然流行/不可避免)</em></p><p id="8caf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">也许围绕渲染道具/功能的讨论像小孩子一样(例如，迈克尔杰克逊的《<a class="ae ka" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">使用渲染道具！</a>、Donavon West的“<a class="ae ka" href="http://americanexpress.io/faccs-are-an-antipattern/" rel="noopener ugc nofollow" target="_blank">函数作为子组件是一种反模式</a>”，而我自己的“<a class="ae ka" href="https://hackernoon.com/solving-the-problems-of-higher-order-components-without-throwing-the-baby-out-with-the-bathwater-40ddc72df5aa" rel="noopener ugc nofollow" target="_blank">解决高阶组件的问题……</a>”)可以被视为这种对话的延伸，其中甚至组件的渲染函数也是一种可以被注入的依赖。像<a class="ae ka" href="https://www.npmjs.com/package/downshift" rel="noopener ugc nofollow" target="_blank">降档</a>这样的库集中体现了这种哲学的逻辑结论。但是我怀疑那些文章和库的作者是否需要关心那个特定的术语。</p><h1 id="a9ef" class="me kr if bd ks mf mg mh kw mi mj mk la ml mm mn ld mo mp mq lg mr ms mt lj mu dt translated">感谢阅读！</h1><p id="eacf" class="pw-post-body-paragraph jc jd if je b jf ll jh ji jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz hn dt translated">非常感谢来自<a class="ae ka" href="https://twitter.com/jephuff" rel="noopener ugc nofollow" target="_blank">杰弗里·伯特</a>和<a class="mv mw gr" href="https://medium.com/u/81bc57426c80?source=post_page-----2e9d2ba1978a--------------------------------" rel="noopener" target="_blank">亚历克斯·威尔默</a>的反馈和编辑笔记</p><p id="0341" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在推特上找到我<a class="ae ka" href="https://twitter.com/cheapsteak" rel="noopener ugc nofollow" target="_blank"> @CheapSteak </a>。</p><p id="dd44" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">📬订阅我的时事通讯以便在文章发表前收到草稿。</p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="09c8" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本文由我的爱好项目资助-<a class="ae ka" href="https://npmcharts.com/" rel="noopener ugc nofollow" target="_blank"><strong class="je ig"/></a><strong class="je ig">📈</strong></p><p id="e510" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是<a class="ae ka" href="https://npmcharts.com/compare/react-apollo,react-relay" rel="noopener ugc nofollow" target="_blank"> react-apollo和react-relay </a>的交互下载直方图</p><figure class="lq lr ls lt fq hw"><div class="bz el l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>