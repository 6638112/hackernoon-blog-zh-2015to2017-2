<html>
<head>
<title>Real-Time React Chart with Rx.Net in Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React在几分钟内的实时反应图表</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/real-time-react-chart-with-rx-net-in-minutes-d76bdcf301e4?source=collection_archive---------8-----------------------#2017-04-10">https://medium.com/hackernoon/real-time-react-chart-with-rx-net-in-minutes-d76bdcf301e4?source=collection_archive---------8-----------------------#2017-04-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="3d87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">如何从跨平台添加异步实时数据流。NET后端到您的React web应用程序。</em></p><p id="6d87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你曾经不得不处理异步数据流，你可能使用过或者至少听说过<a class="ae jq" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">react vex</a>，这是一个用于反应式<a class="ae jq" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程的库</a>，它提供了强大的API来将数据流转换成可以订阅和操作的可观察序列。但是，它与常规事件驱动方法的不同之处在于，它能够从多个其他可观察序列中组合出新的数据流，您可以非常灵活地组合、过滤或转换这些序列。</p><p id="38b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将展示如何利用这个库和我自己的库<a class="ae jq" href="http://dotnetify.net/react/" rel="noopener ugc nofollow" target="_blank"> dotNetify-React </a>来实现一个相当简单的异步实时web应用程序。下面是我们将要构建的输出:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff jr"><img src="../Images/a8d89219f2e4a7757ff241570f7062ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/1*9HUTF_oVxLA50EXPR50ZKQ.gif"/></div></figure><p id="9745" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它是网络浏览器上的实时图表，由异步数据流提供，而异步数据流本身由两个不同的数据流组成；一个用于正弦波信号，另一个用于其振幅。</p><p id="38ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下步骤使用脸书的<a class="ae jq" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank"><em class="jp">create-react-app</em></a>样板文件生成web app，以及<a class="ae jq" href="https://www.microsoft.com/net/core#windowscmd" rel="noopener ugc nofollow" target="_blank">。NET Core SDK </a>运行后端。您需要首先安装它们。</p><p id="1f36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果只是想拉源代码，就去Github<a class="ae jq" href="https://github.com/dsuryd/dotnetify-react-demo" rel="noopener ugc nofollow" target="_blank">dotnetify-react-demo</a>。还有一个运行在Visual Studio 2017上的版本在<a class="ae jq" href="https://github.com/dsuryd/dotnetify-react-demo-vs2017" rel="noopener ugc nofollow" target="_blank">dotnetify-react-demo-vs 2017</a>。</p><h2 id="db71" class="jz ka hu bd kb kc kd ke kf kg kh ki kj jc kk kl km jg kn ko kp jk kq kr ks kt dt translated">前端</h2><p id="4bb7" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">我们将从创建应用程序外壳和安装所需的库开始:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="8490" class="jz ka hu la b fv le lf l lg lh">create-react-app livechart<br/>cd livechart<br/>npm install dotnetify --save<br/>npm install chart.js@1.1.1 --save<br/>npm install react-chartjs@0.8.0 --save<br/>npm install concurrently --save-dev</span></pre><p id="328c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(我一直使用旧版本的图表库，因为API已经发生了变化，我还不熟悉它们。)</p><p id="277d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加将呈现图表的组件<code class="eh li lj lk la b">/src/LiveChart.jsx</code>:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="1761" class="jz ka hu la b fv le lf l lg lh">import React from 'react';<br/>import dotnetify from 'dotnetify';<br/>import { Bar } from 'react-chartjs';</span><span id="d7e9" class="jz ka hu la b fv ll lf l lg lh">export default class LiveChart extends React.Component {<br/>   constructor(props) {<br/>      super(props);<br/>      dotnetify.react.connect("LiveChart", this);<br/>      this.state = {};</span><span id="1a73" class="jz ka hu la b fv ll lf l lg lh">      this.chartData = {<br/>         labels: Array(10).fill(""),<br/>         datasets: [{<br/>            data: Array(10),<br/>            fillColor: 'rgba(75, 192, 192, 0.2)',<br/>            strokeColor: 'rgba(75, 192, 192, 1)'<br/>         }]<br/>      };<br/>      this.chartOptions = { <br/>         responsive: true, <br/>         scaleOverride: true, <br/>         scaleSteps: 5, <br/>         scaleStepWidth: 10 <br/>      };<br/>      this.updateChart = value =&gt; {<br/>            this.chartData.datasets[0].data.shift();<br/>            this.chartData.datasets[0].data.push(value);<br/>      };<br/>   }<br/>   render() {<br/>      return (<br/>         &lt;Bar data={this.chartData} options={this.chartOptions}&gt;<br/>            {this.updateChart(this.state.NextValue)}<br/>         &lt;/Bar&gt;<br/>      );<br/>   }<br/>}</span></pre><p id="bece" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该组件最初将从带有空数据集的<em class="jp"> react-chartjs </em>中呈现一个条形图组件。一旦通过<em class="jp"> dotNetify </em>连接到后端，组件将接收到对<code class="eh li lj lk la b">this.state.NextValue</code>的实时更新，这又会导致图表使用新的数据集值重新呈现。</p><p id="963f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，替换默认的<code class="eh li lj lk la b">/src/App.js</code>来呈现我们的组件:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="36c9" class="jz ka hu la b fv le lf l lg lh">import React, { Component } from 'react';<br/>import LiveChart from './LiveChart';</span><span id="b315" class="jz ka hu la b fv ll lf l lg lh">export default class App extends Component {<br/>  render() {<br/>    return &lt;LiveChart /&gt;<br/>  }<br/>}</span></pre><h2 id="d975" class="jz ka hu bd kb kc kd ke kf kg kh ki kj jc kk kl km jg kn ko kp jk kq kr ks kt dt translated">后端</h2><p id="358b" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">前端就绪后，我们现在添加。网芯后端件。首先创建一个默认的ASP.NET核心web项目并安装所需的包:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="054e" class="jz ka hu la b fv le lf l lg lh">dotnet new web<br/>dotnet add package DotNetify.SignalR --version 2.1.0-pre<br/>dotnet add package System.Reactive<br/>dotnet restore</span></pre><p id="622e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">打开<code class="eh li lj lk la b">package.json</code>并添加下面一行代码，将节点开发服务器未处理的请求重定向到。网络核心服务器:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="27bd" class="jz ka hu la b fv le lf l lg lh">"proxy": "http://localhost:5000/",</span></pre><p id="3449" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仍然在<code class="eh li lj lk la b">package.json</code>中，修改调用<code class="eh li lj lk la b">react-scripts</code>的代码行，以便同时使用<em class="jp">和</em>库来启动Node和。网络核心服务器:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="2285" class="jz ka hu la b fv le lf l lg lh">"start": "concurrently \"react-scripts start\" \"dotnet run\" --kill-others",</span></pre><p id="8cc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，添加将向前端组件提供实时更新的类<code class="eh li lj lk la b">LiveChart.cs</code>:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="2dbb" class="jz ka hu la b fv le lf l lg lh">using System;<br/>using System.Reactive.Linq;</span><span id="41f3" class="jz ka hu la b fv ll lf l lg lh">namespace livechart<br/>{<br/>   public class LiveChart : DotNetify.BaseVM<br/>   {<br/>      private IDisposable _subscription;<br/>      public int NextValue { get; set; }</span><span id="fefb" class="jz ka hu la b fv ll lf l lg lh">      public LiveChart()<br/>      {<br/>         var sine = Observable<br/>            .Interval(TimeSpan.FromMilliseconds(100))<br/>            .Select(t =&gt; Math.Sin(2 * Math.PI * .06 * t));</span><span id="737a" class="jz ka hu la b fv ll lf l lg lh">         var amp = Observable<br/>            .Interval(TimeSpan.FromMilliseconds(100))<br/>            .Select(a =&gt; a % 50 + 1);</span><span id="9c72" class="jz ka hu la b fv ll lf l lg lh">        _subscription = Observable<br/>            .Zip(sine, amp, (s, a) =&gt; (int) Math.Abs( s * a))<br/>            .Subscribe(value =&gt;<br/>            {<br/>               NextValue = value;<br/>               Changed(nameof(NextValue));<br/>               PushUpdates();<br/>            });<br/>      }</span><span id="c2d3" class="jz ka hu la b fv ll lf l lg lh">      public override void Dispose() =&gt; _subscription.Dispose();<br/>   }<br/>}</span></pre><p id="27c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类背后的想法是产生一个数据流，它由另外两个流组成:一个是正弦波信号，另一个是数字的迭代，以产生波动幅度。为了创建流，我们使用<em class="jp"> Rx </em> <a class="ae jq" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a> <code class="eh li lj lk la b">Observable.Interval</code>在一个时间间隔内发出一个整数序列，然后进一步投射到所需的序列中。然后这两个流与<code class="eh li lj lk la b">Observable.Zip</code>合并成一个流，由我们的类实例订阅。</p><p id="6023" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当新数据可用时，我们使用<em class="jp"> dotNetify </em> API <code class="eh li lj lk la b">Changed</code>和<code class="eh li lj lk la b">PushUpdates</code>将数据发送到前端组件，以更新其本地状态。实际通信是通过<em class="jp">信号员</em>完成的，该信号员将在可用时使用<em class="jp">网络插座</em>。但是我们不必担心它，因为它已经被抽象掉了。</p><p id="90a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，在<code class="eh li lj lk la b">Startup.cs:</code>中配置<em class="jp"> dotNetify </em>和<em class="jp"> SignalR </em></p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="af0c" class="jz ka hu la b fv le lf l lg lh">using Microsoft.AspNetCore.Builder;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Http;<br/>using Microsoft.Extensions.DependencyInjection;<br/>using DotNetify;</span><span id="541b" class="jz ka hu la b fv ll lf l lg lh">namespace livechart<br/>{<br/>   public class Startup<br/>   {<br/>      public void ConfigureServices(IServiceCollection services)<br/>      {<br/>         services.AddMemoryCache();<br/>         services.AddSignalR();<br/>         services.AddDotNetify();<br/>      }<br/>      public void Configure(IApplicationBuilder app)<br/>      {<br/>         app.UseWebSockets();<br/>         app.UseSignalR();<br/>         app.UseDotNetify();<br/>         app.Run(async (context) =&gt;<br/>         {<br/>            await context.Response.WriteAsync("LiveChart server");<br/>         });<br/>      }<br/>   }<br/>}</span></pre><p id="b359" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，构建并运行应用程序:</p><pre class="js jt ju jv fq kz la lb lc aw ld dt"><span id="1570" class="jz ka hu la b fv le lf l lg lh">dotnet build<br/>npm start</span></pre><h2 id="a5b0" class="jz ka hu bd kb kc kd ke kf kg kh ki kj jc kk kl km jg kn ko kp jk kq kr ks kt dt translated">摘要</h2><p id="adbd" class="pw-post-body-paragraph ir is hu it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hn dt translated">而且，就是这样。您可以在几分钟内快速构建的异步实时web应用程序。虽然这个例子有些做作，但我希望它仍然能够说明这种技术有多么强大。</p><p id="f059" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在现实场景中，web客户端可能会等待多个后端微服务，这些服务的异步输出需要链接在一起才能产生最终结果。使用<em class="jp">react vex</em>和<em class="jp"> dotNetify </em>组合将显著降低代码复杂度，节省您的时间和精力。</p><div class="js jt ju jv fq ab cb"><figure class="lm jw ln lo lp lq lr paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="lm jw ln lo lp lq lr paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="lm jw ln lo lp lq lr paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="ls lt lu"><p id="f922" class="ir is jp it b iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn jo hn dt translated"><a class="ae jq" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jq" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jq" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jq" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jp it b iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jq" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jq" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="fe ff ly"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>