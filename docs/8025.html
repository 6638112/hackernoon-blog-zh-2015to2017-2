<html>
<head>
<title>Let’s make Reusable Web Components: Google Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们制作可重用的网络组件:谷歌地图</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-make-reusable-web-components-google-maps-8be7577d925?source=collection_archive---------15-----------------------#2017-11-16">https://medium.com/hackernoon/lets-make-reusable-web-components-google-maps-8be7577d925?source=collection_archive---------15-----------------------#2017-11-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/9ff4d9d097ea1b59565b1d8913e22953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*z7CxR54DFNvEF1p-a1bv2w.jpeg"/></div></figure><p id="6249" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">推动web开发前进的一个巨大挑战是缺乏对web组件的完全共识。</p><p id="98f6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">事实证明，到处都有框架，每个框架都有自己的开销和想法，一些常见的<a class="ae jw" href="https://hackernoon.com/tagged/ui" rel="noopener ugc nofollow" target="_blank"> UI </a>组件仍然是从头开始开发的。</p><p id="3fc3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是意料之中的，因为框架迫使你进入他们的世界，所以尽管React或Vue组件是可重用的，但你必须忠于那个框架。我们中的一些人在承诺方面有问题。</p><p id="da4f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有心理医生，但他们通常什么也治不好。</p><p id="7867" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有一个<strong class="ja hv"> Web组件</strong>标准，诞生于这样一个事实:将HTML/JS/CSS混杂在一起在概念上是非常不愉快的。</p><p id="5880" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，我们可以按照他们的教程指示，将<a class="ae jw" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank">谷歌</a>地图放在我们的页面上。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="d7c8" class="kg kh hu kc b fv ki kj l kk kl">&lt;div id=”map”&gt;&lt;/div&gt;</span><span id="618b" class="kg kh hu kc b fv km kj l kk kl">&lt;script&gt;<br/> function initMap() {<br/>  // Create a map object and specify the DOM element for display.<br/>  var map = new google.maps.Map(document.getElementById(‘map’), {<br/>    center: {lat: -34.397, lng: 150.644}, zoom: 8<br/>    });<br/> }<br/>&lt;/script&gt;<br/>&lt;script src=”<a class="ae jw" href="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;callback=initMap" rel="noopener ugc nofollow" target="_blank">https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;callback=initMap</a>" async defer&gt;&lt;/script&gt;</span></pre><p id="cfdd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，这正是重点。是我们页面上的<em class="kn">，不是我们app </em>里的<strong class="ja hv"/><em class="kn">。</em></p><p id="5990" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当然，在我们使用<em class="kn"> google.maps </em>对象之前，需要加载脚本，这是一个问题。脚本标签应该在HTML之后。这不太好。</p><p id="85c2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在一个页面上可能需要很多组件的世界里，我们只能用initMap作为入口点。我们可能正在加载其他脚本，等等..变得一团糟。</p><p id="3b4e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，让我们尝试一种不同的方法。我们必须动态加载JS。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="b59b" class="kg kh hu kc b fv ki kj l kk kl">var e = document.createElement(‘script’)<br/>e.src = s; <br/>document.body.appendChild(e)</span></pre><p id="69df" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了简单起见，我们将这个函数称为load。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="16ae" class="kg kh hu kc b fv ki kj l kk kl">const load = async (s) =&gt; {<br/>  return new Promise(async r=&gt;{<br/>   for(i=0;i&lt;document.scripts.length;i++)<br/>     if(document.scripts[i].src == s) return r()<br/>   let e = document.createElement('script')<br/>   e.src = s <br/>   document.body.appendChild(e)<br/>   e.onload = r<br/>  })<br/>}</span></pre><p id="d828" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当脚本加载后，这个承诺就实现了。它还首先检查脚本是否已经加载。</p><p id="09f0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以，现在我们可以制作我们的可重用组件，一个gmap函数:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="8430" class="kg kh hu kc b fv ki kj l kk kl">const gmap = async (e) =&gt; {<br/>  return new Promise(async r=&gt;{<br/>     e.style.height = e.style.width = e.getAttribute('size')<br/>     let latlng = e.getAttribute('latlng').split(',')<br/>     await load('<a class="ae jw" href="http://maps.googleapis.com/maps/api/js?v=3'" rel="noopener ugc nofollow" target="_blank">http://maps.googleapis.com/maps/api/js?v=3'</a>)<br/>     let map = new google.maps.Map(e, {<br/>      center: new self.google.maps.LatLng(latlng[0], latlng[1]),<br/>      zoom: 14,<br/>      mapTypeId: google.maps.MapTypeId.ROADMAP<br/>     });<br/>     r(map)<br/>  })<br/>}</span></pre><p id="6135" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是一个异步函数，它将等待加载脚本完成。这将确保一切都按顺序进行。我们可能希望在一个页面上有多个地图。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="5f22" class="kg kh hu kc b fv ki kj l kk kl">&lt;div control=gmap size=200px latlng=33.808678,-117.918921&gt;&lt;/div&gt;<br/>&lt;div control=gmap size=200px latlng=28.3852377,-81.5660627&gt;&lt;/div&gt;</span></pre><p id="fb8d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">并将div提供给gmap“组件”以创建控件</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="5f92" class="kg kh hu kc b fv ki kj l kk kl">(async () =&gt; {<br/>  let controls = document.querySelectorAll(‘div[control=gmap]’)<br/>  for (var i = 0; i &lt; controls.length; i++)<br/>    await gmap(controls[i])<br/>})()</span></pre><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="4ffb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所有的依赖都是免费的，并且是普通的JS格式。</p><p id="360e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">重要的是，没什么需要记住的。<br/> Div、函数和语言特性。</p><p id="0815" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">不知道哪种模式会胜出，但有可能只是使用语言而没有额外的东西，也很有趣。</p><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="kq kp l"/></div></figure></div></div>    
</body>
</html>