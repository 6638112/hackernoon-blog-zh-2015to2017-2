<html>
<head>
<title>Angular 2+ and Ruby on Rails user authentication Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 2+和Ruby on Rails用户认证第4部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/angular-2-and-ruby-on-rails-user-authentication-part-4-49d550c5869a?source=collection_archive---------4-----------------------#2017-03-02">https://medium.com/hackernoon/angular-2-and-ruby-on-rails-user-authentication-part-4-49d550c5869a?source=collection_archive---------4-----------------------#2017-03-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="cbf0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">本文是<a class="ae jj" rel="noopener" href="/@avatsaev/angular-2-and-ruby-on-rails-user-authentication-fde230ddaed8#.tfr6zstyp"> Angular 2+和Ruby on Rails用户认证第1部分:后端</a>的后续文章</h2></div><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff jk"><img src="../Images/765f93de67da54aa85b3f38dba9e2c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVCbusTvl_CBlfa96EhvYg.png"/></div></div></figure><h1 id="e859" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">用户配置文件、授权服务和授权路由器保护</h1><h1 id="ca06" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">介绍</h1><p id="fece" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">前提是在<strong class="kq hv"> /profile </strong>路线上显示用户资料信息(姓名、昵称、电子邮件等)并对其进行保护，因此当有人试图未经认证就访问它，被重定向到<strong class="kq hv">家</strong>路线时，我们还将编写一个<strong class="kq hv">认证服务</strong>来将所有与认证相关的东西打包在一个地方。</p></div><div class="ab cl lk ll hc lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hn ho hp hq hr"><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff lr"><img src="../Images/795b08585f8b13d51ba035ebae4fdecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMOpRPtOi4yOwLTSxL2i7g.png"/></div></div></figure></div><div class="ab cl lk ll hc lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hn ho hp hq hr"><h1 id="555f" class="jw jx hu bd jy jz ls kb kc kd lt kf kg ja lu jb ki jd lv je kk jg lw jh km kn dt translated">授权服务</h1><p id="98b2" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">首先，我们需要创建一个<strong class="kq hv">身份验证服务</strong>，它将在一个地方包装所有与身份验证相关的状态和动作，特别是<strong class="kq hv">登录/注销动作</strong>和用户<strong class="kq hv">身份验证状态</strong>(用户已登录/注销)，并作为一个流(请注意RxJS正在传入)<strong class="kq hv">异步提供所有这些。</strong></p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="8faa" class="mc jx hu ly b fv md me l mf mg">ng g s services/auth</span></pre><blockquote class="mh mi mj"><p id="4415" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated">s =服务</p></blockquote><p id="710c" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">这是我们的认证服务(<strong class="kq hv">)。/src/app/services/auth . service . ts</strong>):</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="9b9d" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">乍看起来令人生畏，但相信我，这并不复杂，所以让我们来分解一下:</p><p id="c6a8" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated"><strong class="kq hv">第9行:</strong> userSignedIn$是一个<a class="ae jj" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/subjects.md" rel="noopener ugc nofollow" target="_blank"> <strong class="kq hv"> RxJs Subject </strong> </a>(布尔类型)，这意味着它同时是一个<strong class="kq hv">观察者</strong>和一个<strong class="kq hv">可观察对象</strong>，这意味着我们可以在我们的服务中控制它的值，并在服务之外观察它的变化。</p><p id="ac5f" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">我们的构造函数将通过使用TokenService的<strong class="kq hv"> validateToken() </strong>方法初始化登录状态，该方法将根据Rails后端验证当前令牌(如果存在)，该操作是异步的，并在其主体中返回一个如下所示的对象:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/cd0abee987c86294ced098a214769e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*HKYlNO7aQ4lpYDpKzt9x9A.png"/></div></figure><p id="536e" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">所以我们可以使用<strong class="kq hv"> <em class="mk">成功</em> </strong>键来确定用户是否使用有效的令牌登录(第14行)。</p><p id="cd5d" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated"><em class="mk">名字末尾的美元符号($)是一个约定，用来说明这不是一个简单的变量，而是一个随时间变化的可观察的数据流。</em></p><ul class=""><li id="d98e" class="mw mx hu kq b kr ml ku mm kx my lb mz lf na lj nb nc nd ne dt translated">我们的<strong class="kq hv"> logOutUser() </strong>方法不带参数并返回一个响应的<strong class="kq hv">可观察值，我们将在<strong class="kq hv"> Angular2TokenService </strong>上调用<strong class="kq hv"> signOut() </strong>，但在返回其响应之前，我们将通过映射将<strong class="kq hv"> userSignedIn$ </strong>值更改为<strong class="kq hv"> false </strong>(第19行)<strong class="kq hv"> </strong>，以便<strong class="kq hv"> </strong>通知我们的观察者用户已成功注销，然后返回</strong></li><li id="db04" class="mw mx hu kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne dt translated">logInUser 方法获取一个带有电子邮件和密码密钥的对象，并使用它从Angular2TokenService signIn()方法登录。同样，在返回响应之前，我们将修改<strong class="kq hv"> userSignedIn$ </strong>值为<strong class="kq hv"> true，</strong>这将通知观察者用户成功登录<strong class="kq hv">。</strong></li><li id="701b" class="mw mx hu kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne dt translated"><strong class="kq hv"> registerUser </strong>方法类似于loginUser，但是我们在输入对象中有一个额外的密码确认属性。</li></ul><p id="cc38" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">让我们不要忘记将它注入到我们的主AppModule的提供者中(<strong class="kq hv">)。/src/app/app.module.ts </strong>):</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="5d6e" class="mc jx hu ly b fv md me l mf mg">...</span><span id="a681" class="mc jx hu ly b fv nk me l mf mg"><strong class="ly hv">import {AuthService} from "./services/auth.service";</strong></span><span id="f89c" class="mc jx hu ly b fv nk me l mf mg">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    HomeComponent,<br/>    ToolbarComponent,<br/>    AuthDialogComponent,<br/>    LoginFormComponent,<br/>    RegisterFormComponent,<br/>    ProfileComponent<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    FormsModule,<br/>    HttpModule,<br/>    AppRoutingModule,<br/>    MaterializeModule,<br/>  ],<br/>  providers: [ Angular2TokenService, <strong class="ly hv">AuthService</strong>],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</span></pre><h1 id="1215" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">重构登录和工具栏组件以使用AuthService</h1><p id="93c2" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">现在我们需要对我们的<strong class="kq hv">登录</strong>和<strong class="kq hv">工具栏</strong>组件做一些小的改动，以便直接使用AuthService而不是Angular2TokenService。</p><h2 id="b05c" class="mc jx hu bd jy nl nm nn kc no np nq kg kx nr ns ki lb nt nu kk lf nv nw km nx dt translated">重构工具栏</h2><p id="bd0b" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">先说工具栏组件类(<strong class="kq hv">)。/src/app/toolbar/toolbar . component . ts</strong>):</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="e964" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">正如你所看到的，我们去掉了<strong class="kq hv"> Angular2TokenService </strong>并注入了我们的自定义<strong class="kq hv"> AuthService </strong>(第16行)，我们还创建了一个<strong class="kq hv"> logOut() </strong>方法，该方法将在我们的<strong class="kq hv"> AuthService </strong>上调用<strong class="kq hv"> logOutUser </strong>动作，并使用Angular路由器，在注销动作完成时将用户重定向到<strong class="kq hv"> home </strong>(第21行)。</p><p id="a4ae" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">现在让我们改变工具栏的模板(<strong class="kq hv">)。/src/app/toolbar/toolbar . component . html</strong>):</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="7277" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">现在我们使用我们的AuthService的<strong class="kq hv"> userSignedIn$ </strong> Subject来改变用户登录或注销时工具栏的状态，考虑到<strong class="kq hv"> userSignedIn$ </strong>不是一个简单的值，而是一个随时间变化的异步值流，我们需要使用Angular的异步管道来监听它的变化(第11、12、14、15行)。我们还将把<strong class="kq hv">注销按钮</strong>上的click事件链接到我们之前创建的toobar组件的<strong class="kq hv"> logOut() </strong>方法(第15行)。</p><h2 id="a868" class="mc jx hu bd jy nl nm nn kc no np nq kg kx nr ns ki lb nt nu kk lf nv nw km nx dt translated">重构来自的登录</h2><p id="ef3b" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">对登录表单的修改将会非常小，我们只需要修改LoginFormComponent类(<strong class="kq hv">)。/src/app/log in-form/log in-form . component . ts</strong></p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="1ac5" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">我们唯一需要做的就是去掉<strong class="kq hv"> Angular2TokenService </strong>，用我们的<strong class="kq hv"> AuthService </strong>和它的<strong class="kq hv"> logInUser </strong>方法来代替它。</p><blockquote class="mh mi mj"><p id="f916" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated"><strong class="kq hv">不要忘记对RegisterFormComponent应用相同的更改</strong></p></blockquote><p id="cec5" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">就这样，重构结束了。</p><h1 id="72f1" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">用户个人资料页面</h1><h2 id="5dfe" class="mc jx hu bd jy nl nm nn kc no np nq kg kx nr ns ki lb nt nu kk lf nv nw km nx dt translated">分学科实现目标</h2><p id="25c4" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">第一步很明显，让我们生成显示当前用户信息的<strong class="kq hv"> ProfileComponent </strong>:</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="8569" class="mc jx hu ly b fv md me l mf mg">ng g c profile</span></pre><p id="885a" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">组件应该自动导入到AppModule的声明中。</p><h2 id="0d7b" class="mc jx hu bd jy nl nm nn kc no np nq kg kx nr ns ki lb nt nu kk lf nv nw km nx dt translated">轮廓路线</h2><p id="d9f4" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">在我们的路由器模块中(<strong class="kq hv">)。/src/app/app-routing . module . ts</strong>)，我们来声明一下概要路由:</p><p id="3855" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">导入配置文件组件:</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="f074" class="mc jx hu ly b fv md me l mf mg">import {ProfileComponent} from "./profile/profile.component";</span></pre><p id="4a95" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">宣布路线:</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="68f4" class="mc jx hu ly b fv md me l mf mg">...</span><span id="dbc2" class="mc jx hu ly b fv nk me l mf mg">const routes: Routes = [<br/>  {<br/>    path: '',<br/>    component: HomeComponent,<br/>    pathMatch: 'full'<br/>  },<br/>  {<br/>    path: 'home',<br/>    component: HomeComponent<br/>  },<br/>  <strong class="ly hv">{<br/>    path: 'profile',<br/>    component: ProfileComponent<br/>  }</strong><br/>];<br/>...</span></pre><h2 id="7832" class="mc jx hu bd jy nl nm nn kc no np nq kg kx nr ns ki lb nt nu kk lf nv nw km nx dt translated">用户界面</h2><p id="ac20" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">至于个人资料页面的设计，这将非常简单，我们将在一个<a class="ae jj" href="http://materializecss.com/cards.html" rel="noopener ugc nofollow" target="_blank">物化卡</a>中显示用户的电子邮件、姓名和用户名，并使用其页脚添加一个注销按钮。</p><p id="b6e2" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">让我们将Angular2TokenService注入到我们的ProfileComponent中，并添加一个注销方法(<strong class="kq hv">)。/app/profile/profile . component . ts</strong>):</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="5b39" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">我们将使用<strong class="kq hv"> Angular2TokenService </strong>来显示用户的个人信息，使用<strong class="kq hv"> AuthService </strong>来实现注销操作，使用<strong class="kq hv"> Router </strong>在注销完成后进行重定向，因此我们需要将这些注入到我们的<strong class="kq hv"> ProfileComponent </strong>中(第14–16行)</p><p id="739c" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">Nn第18行，我们有一个<strong class="kq hv">注销</strong>动作，当它完成时将用户重定向到home。</p><blockquote class="mh mi mj"><p id="bcd0" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated">为每个组件重新实现<strong class="kq hv">注销</strong>动作似乎是重复的，但这实际上是有用的，因为我们可以为每个组件实现不同的注销后行为，例如重定向到某个其他路由而不是家。</p></blockquote><p id="cfdc" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">配置文件组件的模板，(<strong class="kq hv">)。/src/app/profile/profile . component . html)</strong></p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="9869" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">Angular2TokenService的<strong class="kq hv"> currentUserData </strong>属性提供了用户登录时的信息(电子邮件、姓名、昵称等。)，当用户未登录时，其值为<em class="mk">未定义</em>。</p><p id="f30b" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">第15行，我们使用了<strong class="kq hv"> *ngIf </strong>结构指令来测试是否有数据要显示，如果没有，我们不会显示用户信息卡。</p><p id="ef6c" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">在第31行我们还有一个注销按钮，链接到我们的<strong class="kq hv"> ProfileComponent </strong>类的<strong class="kq hv">注销</strong>方法。</p><p id="5324" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">一定要给<strong class="kq hv">添加一个cleafix类。/src/app/profile/profile . component . sass</strong>因为Materialize不实现它。</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="6c4b" class="mc jx hu ly b fv md me l mf mg">.clearfix<br/>  overflow: auto</span></pre><p id="8ef0" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">这是我们登录后导航到<strong class="kq hv"> /profile </strong>路线时得到的结果:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ny"><img src="../Images/1f16ef23e8174b8a089aef23afa115e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDmxaMm2I8SgV3bIF43c1A.png"/></div></div><figcaption class="nz oa fg fe ff ob oc bd b be z ek">User info card</figcaption></figure><h1 id="e385" class="jw jx hu bd jy jz ka kb kc kd ke kf kg ja kh jb ki jd kj je kk jg kl jh km kn dt translated">授权路由保护</h1><p id="f8c7" class="pw-post-body-paragraph ko kp hu kq b kr ks iv kt ku kv iy kw kx ky kz la lb lc ld le lf lg lh li lj hn dt translated">现在的问题是，即使我们没有登录，我们仍然可以导航到<strong class="kq hv"> /profile </strong>路线:</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff od"><img src="../Images/bb7e2afe02212324833aef04d7bf0e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCWmvl9VD9jX20MjJqAuMg.png"/></div></div></figure><p id="3d32" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">Angular的路线守卫可以帮助我们解决这个问题。</p><p id="2f26" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">Route Guards非常容易理解，这是一个简单的类，它实现了<strong class="kq hv"> CanActivate </strong>接口，这个接口要求我们实现一个<strong class="kq hv"> canActivate() </strong>方法<strong class="kq hv">，</strong>，该方法返回一个布尔值(<em class="mk">或一个布尔类型的可观察值，尽管我无法让它们正常工作</em>)，根据这个布尔值，路由器将允许或禁止路由的激活，逻辑由我们来实现，所以让我们这样做吧。</p><p id="2611" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">在(<strong class="kq hv">中创建一个AuthGuard类。/src/app/guards/auth . guard . ts</strong>):</p><figure class="jl jm jn jo fq jp"><div class="bz el l di"><div class="mt mu l"/></div></figure><p id="256e" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">如你所见，我们的AuthGuard类实现了<strong class="kq hv"> CanActivate </strong>接口及其<strong class="kq hv"> canActivate() </strong>方法，逻辑很简单，Angular2TokenService的userSignedIn()方法返回一个single布尔值，我们将使用它来确定用户是否登录，如果是，我们通过返回true来允许激活，否则，我们将重定向到home并通过返回false来禁止激活。</p><p id="2e94" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">不要忘记在我们的AppModule的提供者中注入它:</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="c758" class="mc jx hu ly b fv md me l mf mg">...</span><span id="38aa" class="mc jx hu ly b fv nk me l mf mg"><strong class="ly hv">import {AuthGuard} from "./guards/auth.guard";</strong><br/><br/>@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    HomeComponent,<br/>    ToolbarComponent,<br/>    AuthDialogComponent,<br/>    LoginFormComponent,<br/>    RegisterFormComponent,<br/>    ProfileComponent<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    FormsModule,<br/>    HttpModule,<br/>    AppRoutingModule,<br/>    MaterializeModule,<br/>  ],<br/>  providers: [ Angular2TokenService, AuthService, <strong class="ly hv">AuthGuard</strong>],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule { }</span></pre><p id="f1cb" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">现在让我们保护我们的<strong class="kq hv">/侧面</strong>路线，打开<strong class="kq hv">。/src/app/app-routing . module . ts</strong>并设置profile route的守卫:</p><pre class="jl jm jn jo fq lx ly lz ma aw mb dt"><span id="86ce" class="mc jx hu ly b fv md me l mf mg">import { NgModule } from '@angular/core';<br/>import { Routes, RouterModule } from '@angular/router';<br/>import {HomeComponent} from "./home/home.component";<br/>import {ProfileComponent} from "./profile/profile.component";<br/>import {AuthGuard} from "./guards/auth.guard";<br/><br/>const routes: Routes = [<br/>  {<br/>    path: '',<br/>    component: HomeComponent,<br/>    pathMatch: 'full'<br/>  },<br/>  {<br/>    path: 'home',<br/>    component: HomeComponent<br/>  },<br/>  {<br/>    path: 'profile',<br/>    component: ProfileComponent,<br/>    <strong class="ly hv">canActivate: [AuthGuard]</strong><br/>  }<br/>];<br/><br/>@NgModule({<br/>  imports: [RouterModule.forRoot(routes)],<br/>  exports: [RouterModule],<br/>  providers: []<br/>})<br/><br/>export class AppRoutingModule { }</span></pre><p id="d38e" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated"><strong class="kq hv"> canActivate </strong>键接受一组守卫，如果你在一条路线上有几个守卫，为了激活这条路线，他们都必须返回<strong class="kq hv"> true </strong>。</p><p id="07fa" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">现在，当我们在没有登录的情况下进入<strong class="kq hv"> /profile </strong>时，我们将被重定向到home，任何以/profile作为路由的路由器链接，在点击时都不会产生任何效果。</p><p id="ab89" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">就这样，一个个人资料页面，被一个路线守卫保护着。</p><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff oe"><img src="../Images/c47c78807b5df6c7af7e5cb87903feea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bn_fyEwreT7EN18bkp7tqw.gif"/></div></div></figure><blockquote class="mh mi mj"><p id="a9c6" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated">你可以在GitHub上获得这部分的最终代码:<a class="ae jj" href="https://github.com/avatsaev/angular-token-auth-seed/tree/profile" rel="noopener ugc nofollow" target="_blank"><strong class="kq hv">https://GitHub . com/avatsaev/angular-token-auth-seed/tree/profile</strong></a></p></blockquote><p id="558f" class="pw-post-body-paragraph ko kp hu kq b kr ml iv kt ku mm iy kw kx mo kz la lb mq ld le lf ms lh li lj hn dt translated">如果您对本教程有任何意见，请告诉我，如果有什么不清楚的地方，我很乐意帮助并纠正:)</p></div><div class="ab cl lk ll hc lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hn ho hp hq hr"><blockquote class="mh mi mj"><p id="a1e6" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated">感谢你阅读这个系列，在Twitter上关注我(<a class="ae jj" href="https://twitter.com/avatsaev" rel="noopener ugc nofollow" target="_blank">https://twitter.com/avatsaev</a>)了解更多关于Angular 2+和Rails的有趣内容。</p></blockquote><div class="jl jm jn jo fq ab cb"><figure class="of jp og oh oi oj ok paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="of jp og oh oi oj ok paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="of jp og oh oi oj ok paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mh mi mj"><p id="f922" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated"><a class="ae jj" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jj" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jj" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jj" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ko kp mk kq b kr ml iv kt ku mm iy kw mn mo kz la mp mq ld le mr ms lh li lj hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jj" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jj" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jl jm jn jo fq jp fe ff paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="fe ff ol"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>