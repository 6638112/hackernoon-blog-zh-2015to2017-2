<html>
<head>
<title>How to use databases with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过Golang使用数据库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-work-with-databases-in-golang-33b002aa8c47?source=collection_archive---------2-----------------------#2017-01-25">https://medium.com/hackernoon/how-to-work-with-databases-in-golang-33b002aa8c47?source=collection_archive---------2-----------------------#2017-01-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="d0d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Golang中有很多不同的方法来使用数据库。我不喜欢这些方法，尤其是ORM的。很多时候，它们会生成低效的查询、错误的锁、检索太多的数据，而你却不知道发生了什么。经过几次实现后，我决定采用这种模式。该模式使用jmoiron的sql抽象库<a class="ae jp" href="https://github.com/jmoiron/sqlx" rel="noopener ugc nofollow" target="_blank"> sqlx </a>，并允许完全定制和控制。</p><p id="634a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">项目结构将如下所示:</p><ul class=""><li id="443f" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv"> db/db.go </strong> = &gt;包含接口定义并嵌入默认的sqlx结构</li><li id="c4a6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv">模型/ </strong> = &gt;包含所有的数据库模型</li><li id="49ac" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv"> utils/ </strong> = &gt;包含通用函数</li></ul><p id="64cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> db.go </strong>文件包含所有的魔法和接口，本质上是默认sqlx函数的包装器。该结构尝试在模型本身中查找自定义实现，如果找不到，则返回错误或默认实现。该结构定义了默认行为，如(有限的)选择、计数、选择、插入、更新和删除。</p><p id="b1e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> db.go </strong></p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="6a86" class="kn ko hu kj b fv kp kq l kr ks">package db</span><span id="5d9e" class="kn ko hu kj b fv kt kq l kr ks">import (<br/> "errors"<br/> "fmt"<br/> "reflect"</span><span id="71d9" class="kn ko hu kj b fv kt kq l kr ks">"github.com/jmoiron/sqlx"<br/> "github.com/op/go-logging"<br/>)</span><span id="9978" class="kn ko hu kj b fv kt kq l kr ks">var log = logging.MustGetLogger("db")</span><span id="6633" class="kn ko hu kj b fv kt kq l kr ks">type Query string</span><span id="fc9e" class="kn ko hu kj b fv kt kq l kr ks">type Queryx struct {<br/> Query  Query<br/> Params []interface{}<br/>}</span><span id="8b7a" class="kn ko hu kj b fv kt kq l kr ks">type DB struct {<br/> *sqlx.DB<br/>}</span><span id="3a6c" class="kn ko hu kj b fv kt kq l kr ks">type Tx struct {<br/> *sqlx.Tx<br/>}</span><span id="1212" class="kn ko hu kj b fv kt kq l kr ks">var (<br/> ErrNoGetterFound   = errors.New("No getter found")<br/> ErrNoDeleterFound  = errors.New("No deleter found")<br/> ErrNoSelecterFound = errors.New("No getter found")<br/> ErrNoUpdaterFound  = errors.New("No updater found")<br/> ErrNoInserterFound = errors.New("No inserter found")<br/>)</span><span id="72c3" class="kn ko hu kj b fv kt kq l kr ks">func Limit(offset, count int) selectOption {<br/> return &amp;limitOption{offset, count}<br/>}</span><span id="d4e7" class="kn ko hu kj b fv kt kq l kr ks">type limitOption struct {<br/> offset int<br/> count  int<br/>}</span><span id="b409" class="kn ko hu kj b fv kt kq l kr ks">func (o *limitOption) Wrap(query string, params []interface{}) (string, []interface{}) {<br/> query = fmt.Sprintf("SELECT a.* FROM (%s) a LIMIT ?, ?", query)<br/> params = append(params, o.offset)<br/> params = append(params, o.count)<br/> return query, params<br/>}</span><span id="224d" class="kn ko hu kj b fv kt kq l kr ks">type selectOption interface {<br/> Wrap(string, []interface{}) (string, []interface{})<br/>}</span><span id="1ddf" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Selectx(o interface{}, qx Queryx, options ...selectOption) error {<br/> q := string(qx.Query)<br/> params := qx.Params</span><span id="2b79" class="kn ko hu kj b fv kt kq l kr ks">log.Debug(q)</span><span id="f8dc" class="kn ko hu kj b fv kt kq l kr ks">for _, option := range options {<br/>  q, params = option.Wrap(q, params)<br/> }</span><span id="1eaf" class="kn ko hu kj b fv kt kq l kr ks">if u, ok := o.(Selecter); ok {<br/>  return u.Select(tx.Tx, Query(q), params...)<br/> }</span><span id="4415" class="kn ko hu kj b fv kt kq l kr ks">stmt, err := tx.Preparex(q)<br/> if err != nil {<br/>  return err<br/> }</span><span id="27c0" class="kn ko hu kj b fv kt kq l kr ks">return stmt.Select(o, params...)<br/>}</span><span id="cb6a" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Countx(qx Queryx) (int, error) {<br/> stmt, err := tx.Preparex(fmt.Sprintf("SELECT COUNT(*) FROM (%s) q", string(qx.Query)))<br/> if err != nil {<br/>  return 0, err<br/> }</span><span id="3c20" class="kn ko hu kj b fv kt kq l kr ks">count := 0<br/> err = stmt.Get(&amp;count, qx.Params...)<br/> return count, err<br/>}</span><span id="619f" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Getx(o interface{}, qx Queryx) error {<br/> if u, ok := o.(Getter); ok {<br/>  return u.Get(tx.Tx, qx.Query, qx.Params...)<br/> }</span><span id="451f" class="kn ko hu kj b fv kt kq l kr ks">stmt, err := tx.Preparex(string(qx.Query))<br/> if err != nil {<br/>  return err<br/> }</span><span id="234a" class="kn ko hu kj b fv kt kq l kr ks">return stmt.Get(o, qx.Params...)<br/>}</span><span id="5774" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Get(o interface{}, query Query, params ...interface{}) error {<br/> if u, ok := o.(Getter); ok {<br/>  return u.Get(tx.Tx, query, params...)<br/> }</span><span id="fcd0" class="kn ko hu kj b fv kt kq l kr ks">stmt, err := tx.Preparex(string(query))<br/> if err != nil {<br/>  return err<br/> }</span><span id="772e" class="kn ko hu kj b fv kt kq l kr ks">return stmt.Get(o, params...)<br/>}</span><span id="cb14" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Update(o interface{}) error {<br/> if u, ok := o.(Updater); ok {<br/>  return u.Update(tx.Tx)<br/> }</span><span id="4622" class="kn ko hu kj b fv kt kq l kr ks">log.Debug("No updater found for object: %s", reflect.TypeOf(o))<br/> return ErrNoUpdaterFound<br/>}</span><span id="8806" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Delete(o interface{}) error {<br/> if u, ok := o.(Deleter); ok {<br/>  return u.Delete(tx.Tx)<br/> }</span><span id="bbb0" class="kn ko hu kj b fv kt kq l kr ks">log.Debug("No deleter found for object: %s", reflect.TypeOf(o))<br/> return ErrNoDeleterFound<br/>}</span><span id="501f" class="kn ko hu kj b fv kt kq l kr ks">func (tx *Tx) Insert(o interface{}) error {<br/> if u, ok := o.(Inserter); ok {<br/>  err := u.Insert(tx.Tx)<br/>  if err != nil {<br/>   log.Error(err.Error())<br/>  }<br/>  return err<br/> }</span><span id="a48d" class="kn ko hu kj b fv kt kq l kr ks">log.Debug("No inserter found for object: %s", reflect.TypeOf(o))<br/> return ErrNoInserterFound<br/>}</span><span id="df32" class="kn ko hu kj b fv kt kq l kr ks">func (db *DB) Begin() *Tx {<br/> tx := db.MustBegin()<br/> return &amp;Tx{tx}<br/>}</span><span id="713d" class="kn ko hu kj b fv kt kq l kr ks">type Updater interface {<br/> Update(*sqlx.Tx) error<br/>}</span><span id="fff8" class="kn ko hu kj b fv kt kq l kr ks">type Inserter interface {<br/> Insert(*sqlx.Tx) error<br/>}</span><span id="4214" class="kn ko hu kj b fv kt kq l kr ks">type Selecter interface {<br/> Select(*sqlx.Tx, Query, ...interface{}) error<br/>}</span><span id="fdae" class="kn ko hu kj b fv kt kq l kr ks">type Getter interface {<br/> Get(*sqlx.Tx, Query, ...interface{}) error<br/>}</span><span id="795b" class="kn ko hu kj b fv kt kq l kr ks">type Deleter interface {<br/> Delete(*sqlx.Tx) error<br/>}</span></pre><p id="9931" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是person模型的一个示例实现。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="010b" class="kn ko hu kj b fv kp kq l kr ks">package model</span><span id="ca99" class="kn ko hu kj b fv kt kq l kr ks">import (<br/>        "fmt"<br/>        "time"</span><span id="4d8b" class="kn ko hu kj b fv kt kq l kr ks">"github.com/jmoiron/sqlx"</span><span id="de12" class="kn ko hu kj b fv kt kq l kr ks">db "./db"<br/>)</span><span id="3847" class="kn ko hu kj b fv kt kq l kr ks">type Gender string</span><span id="5502" class="kn ko hu kj b fv kt kq l kr ks">var (<br/>        GenderMale    Gender = "male"<br/>        GenderFemale  Gender = "female"<br/>)</span><span id="a203" class="kn ko hu kj b fv kt kq l kr ks">func (u *Gender) Scan(value interface{}) error {<br/>        if value == nil {<br/>                return nil<br/>        }</span><span id="33fa" class="kn ko hu kj b fv kt kq l kr ks">b := value.([]byte)<br/>        *u = Gender(b)<br/>        return nil<br/>}</span><span id="a6f6" class="kn ko hu kj b fv kt kq l kr ks">func (u Gender) Value() (driver.Value, error) {<br/>        return string(u), nil<br/>}</span><span id="4fb7" class="kn ko hu kj b fv kt kq l kr ks">type Person struct {<br/>        PersonID      utils.UUID `db:"person_id"`</span><span id="d33b" class="kn ko hu kj b fv kt kq l kr ks">FirstName     string     `db:"first_name"`<br/>        LastName      string     `db:"last_name"`</span><span id="e3af" class="kn ko hu kj b fv kt kq l kr ks">Active        Bool       `db:"active"`<br/>        Gender        Gender     `db:"gender"`</span><span id="3f02" class="kn ko hu kj b fv kt kq l kr ks">ModifiedDate  time.Time  `db:"modified_date"`<br/>}</span><span id="4c94" class="kn ko hu kj b fv kt kq l kr ks">var (<br/>        queryPersons        db.Query = "SELECT person_id, first_name, last_name, gender, active, modified_date FROM persons"<br/>        queryPersonByID     db.Query = "SELECT person_id, first_name, last_name, gender, active, modified_date FROM persons WHERE person_id=:person_id"<br/>        queryPersonInsert   db.Query = "INSERT INTO persons (person_id, first_name, last_name, gender, active, modified_date) VALUES (:person_id, :first_name, :last_name, :gender, :active, :modified_date)"<br/>        queryPersonUpdate   db.Query = "UPDATE persons SET first_name=:first_name, last_name=:last_name, gender=:gender, modified_date=:modified_date, active=:active WHERE person_id=:person_id"<br/>)</span><span id="aec6" class="kn ko hu kj b fv kt kq l kr ks">func QueryPersons(offset, count int) db.Queryx {<br/>        return db.Queryx{<br/>                Query: queryPersons,<br/>                Params: []interface{}{<br/>                },<br/>        }<br/>}</span><span id="240d" class="kn ko hu kj b fv kt kq l kr ks">func QueryPersonByID(personID utils.UUID) db.Queryx {<br/>        return db.Queryx{<br/>                Query: queryPersonByID,<br/>                Params: []interface{}{<br/>                        personID,<br/>                },<br/>        }<br/>}</span><span id="a8d0" class="kn ko hu kj b fv kt kq l kr ks">func NewPerson() *Person {<br/>        return &amp;Person{PersonID: utils.NewUUID(), ModifiedDate: time.Now() }<br/>}</span><span id="dec6" class="kn ko hu kj b fv kt kq l kr ks">func (s *Person) Insert(tx *sqlx.Tx) error {<br/>        _, err := tx.NamedExec(string(queryPersonInsert), s)<br/>        return err<br/>}</span><span id="1f4f" class="kn ko hu kj b fv kt kq l kr ks">func (s *Person) Update(tx *sqlx.Tx) error {<br/>        s.ModifiedDate = time.Now()</span><span id="af93" class="kn ko hu kj b fv kt kq l kr ks">_, err := tx.NamedExec(string(queryPersonUpdate), s)<br/>        return err<br/>}</span><span id="9d02" class="kn ko hu kj b fv kt kq l kr ks">func (s *Person) Delete(tx *sqlx.Tx) error {<br/>        s.Active = false<br/>        return s.Update(tx)<br/>}</span></pre><p id="b654" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在已经定义了数据库和模型，您可以使用如下模式:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="cbe3" class="kn ko hu kj b fv kp kq l kr ks">tx := db.Begin()</span><span id="cc5d" class="kn ko hu kj b fv kt kq l kr ks">var err error<br/>defer func() {<br/>        if err != nil {<br/>                tx.Rollback()<br/>                return<br/>        }</span><span id="ddec" class="kn ko hu kj b fv kt kq l kr ks">tx.Commit()<br/>}()</span><span id="f3e5" class="kn ko hu kj b fv kt kq l kr ks">// retrieve single person<br/>person := model.Person{}<br/>if err := tx.Getx(&amp;person, model.QueryPersonByID(personID)); err != nil {<br/>        return err<br/>}</span><span id="a223" class="kn ko hu kj b fv kt kq l kr ks">person.Lastname = "Doe"</span><span id="d3e8" class="kn ko hu kj b fv kt kq l kr ks">// update the person<br/>if err := tx.Update(&amp;person); err != nil {<br/>        return err<br/>}</span><span id="8cae" class="kn ko hu kj b fv kt kq l kr ks">index := 0<br/>count := 50</span><span id="2c57" class="kn ko hu kj b fv kt kq l kr ks">// retrieve multiple paged persons<br/>persons := []model.Person{}<br/>if err := ctx.tx.Selectx(&amp;persons, model.QueryPersons(user), db.Limit(index, count)); err == sql.ErrNoRows {<br/>} else if err == nil {<br/>} else {<br/>        return err<br/>}</span><span id="a492" class="kn ko hu kj b fv kt kq l kr ks">// count number of results<br/>total, err := ctx.tx.Countx(model.QueryPersons())<br/>if err != nil {<br/>        return err<br/>}</span></pre><p id="0eb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Defer将检查是否发生了错误，以及是否将回滚事务。否则，它将只提交事务。我们不需要在实现中更新最后的修改日期，这在模型中已经考虑到了。我们还可以通过设置活动标志来定义不同的删除行为。可以实现附加的selectOptions，如limitOption。</p><p id="6903" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种模式有以下优点:</p><ul class=""><li id="3e71" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">完全负责查询定义，很容易定义连接、子查询或特定的优化</li><li id="ff55" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">使用这个新函数，你可以用缺省值进行初始化</li><li id="d36f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">每个操作(插入、更新或删除)都可以有一个带有附加检查或行为的自定义实现</li><li id="8b7f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">支持默认操作克林计数和限制</li><li id="d7df" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">所有的操作都是强类型的，避免了很多错误</li><li id="a6a9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">所有操作都组织在一个包中</li><li id="77c5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">所有的查询都是相互靠近的，这使得查询的验证变得容易(在添加字段或过滤器的情况下)</li><li id="bce1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">每个查询都包装在一个事务中</li><li id="701a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">可以使用枚举(如性别)</li><li id="ed96" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">测试可以很容易地在db类中实现</li><li id="0467" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">通过一些修改，查询可以根据所使用的数据库以不同的方式实现</li><li id="aa38" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">查询本身可以部分使用go generate生成</li></ul><p id="55cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缺点之一是你需要写相当多的代码，但是作为回报，所有的东西都是结构化的，可测试的，并且错误会少得多。</p><blockquote class="ku kv kw"><p id="d475" class="ir is kx it b iu iv iw ix iy iz ja jb ky jd je jf kz jh ji jj la jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="dca4" class="ir is kx it b iu iv iw ix iy iz ja jb ky jd je jf kz jh ji jj la jl jm jn jo hn dt translated">要了解更多信息，请<a class="ae jp" href="https://goo.gl/4ofytp" rel="noopener ugc nofollow" target="_blank">阅读我们的“关于”页面</a>、<a class="ae jp" href="http://bit.ly/HackernoonFB" rel="noopener ugc nofollow" target="_blank">在脸书上点赞/给我们发消息</a>，或者简单地说，<a class="ae jp" href="https://goo.gl/k7XYbx" rel="noopener ugc nofollow" target="_blank"> tweet/DM @HackerNoon。</a></p><p id="708a" class="ir is kx it b iu iv iw ix iy iz ja jb ky jd je jf kz jh ji jj la jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote></div></div>    
</body>
</html>