<html>
<head>
<title>Python functions, *args, **kwargs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python函数，*args，**kwargs</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/python-functions-args-kwargs-5d2d00f09c74?source=collection_archive---------1-----------------------#2017-09-01">https://medium.com/hackernoon/python-functions-args-kwargs-5d2d00f09c74?source=collection_archive---------1-----------------------#2017-09-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/687dc7b63b23ede01035b3e8d6750d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*_wbDOXgPIxEsHLu7KEFY_w.png"/></div></figure><p id="69a2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为什么在python中使用args和kwargs？不久前，我还不理解夸尔格斯，我发现写点东西有助于建立对主题的理解，它允许信息被消化，就像橡皮鸭。另外，因为学习很有趣，填补知识空白更好，所以我们开始吧。<a class="ae jw" href="https://rubberduckdebugging.com/" rel="noopener ugc nofollow" target="_blank">https://rubberduckdebugging.com/</a></p><p id="883b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我将从数字海洋教程中借用一些例子，因为他们解释的方式确实有助于我理解它。<a class="ae jw" href="https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/how-to-use-args-and-kwargs-in-python-3</a></p><p id="5bd8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">用python实现函数中的变量；为了将数据传递给函数，变量被设置并以特定的顺序传递。示例函数是用一个字符串和一个数字调用的，非常简单。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="f284" class="kg kh hu kc b fv ki kj l kk kl">def profile_info(username, followers):<br/> print(“Username: “ + username)<br/> print(“Followers: “ + str(followers))</span><span id="e2d7" class="kg kh hu kc b fv km kj l kk kl">profile_info("chris",15)</span><span id="c69c" class="kg kh hu kc b fv km kj l kk kl">&gt;&gt;Username: chris<br/>&gt;&gt;Followers: 15</span></pre><p id="363c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">问题:这种方法和函数调用要求变量以特定的顺序传递，并且所有的变量必须总是被传递。<br/>解决方案:添加一些缺省值，这样我们可以不传递或者传递一些值而不会出错。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="767d" class="kg kh hu kc b fv ki kj l kk kl">def profile_info(username="name", followers=0):<br/> print(“Username: “ + username)<br/> print(“Followers: “ + str(followers))</span><span id="02da" class="kg kh hu kc b fv km kj l kk kl">profile_info()<br/>profile_info(username="thor")</span><span id="d5a2" class="kg kh hu kc b fv km kj l kk kl">&gt;&gt;Username: name<br/>&gt;&gt;Followers: 0</span><span id="e37c" class="kg kh hu kc b fv km kj l kk kl">&gt;&gt;Username: thor<br/>&gt;&gt;Followers: 0</span></pre><p id="b306" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">好处:通过关键字传递时顺序无关紧要。如果我们想混合和匹配变量的顺序，我们可以传递带有关键字的变量。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="e16b" class="kg kh hu kc b fv ki kj l kk kl">def profile_info(username="name", followers=0):<br/> print(“Username: “ + username)<br/> print(“Followers: “ + str(followers))</span><span id="f0e8" class="kg kh hu kc b fv km kj l kk kl">profile_info(followers=6, username="thor")</span><span id="d5a4" class="kg kh hu kc b fv km kj l kk kl">&gt;&gt;Username: thor<br/>&gt;&gt;Followers: 6</span></pre><p id="2e13" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">很好，那么很多变量呢...使用*args，我们可以将数量未知的变量作为元组传递。元组和列表的区别是什么？在python中，元组是不可变的，而列表是可变的。</p><blockquote class="kn ko kp"><p id="bc4d" class="iy iz kq ja b jb jc jd je jf jg jh ji kr jk jl jm ks jo jp jq kt js jt ju jv hn dt translated">有些对象是可变的，这意味着它们可以被改变。其他的是不可改变的；它们不能被更改，而是在尝试更新时返回新的对象。<a class="ae jw" href="https://codehabitude.com/2013/12/24/python-objects-mutable-vs-immutable/" rel="noopener ugc nofollow" target="_blank">https://codehabitude . com/2013/12/24/python-objects-mutable-vs-immutable/</a></p></blockquote><p id="9188" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为什么可变性很重要？</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="14af" class="kg kh hu kc b fv ki kj l kk kl">string_build = ""<br/>for data in container:<br/>    string_build += str(data)</span></pre><p id="7646" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">很简单，但是因为字符串是不可变的对象，所以每次concat都会创建一个新的对象，丢弃旧的对象，结果会占用更多的内存。</p><p id="bc15" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">解决方案:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="8804" class="kg kh hu kc b fv ki kj l kk kl">builder_list = []<br/>for data in container:<br/>    builder_list.append(str(data))<br/>“”.join(builder_list)<br/> <br/>### Another way is to use a list comprehension<br/>“”.join([str(data) for data in container])<br/> <br/>### or use the map function<br/>“”.join(map(str, container))</span></pre><p id="304e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一个陷阱是使用一个列表作为函数的参数，也就是众所周知的可怜的args。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="53ca" class="kg kh hu kc b fv ki kj l kk kl">def my_function(param=[]):<br/> param.append(“thing”)<br/> return param<br/> <br/>my_function() # returns [“thing”]<br/>my_function() # returns [“thing”, “thing”]</span></pre><p id="1ef3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">尽管使用空列表作为默认值，python只对定义求值一次，因此空列表只在第一次被调用之前为空。该函数将在每次调用时重用相同的列表。*哎呀</p><p id="f62b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于函数，返回到*args。列表很酷，但是对函数参数使用*args选项非常有用。这样，函数可以接受任意数量的变量，而不必为每个排列重新构建调用。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="8bf5" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">def</strong> <strong class="kc hv">multiply</strong>(*args):<br/>    z = 1<br/>    <strong class="kc hv">for</strong> num <strong class="kc hv">in</strong> args:<br/>        z *= num<br/>    print(z)<br/><br/>multiply(4, 5)<br/>multiply(10, 9)</span></pre><p id="763e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这非常棒，但是它缺乏拥有不同的参数顺序和定义特定参数的能力。这给了我们在一个领域更多的灵活性，但在另一个领域却更少。对此有什么解决办法？</p><p id="0d4d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">* *克瓦查</p><p id="9db9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">KWargs或“关键字参数”允许您将带关键字的字典作为参数传递。因为字典几乎总是超级有用的。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="be72" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">def</strong> <strong class="kc hv">print_values</strong>(**kwargs):<br/>    <strong class="kc hv">for</strong> key, value <strong class="kc hv">in</strong> kwargs.items():<br/>        print("The value of {} is {}".format(key, value))<br/><br/>print_values(my_name="thor", your_name="hulk")</span></pre><p id="9f55" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">关键措辞的参数是一个相当奇妙的附加，然而，为了有效地利用它们，代码必须适当地处理字典。最后，如果目的是混合和匹配参数类型，声明的顺序需要像这样。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="29dc" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">def</strong> <strong class="kc hv">example2</strong>(arg_1, arg_2, *args, kw_1="shark", kw_2="blobfish", **kwargs):<br/>...</span></pre><p id="faeb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">传给args和kwargs呢？很简单，只需建立一个列表或字典，并将其传递给适当的函数。</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="373c" class="kg kh hu kc b fv ki kj l kk kl"><strong class="kc hv">def</strong> <strong class="kc hv">some_args</strong>(arg_1, arg_2, arg_3):<br/>    print("arg_1:", arg_1)<br/>    print("arg_2:", arg_2)<br/>    print("arg_3:", arg_3)<br/><br/>my_list = [2, 3]<br/>some_args(1, *my_list)</span><span id="f846" class="kg kh hu kc b fv km kj l kk kl"><strong class="kc hv">def</strong> <strong class="kc hv">some_kwargs</strong>(kwarg_1, kwarg_2, kwarg_3):<br/>    print("kwarg_1:", kwarg_1)<br/>    print("kwarg_2:", kwarg_2)<br/>    print("kwarg_3:", kwarg_3)<br/><br/>kwargs = {"kwarg_1": "Val", "kwarg_2": "Harper", "kwarg_3": "Remy"}<br/>some_kwargs(**kwargs)</span></pre><p id="3091" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">结论，args和kwargs在很多情况下都是很棒的，但是当然它们不是最终的解决方案。当编写函数和使用它们时，只使用需要的东西，不要只使用kwargs，因为它是一个新的闪亮的玩具，因为当你只有一把锤子时，一切都是钉子。考虑优化，考虑内存使用，考虑可维护性和可读性，然后为工作使用合适的数据类型。</p><p id="66cd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">感谢digital ocean编写了一个关于python的精彩教程，请认真阅读他们关于python的系列文章。</p><div class="ku kv fm fo kw kx"><a href="https://www.digitalocean.com/community/tutorials/how-to-use-args-and-kwargs-in-python-3" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab ej"><div class="kz ab la cl cj lb"><h2 class="bd hv fv z el lc eo ep ld er et ht dt translated">如何在Python 3 | DigitalOcean中使用*args和**kwargs</h2><div class="le l"><h3 class="bd b fv z el lc eo ep ld er et ek translated">在函数定义中，参数是指定给定函数可以接受的参数的命名实体。当…</h3></div><div class="lf l"><p class="bd b gc z el lc eo ep ld er et ek translated">www.digitalocean.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll iw kx"/></div></div></a></div><figure class="jx jy jz ka fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure></div></div>    
</body>
</html>