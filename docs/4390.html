<html>
<head>
<title>Serverless server-side rendering with React using Redux or MobX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux或MobX的React的无服务器服务器端渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-server-side-rendering-with-react-using-redux-or-mobx-ce32a121ce08?source=collection_archive---------3-----------------------#2017-05-30">https://medium.com/hackernoon/serverless-server-side-rendering-with-react-using-redux-or-mobx-ce32a121ce08?source=collection_archive---------3-----------------------#2017-05-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1bd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约两年前，我开始使用React，我一直对做服务器端渲染很好奇，但从来没有烦恼过。部分原因是我正在开发的最大的应用程序的大部分内容都在登录之后，不需要在每个页面上都进行大规模的搜索引擎优化(SEO )( T1 ),但也因为这看起来是一个巨大的麻烦，而且工具，比如说，发展得非常快。</p><p id="5553" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，当我的朋友<a class="ae jp" href="https://twitter.com/jotto" rel="noopener ugc nofollow" target="_blank">乔纳森</a>告诉我他正在开发<a class="ae jp" href="https://www.roast.io/" rel="noopener ugc nofollow" target="_blank">烤肉。io </a>时，我认为这将是一个很好的方式来满足我的好奇心和用React进行服务器端渲染的懒惰。</p><p id="e5c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">switch . io是一个前端主机，在部署到CDN之前使用headless Chrome渲染页面。换句话说，它为您完成所有的服务器端渲染，而不必有一个“前端服务器”，它知道如何做所有的事情，“预加载您的根组件，用props注入它，渲染到字符串，注入模板，等等。”假设它是一个CDN，(即它是一个缓存！)对于需要SEO，但不需要登录的页面来说非常好用。所以它不会解决所有的服务器端渲染问题，但是确实解决了一些高价值的问题。</p><p id="9bce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好，好，所以不是小计算功能意义上的capital-S无服务器，而是我不用运行服务器意义上的无服务器。这对于只想玩玩服务器端渲染的我来说很有帮助，但是对于那些拥有单页面应用程序的人来说却很难运行节点服务器。</p><p id="ff71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我开始创建一个项目来部署scatter . io，并想分享一下我的经验。剧透:它非常简单，只需要0-10行代码就可以实现服务器端渲染。除了加载速度更快之外，我还将客户端请求数量中的API调用数量从O(n)更改为O(1)。我探索了如何使用组件状态、<a class="ae jp" href="https://hackernoon.com/tagged/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>和MobX，所以我想看看不同的状态管理方案如何与scatter . io一起工作</p><p id="d6b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">免责声明:烘焙. io的创作者乔纳森是我的朋友。他让我去试一下bake . io，然后写博客，但是他没有付钱给我。我们最后一次出去的时候，他确实提议给我买咖啡，但是那天太晚了，我没时间喝咖啡。相反，我抓住了机会，写了一篇标题中有着令人难以置信的高流行词密度的文章，我们都在这里。</em></p><h1 id="2e25" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">让我们化妆吧</h1><p id="6caa" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">为了充分利用scatter . io，我需要一个API来加载一些数据。浏览<a class="ae jp" href="https://github.com/toddmotto/public-apis" rel="noopener ugc nofollow" target="_blank">这个令人敬畏的公共API列表</a>，我发现了<a class="ae jp" href="http://makeup-api.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">化妆API </a>，它非常完美——它在JSON中开放了大量细节和图片链接。我开始制作一个非常简单的React应用程序，按品牌显示化妆品。(我最喜欢的API数据是，它为许多产品的不同颜色选项提供了十六进制代码。那是一个<a class="ae jp" href="https://github.com/emilong/makeup/blob/master/src/ProductColors.js" rel="noopener ugc nofollow" target="_blank">好玩的反应组件</a>。💅)</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/e06d7912e08b72115398d0e05ee9b65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/1*0INLpKnJkUrysm8Lws_-kA.gif"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">The makeup app</figcaption></figure><p id="dc48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好吧，所以化妆比我的应用程序好看多了，但它应该有助于我们测试服务器端的渲染。你可以去查看应用程序的<a class="ae jp" href="https://github.com/emilong/makeup" rel="noopener ugc nofollow" target="_blank">源代码和部署的应用程序</a>的<a class="ae jp" href="https://broken-apparel-8185.roast.io/revlon" rel="noopener ugc nofollow" target="_blank">，但是你会发现它看起来更像是一个(粗糙的)反应应用程序。换句话说，我变得懒惰，在让服务器端渲染工作时几乎什么都不做。我会在下面描述我做了什么。</a></p><p id="5abe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> F </span>首先，我尝试使用<a class="ae jp" href="https://github.com/emilong/makeup/tree/component-state" rel="noopener ugc nofollow" target="_blank">组件状态</a>按品牌加载数据，因为应用程序并不太复杂。换句话说，当React路由器加载一个品牌时，品牌组件会查看路径，从API请求该品牌的数据，然后使用setState()将其保存在本地。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lp lq l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Saving data in component state</figcaption></figure><p id="2bf7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我部署时，我需要创建一个名为<a class="ae jp" href="https://github.com/emilong/makeup/blob/master/_ssr.json" rel="noopener ugc nofollow" target="_blank"> _ssr.json </a>的小文件，其中包含我希望在服务器上呈现的路径列表。许多应用程序可能不需要这样做，因为scatter . io会抓取你的网站，但我必须特别做一个没有默认登陆页面的应用程序。幸运的是，我喜欢雪花。❄️</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/c0506efd4664a286579667a9a2516213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*nE5slGnNySfjCQzqnyGxdA.gif"/></div></figure><p id="5095" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除此之外，我什么也没做。该应用程序已部署，所有标记都在第一次下载时呈现。万岁。</p><p id="7098" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法的唯一问题是，尽管页面可以快速加载所有呈现的标记，但当每个用户访问时，它仍然会进行额外的获取，因为应用程序无法知道它是在服务器端呈现的。虽然我们可以使用组件状态来处理这个问题，但是Redux社区有很多关于状态“再水化”的文档。所以我试着把应用程序转换成Redux…</p><p id="bd77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt lg translated">唱Redux " <a class="ae jp" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank">鸭子</a>"风格，我创建了一个减速器与行动和行动的创造者如下所示。(你可以浏览代码，我在后面总结了重要的部分。)</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lp lq l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Reducer, actions, and action creators for the API</figcaption></figure><p id="771d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在这里使用了<a class="ae jp" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>来实现异步，因为我们只有一个调用。基本的获取是相同的，但是有一些显著的变化:</p><ul class=""><li id="0840" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo lx ly lz ma dt translated">它是可还原的，也就是说，它不需要对任何结构进行修改，reducer将所有东西集成到一个状态树中。</li><li id="f2cc" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">状态树保存了我们遇到的任何品牌的所有数据，因此切换回我们已经见过的品牌会更快。</li><li id="0d7e" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">该组件现在检查它所呈现的品牌是否在状态树中可用，如果不可用，则只获取。</li><li id="3e57" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">状态树还保存了一个“进行中”的品牌列表，所以如果我们想要的话，我们可以显示一个微调器，这样我们就不会获取一个已经在进行中的品牌。</li></ul><p id="44e4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不过最重要的是，注意我们从__PRELOADED_STATE__获取初始Redux状态，如果它可用的话。如果你的应用程序使用这个变量的话，它可以作为保存和加载预加载状态的句柄。在reducer中，我们机会性地使用它，但是如果它不在那里，就退回到空状态。</p><p id="f081" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果它是可用的，并且具有我们试图呈现的品牌的数据，则组件不会获取。它只会使用预加载状态下的内容。此外，如果已经呈现了标记，React不需要更改DOM，因为它会意识到它只是呈现了与服务器端由soat . io呈现的一样的东西，因为<a class="ae jp" href="https://stackoverflow.com/questions/34311221/what-is-checksum-in-react-and-how-to-use-it" rel="noopener ugc nofollow" target="_blank">校验和</a>在缓存的页面上是完整的。</p><p id="5891" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么它是如何到达那里的呢？好吧，因为在它的服务器渲染阶段结束时，scatter . io只是序列化__PRELOADED_STATE__指向的任何东西，所以我们可以将__PRELOADED_STATE__设置为等于reducer每次更新它时的状态。Redux为我们提供了一个优秀的中间件框架来相对容易地做到这一点。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lp lq l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Configuring the store to use our preloaded state-saving middleware</figcaption></figure><p id="1201" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果我们用上面附加的中间件来设置我们的商店，那么scatter . io将保存整个Redux商店，并将其“脱水”到缓存页面中。当我们再次创建我们的存储时，我们将从__PRELOADED_STATE__开始对其进行“再水合”。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/491558cdc5cb2a1194bfd0bc534da9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*oUQg-66GQi8SgOY2x__otw.gif"/></div></figure><p id="5f73" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">概括地说，当页面加载时，标记已经就位，因此浏览器可以立即开始呈现，Redux存储的状态将被加载，因此在第一个页面视图上没有API调用。我们正在有机会地使用__PRELOADED_STATE__，因此我们不必在我们的开发环境中对我们的soat . io部署做任何不同的事情。(另外，如果你想退出switch . io，你不需要修改任何代码，但是不要告诉Jonathan是我说的。)</p><blockquote class="mh"><p id="8a6e" class="mi mj hu bd mk ml mm mn mo mp mq jo ek translated">这个页面只需要一个API调用<strong class="ak"><em class="mr"/></strong><em class="mr"/>就可以搜索到任意数量的客户端。</p></blockquote><p id="abd0" class="pw-post-body-paragraph ir is hu it b iu ms iw ix iy mt ja jb jc mu je jf jg mv ji jj jk mw jm jn jo hn dt translated">这样，对于通过搜索到达的任意数量的客户端，该页面只需要一次API调用。虽然这个例子中的API是免费的，但是Firebase和您自己的自托管API却不是，所以这个架构可以为您节省相当多的后端成本。</p><p id="8b70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt lg translated">虽然Redux是我第一次进入React state，但我最近也开始关注MobX。我知道Redux有很多使用预加载状态的基础设施，但是我不太熟悉MobX的服务器端渲染功能。我非常惊讶地发现，它不仅真的很容易做到，而且它与scatter . io的__PRELOADED_STATE__变量设置方法配合得非常好。我将项目转换为在这个<a class="ae jp" href="https://github.com/emilong/makeup/tree/mobx" rel="noopener ugc nofollow" target="_blank">分支</a>上使用MobX。</p><p id="6850" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您不熟悉MobX，那么对于本文，您需要知道的主要区别是，它就地修改状态，并使用反应式架构发布更改。<em class="jq">到位</em>的事情才是重要的事情。下面是我们州对于化妆app的样子:</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lp lq l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">MobX store for brand data</figcaption></figure><p id="f249" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了特殊的装饰者，它实际上只是一个ES6类。我们保留的数据与Redux方法相同，只是在ES6集合和MobX可观察地图中(就我们的目的而言，这与ES6地图非常相似)。在初始化时，我们获取一些预加载的状态，并将其设置为可被MobX观察到，做一些定制工作，但不是太多。这个类类似于我们在上面用Redux reducer所做的。</p><p id="191b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么我们如何让预加载的状态保存和加载呢？因为存储是就地修改的，所以我们只需在创建时设置__PRELOADED_STATE__一次。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lp lq l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Initializing and saving the MobX store</figcaption></figure><p id="6823" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就是这样！🎉我们甚至不需要用每个动作更新__PRELOADED_STATE__。我们获得了服务器端呈现标记的所有好处，并且没有API调用。</p><h1 id="aadf" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">去试试吧</h1><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/b417cf0aa2f926047c423ef6ae84b17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*LwrsGq38CJ0bx-BDbLXnvg.gif"/></div></figure><p id="3d12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以我不知道这次体验算不算我在做设置服务器端渲染，但是我<em class="jq">得到了</em>服务器端渲染，所以我要把它算作一次胜利。所以试一试吧——这里有一个免费层，你所要做的就是启动NPM install-g bake，然后运行roast deploy。</p><p id="d154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望尽快尝试Vue，看看效果如何。如果有人尝试用bake . io，请在回复中告诉我！</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="9ccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">你知道为什么灵媒要用绿心吗💚而不是红色或其他颜色？我也是，但我真的很感激喜欢我帖子的人点击💚。接下来也很棒。:)谢谢！</em></p><div class="kv kw kx ky fq ab cb"><figure class="nf kz ng nh ni nj nk paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nf kz ng nh ni nj nk paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nf kz ng nh ni nj nk paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nl nm nn"><p id="f922" class="ir is jq it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jp" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jq it b iu iv iw ix iy iz ja jb no jd je jf np jh ji jj nq jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="fe ff nr"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="nw lq l"/></div></figure></div></div>    
</body>
</html>