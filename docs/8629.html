<html>
<head>
<title>Non event-driven redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非事件驱动的冗余</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/non-event-driven-redux-5ce56776184f?source=collection_archive---------7-----------------------#2017-12-08">https://medium.com/hackernoon/non-event-driven-redux-5ce56776184f?source=collection_archive---------7-----------------------#2017-12-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e48f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">如果对前端来说通量的核心思想是错误的呢？</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/ab783f0732945cec14e9097d1d1d9536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00F8QCjUhHAXqhnorGZSOg.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/photos/-Cmz06-0btw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae jz" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da63" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当你第一次听说通量时，你可能会感到困惑。回过头来看，这么简单的东西竟然让我花了这么多文章和教程来理解，这有点令人惊讶。我非常感谢Redux是Flux最受欢迎的衍生产品之一，因为它确实是Flux核心方面的一个非常简单的表达——一个单向的数据流，涉及到调度一个动作来改变存储以改变视图的过程。</p><blockquote class="kw kx ky"><p id="69df" class="ka kb kz kc b kd ke iv kf kg kh iy ki la kk kl km lb ko kp kq lc ks kt ku kv hn dt translated">动作是简单的对象，包含新数据和一个标识性的<em class="hu">类型</em>属性。—<a class="ae jz" href="https://facebook.github.io/flux/docs/in-depth-overview.html#content" rel="noopener ugc nofollow" target="_blank">https://Facebook . github . io/flux/docs/in-depth-overview . html # content</a></p></blockquote><p id="46b2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">脸书给出了这个动作的具体定义，一个具有特定属性的普通javascript对象。尽管脸书从未明确地将动作改变商店的过程描述为事件驱动的架构，但当使用普通的javascript对象来改变商店时，很难想象有任何其他的设计模式。</p><p id="fe7f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">事件驱动架构中有一些常见的关键模式。事件采购和事件通知是马丁·福勒<a class="ae jz" href="https://martinfowler.com/articles/201701-event-driven.html" rel="noopener ugc nofollow" target="_blank">在他的博客</a>中谈论的两个话题。事件源是关于存储一系列事件，以便可以用来重建系统状态。事件通知是关于从一个不知道谁使用这些动作的系统中分派动作。事件通知的优势之一是它提供了解耦。发出一个事件，任何进程都可以使用该事件，而不需要知道还有谁在使用该事件。我认为Flux肯定展示了事件源和事件通知，但是后者的质量有潜在的问题。</p><p id="cec0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">事件通知的一个问题是，很难跟踪到事件处理程序的事件流，因为该流是隐式的，而不是显式的。一旦一个事件被发出(或者一个动作被分派)，它就进入一种黑盒，返回改变后的状态。在Redux世界中，已经尝试采用某些标准来使这些关系更加明确(例如<a class="ae jz" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank">像鸭子</a>)，但是真正的问题是为什么有必要使这种关系更加明确？对于使用事件通知来说，这应该是一个可以接受的折衷，但是相反，没有人真正理解他们为什么要首先做出这样的折衷。</p><p id="bb08" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我认为Flux的部分问题在于脸书开发它是为了自己的应用。脸书有非常复杂的应用程序，我猜这些应用程序的前端组件非常复杂，以至于他们实际上需要多个团队来监管特定的领域。我认为Flux在这种情况下是有意义的，但就我个人而言，我从未参与过任何需要多个独立团队的项目。我说的不是3或4个人一起工作来完成前端的某些方面，我说的是15个以上的开发人员组成的专门部门，他们很少看到任何重叠的工作。</p><p id="30e0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有可能通量对脸书来说并不理想。我们知道他们在开源技术之前几年就采用了Graphql，如果他们使用Relay或一些等效的库来管理状态，那么他们并没有真正使用Flux。是的，Relay受到Flux的启发，但是Relay中调度动作的过程是如此的隐蔽，只有在使用调试工具时才可见。仔细想想，中继甚至可能不是调度动作。从官方的中继文档“commitUpdate类似于在流动中调度一个动作”，但是为什么它是类似的而不是简单地调度一个动作呢？</p><p id="b30b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">流量和事件通知的真正问题是前端耦合的问题。我们听说了很多关于微服务和更小范围的无服务器功能的事情，但是在前端并没有相同的概念。前端的某些特性使得它几乎不可能分成更小的封装。可能是因为前端是所有东西汇集在一起的地方。也许是因为前端的体验应该贯穿整个应用程序。无论是什么，前端都很难分成更小的组件，因此当我们不可思议地从一个系统发出事件时，我们实际上只是在向自己发出事件。</p><p id="b8de" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">Dan Abramov 谈到了Redux的<a class="ae jz" rel="noopener" href="/@dan_abramov/you-might-not-need-redux-be46360cf367">极限，以及它并不适用于每个项目。</a> Redux并不完美，但它很好地满足了自己的目的。两年前，它风靡全球，除了Relay，它是React最流行的状态管理工具。也许是时候换一种方式了。也许是一种非事件驱动的Redux方法。</p><pre class="jk jl jm jn fq lf lg lh li aw lj dt"><span id="e2bc" class="lk ll hu lg b fv lm ln l lo lp">import {createStore} from 'noredux'</span><span id="5960" class="lk ll hu lg b fv lq ln l lo lp">const initialState = 1</span><span id="13c6" class="lk ll hu lg b fv lq ln l lo lp">const store = createStore(initialState)</span><span id="5c6d" class="lk ll hu lg b fv lq ln l lo lp">const reducer = (state)=&gt;state + 1</span><span id="8d8f" class="lk ll hu lg b fv lq ln l lo lp">store.dispatch(reducer)</span><span id="54d4" class="lk ll hu lg b fv lq ln l lo lp">console.log(store.getState())</span><span id="098d" class="lk ll hu lg b fv lq ln l lo lp">// 2</span></pre><p id="38a7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">不仅Redux (noredux)是一个库，它用不同的方法来引起状态的变化。不是调度一个动作，而是调度一个缩减器。这是一种明确的状态变更方法。</p><p id="5534" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">但是不要被愚弄了，这种方法有它自己的局限性。以类似于传统Redux的combineReducers的方式实现关注点分离并不容易。</p><pre class="jk jl jm jn fq lf lg lh li aw lj dt"><span id="2135" class="lk ll hu lg b fv lm ln l lo lp">import {scopeReducer} from 'noredux'</span><span id="b668" class="lk ll hu lg b fv lq ln l lo lp">const pretodosReducerCreator = () =&gt; state =&gt; state + 1<br/>const selector = state =&gt; state.todos<br/>const setter = (state, result)=&gt;({...state, todos: result})</span><span id="a5fd" class="lk ll hu lg b fv lq ln l lo lp">const todosReducerCreator = scopeReducer(selector, setter, pretodosReducer)</span></pre><p id="6712" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">或者</p><pre class="jk jl jm jn fq lf lg lh li aw lj dt"><span id="81ad" class="lk ll hu lg b fv lm ln l lo lp">import {defaultScopeReducer} from 'noredux'</span><span id="b599" class="lk ll hu lg b fv lq ln l lo lp">const pretodosReducerCreator = () =&gt; state =&gt; state + 1</span><span id="7a09" class="lk ll hu lg b fv lq ln l lo lp">const todosReducer = defaultScopeReducer('todos', pretodosReducerCreator)</span></pre><p id="772c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我个人认为，图书馆背后的理念比图书馆本身更重要。让Redux更显式。对于任何想要试用Noredux的人，你可以在<a class="ae jz" href="https://github.com/l2silver/noredux" rel="noopener ugc nofollow" target="_blank"> noredux github repo </a>中看到一个例子。如果你决定尝试使用Noredux，目前还没有太多的基础设施，所以你不能使用chrome redux devtools或react-router-redux(但react-redux可以很好地与noredux配合使用)。</p><p id="7ae1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">也就是说，我创建了一个<a class="ae jz" href="https://github/com/l2silver/redux-noredux" rel="noopener ugc nofollow" target="_blank"> redux-noredux </a>包，这样你就可以在redux项目中使用noredux，<a class="ae jz" href="https://github.com/l2silver/redux-noredux" rel="noopener ugc nofollow" target="_blank"> github repo </a>中有一个示例应用程序来演示它的用法。目前，这是Noredux的首选实现。</p><pre class="jk jl jm jn fq lf lg lh li aw lj dt"><span id="2fb1" class="lk ll hu lg b fv lm ln l lo lp">import {createStore} from 'redux'<br/>import {noreduxAction, enableNoredux} from 'redux-noredux'<br/>import reducers from './reducers'</span><span id="f2fe" class="lk ll hu lg b fv lq ln l lo lp">const store = createStore(enableNoredux(reducers), {todos: 0})</span><span id="382d" class="lk ll hu lg b fv lq ln l lo lp">const noreduxReducer = (state)=&gt;({...state, todos: state.todos + 1})</span><span id="f137" class="lk ll hu lg b fv lq ln l lo lp">noreduxReducer.type = 'exampleType'<br/>noreduxReducer.args = []</span><span id="2685" class="lk ll hu lg b fv lq ln l lo lp">store.dispatch(noreduxAction(noreduxReducer))</span><span id="82ef" class="lk ll hu lg b fv lq ln l lo lp">/*<br/>{<br/>  type: '@@redux-noredux/exampleType'<br/>  args: [],<br/>  reducer: noreduxReducer,<br/>  noredux: true,<br/>}<br/>*/</span></pre><p id="0344" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">如果您使用redux的combineReducers，这种方法有一点需要注意。CombineReducers不允许没有附属于它们的reducer的状态属性，所以你需要伪造它。</p><pre class="jk jl jm jn fq lf lg lh li aw lj dt"><span id="c019" class="lk ll hu lg b fv lm ln l lo lp">import {combineReducers} from 'redux'<br/>import {fakeReducer} from 'redux-noredux'<br/>import soonToBeDones from './soonToBeDones'</span><span id="fa45" class="lk ll hu lg b fv lq ln l lo lp">import {initialState as todosInitialState} from './todos'</span><span id="d721" class="lk ll hu lg b fv lq ln l lo lp">export default combineReducers({<br/>  soonToBeDones,<br/>  todos: fakeReducer(todosInitialState)<br/>})</span></pre><p id="6a03" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">干杯。</p></div></div>    
</body>
</html>