<html>
<head>
<title>JS: Let’s try the future today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们今天试试未来</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/js-lets-try-the-future-today-ae74f3fbe656?source=collection_archive---------19-----------------------#2017-10-02">https://medium.com/hackernoon/js-lets-try-the-future-today-ae74f3fbe656?source=collection_archive---------19-----------------------#2017-10-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="dd14" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个简单的练习，我试图在没有任何第三方依赖或构建工具的情况下构建一个基本的网站(SPA ),但假设我们处于一个所有浏览器都实现了大多数现代Javascript APIs的世界。</p><p id="7a65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是我们将要建立的:(<a class="ae jp" href="http://podcaster-vanilla-components.surge.sh/" rel="noopener ugc nofollow" target="_blank">演示在这里</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/2dd838cfcde89dd84f0ff129f1787eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3uG3I-Dyxujk9uu_hpZoQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Podcaster home page</figcaption></figure><p id="b3bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个简单的网站来寻找音乐播客，列出他们的插曲，并听取他们。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/2a131d06e02b0d9f836697035fc36ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdjJQuRUx3c-gKEKFQhQTw.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Podcast detail page</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/badb761a97a5e53a403f8344f2549157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8X3fPD1ENdUUfc0Q2rshaw.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Episode detail page</figcaption></figure><p id="0052" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主要思想是采用基于组件的方法，因此，记住这一点，这是我将用于代码的结构:</p><pre class="jr js jt ju fq kg kh ki kj aw kk dt"><span id="b2a0" class="kl km hu kh b fv kn ko l kp kq">&lt;<em class="kr">root</em>&gt;<br/> <!-- -->+ <!-- -->index.html<br/> <!-- -->+<!-- --> src<br/>   - styles<br/>   - js<br/>     <!-- -->*<!-- --> <strong class="kh hv">api</strong> (here is the code to access podcasts services)<br/>     <!-- -->*<!-- --> <strong class="kh hv">components</strong> (here are the views and partials for the UI)<br/>     <!-- -->*<!-- --> <strong class="kh hv">config</strong> (here is the routing configuration)<br/>     <!-- -->*<!-- --> <strong class="kh hv">plugins</strong> (support code)</span></pre><p id="9fab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">你可以在这里 </strong> 得到最终代码 <a class="ae jp" href="https://github.com/PaquitoSoft/podcaster-vanilla-components" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="kr">。</em></strong></a></p><p id="b214" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我将使用的第一个好东西是现代浏览器(Chrome和Safari)中的<a class="ae jp" href="https://www.chromestatus.com/features/5365692190687232" rel="noopener ugc nofollow" target="_blank"> Javascript模块加载支持</a>。</p><p id="b5d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，HTML文件将如下所示:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="078d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里重要的部分是<em class="kr">脚本</em>标签的<strong class="it hv">类型</strong>属性。<br/>使用“<strong class="it hv">模块</strong>”值，您告诉浏览器使用<a class="ae jp" href="http://2ality.com/2014/09/es6-modules-final.html" rel="noopener ugc nofollow" target="_blank"> ES2015 javascript模块</a>语法及其<em class="kr">导入/导出</em>API。</p><p id="1eb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在标记中，我们只设置了一个根入口点，我们将从主文件中<em class="kr">挂载</em>我们的应用程序。</p><h2 id="e1c7" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">应用程序主文件</h2><p id="8bae" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">该主文件插入应用程序布局(一个带有微调器的头，我们将使用它来加载状态),并将主要内容呈现委托给应用程序路由器:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="9d66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们只需用布局创建一个新的<em class="kr"> html </em>元素，并用路由配置设置客户端路由器，它应该在其中呈现主要内容的根元素(基于URL)和一个侦听器，这样我们就可以对加载事件做出反应(当数据没有被缓存时跨页面转换)。</p><h2 id="6f4c" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">路由器</h2><p id="cf66" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">所以，客户端路由。许多人会自动寻找第三方库，因为这似乎是一个复杂的领域，但事实是，如果您只需要处理简单的导航，从头构建一个路由器并不困难。它只是将你的URL与一个组件同步。关于渲染组件所需的数据，你可以设置组件来加载它，或者你可以让路由器加载它并把它传递给组件。我更喜欢第二种方式，因为我不希望新页面在获得数据之前就开始呈现，我也不想为每个页面处理一个<em class="kr">加载</em>状态(如果您为此创建助手组件，我认为最好使用<em class="kr">路由器</em>)。</p><p id="a2a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是应用程序路由器:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="516b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个简单的问题，但它足以开始。我在其他一些项目中使用了这种方法，使用了稍微复杂一点的路由器，我通常会创建另一个文件用于<em class="kr"> popstate </em>的正确处理，并导出一些<em class="kr"> navTo </em>和<em class="kr"> redirectTo </em>助手函数。</p><p id="b6f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是我们所做的:</p><ul class=""><li id="41ff" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo lx ly lz ma dt translated">监听文档中链接的点击事件</li><li id="db4a" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">监听URL中的外部变化(例如:浏览器中的<em class="kr">后退</em>和<em class="kr">前进</em>按钮)</li><li id="ff40" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">当页面加载时触发第一次更改URL处理</li></ul><p id="215b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们需要加载新页面时:</p><ul class=""><li id="9080" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo lx ly lz ma dt translated">根据我们要导航到的URL，找到正确的路由器配置</li><li id="3d57" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">一旦我们有了那个，我们就从URL中提取数据加载器可能需要的参数</li><li id="35b3" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">调用加载程序来获取所需的数据</li><li id="4e75" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">更新路由器内部状态:新视图组件和新数据</li><li id="8bee" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">通过用新数据实例化一个新组件，用新状态重新呈现路由器主元素，并调用其<strong class="it hv">呈现</strong>函数，该函数返回一个<em class="kr"> HTMLElement </em>。</li><li id="9491" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">恢复滚动位置</li></ul><p id="4c2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有执行回调来显示应用程序加载指示器。</p><h2 id="2492" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">主页</h2><p id="df86" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">好了，接下来我们需要了解的是<em class="kr">页面</em>(主页、播客详情和剧集详情)。<br/>我们刚刚看到<em class="kr">页面</em>可能有一个接受初始数据的<strong class="it hv">构造器</strong>和一个<strong class="it hv">渲染</strong>函数，该函数必须返回一个包含预期内容的<em class="kr"> HTMLElement </em>。</p><p id="dd19" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于所有的<em class="kr">页面</em>都有一些共同的行为，并且我们需要它们的几个实例，我们将为它们创建一个基类，每个页面都将继承这个基类。</p><p id="5c46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的页面将会有一个来自<a class="ae jp" href="http://backbonejs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">的主干</strong> </a>和另一个来自<a class="ae jp" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">的反应</strong> </a>。<br/>让我们开始看看<em class="kr">首页</em>视图。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="8240" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在页面的<em class="kr">构造器</em>中，我们接收来自<em class="kr">路由器</em>的数据，并调用parent来存储实例状态。我们将使用该状态来重新呈现视图。</p><p id="7ce7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还有一个<em class="kr"> getter </em>，它返回页面必须处理的DOM事件的映射。语法灵感来自<a class="ae jp" href="http://backbonejs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">骨干</strong> </a> <strong class="it hv">。</strong> <br/>每个条目的键都有几个部分:第一部分是我们想要监听的DOM事件的名称，第二部分是用于"<em class="kr">我们想要将监听器附加到的元素"的<em class="kr">选择器</em>；</em>第二部分是我们希望与事件关联的函数。<br/>实际上，事件监听器并不绑定到选择器所表示的元素，它们都绑定到视图实例的根元素，并且在<em class="kr">基页</em>中有委托管理。</p><p id="baf0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">呈现过程中使用的函数是<strong class="it hv"> html </strong>函数，它必须返回一个表示html的字符串，以可视化页面及其提供的状态。<br/>在<em class="kr">路由器</em>中，我们看到我们正在为页面生成内容，调用一个返回HTMLElement的<em class="kr">渲染</em>函数。该功能是在<em class="kr"> BasePage </em>类中实现的(我们马上就要实现了)。</p><p id="0822" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后需要注意的是静态的<strong class="it hv"> dataLoader </strong>函数，路由器使用它来知道如何加载(异步)这个视图需要的数据。</p><h2 id="f18c" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">基本页面类</h2><p id="3db7" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">到目前为止一切顺利。让我们看看每个应用程序页面的基类:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div></figure><p id="a38e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在构造函数中，我们存储从page类接收的数据，为这个视图创建根HTMLElement，并注册子类可能定义的可能的DOM事件处理程序。</p><p id="d630" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们只有一个更新实例状态的函数(重新呈现页面实例)和一个呈现函数，用于设置根实例HTMLElement中子类产生的HTML字符串。</p><h2 id="6ac1" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">分音</h2><p id="4aa9" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">如果你回到<em class="kr">主页</em>渲染代码，你会注意到每个播客信息都是使用<em class="kr">播客摘要</em>部分渲染的。</p><p id="d1b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种组件比较简单，因为它不需要处理导航，也不需要动态状态。<br/>这些就像<a class="ae jp" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> React </strong> </a>中的 无状态功能组件。它们只是接收要呈现的数据并返回相应的HTML字符串。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ks kt l"/></div></figure><h2 id="987d" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">代码的其余部分</h2><p id="5c34" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">其他页面的代码与你刚刚在<em class="kr">主页</em>类中看到的非常相似。<br/>还有其他一些相关的文件:</p><ul class=""><li id="8cdf" class="ls lt hu it b iu iv iy iz jc lu jg lv jk lw jo lx ly lz ma dt translated">/src/api/ <strong class="it hv"> podcaster.js </strong>这个文件保存了对iTunes播客服务的AJAX调用以及获取播客RSS详细信息文件的请求。</li><li id="0f32" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">/src/plugins/<strong class="it hv">local-cache . js</strong>这个文件是本地存储API的代理，允许存储带有生存时间元信息的值。</li><li id="a756" class="ls lt hu it b iu mb iy mc jc md jg me jk mf jo lx ly lz ma dt translated">/src/plugins/ <strong class="it hv"> ajax.js </strong>这个文件是fetch API的一个瘦包装器，以简化它的使用。</li></ul><p id="b3cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以在这里浏览/下载这个宠物项目的<a class="ae jp" href="https://github.com/PaquitoSoft/podcaster-vanilla-components" rel="noopener ugc nofollow" target="_blank">完成代码，以了解他们的详细信息。</a></p><h2 id="83af" class="kl km hu bd ku kv kw kx ky kz la lb lc jc ld le lf jg lg lh li jk lj lk ll lm dt translated">结论</h2><p id="9d58" class="pw-post-body-paragraph ir is hu it b iu ln iw ix iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo hn dt translated">正如你所看到的，使用最新的浏览器，你可以很容易地实现一个没有第三方依赖的<strong class="it hv">基本</strong>解决方案。</p><p id="c443" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我确信，一两年后，当所有的浏览器都实现了这种API时，将会有新的优秀的API出现，只在一两个浏览器中可用，所以我们仍然会等待所有的浏览器都实现它们，就像我们现在一样。但是，你知道吗？这让我们的生活充满乐趣。</p><p id="3a2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您已经读到这里，我想感谢您给我一些时间，我希望您能在这篇文章中找到一些有用的东西。</p></div><div class="ab cl mg mh hc mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hn ho hp hq hr"><p id="3adb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">额外奖励</strong>:我已经写了一篇后续文章来展示将<em class="kr">代码分割</em>添加到这个基本应用程序中是多么容易。<br/>来看看吧！<a class="ae jp" rel="noopener" href="/@paquitosoftware/js-lets-try-the-future-today-extra-bonus-43e9e1a8480a"> <strong class="it hv"> JS:今天就来试试未来(额外奖励)</strong> </a></p></div></div>    
</body>
</html>