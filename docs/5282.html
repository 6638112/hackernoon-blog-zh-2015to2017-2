<html>
<head>
<title>Catamorphisms for Java developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java开发人员的变形</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/catamorphisms-for-java-developers-e3cc10b43d03?source=collection_archive---------1-----------------------#2017-07-19">https://medium.com/hackernoon/catamorphisms-for-java-developers-e3cc10b43d03?source=collection_archive---------1-----------------------#2017-07-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="92ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我们将深入探讨一个有用的概念，即catamorphism，它在函数式语言中很常用，但在<a class="ae jp" href="https://hackernoon.com/tagged/java" rel="noopener ugc nofollow" target="_blank"> Java </a>中却很少见。变形很容易实现，通常只需要几行Java代码。这几行代码为您的内部API增加了巨大的能力，有效地引入了编译器强制的、详尽的结构模式匹配，这种匹配可以消除通过复杂的if / then / else意面代码潜入的令人沮丧且难以阻止的错误。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/7a79a3cbcc452ab1063da5672c57884a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zh8Ta2IiqVwmSHGU5kSE6Q.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Photo by <a class="ae jp" href="http://unsplash.com/photos/kMU_2u2Ap2g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">James McGill</a> on <a class="ae jp" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="7118" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">简单的概念，复杂的单词</h2><p id="e9f1" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Catamorphism这个词是由希腊语向下(cata)和转换(morphism)组成的，对于大多数Java开发人员来说可能听起来很陌生。T2维基百科上的定义是</p><blockquote class="lg lh li"><p id="d703" class="ir is lj it b iu iv iw ix iy iz ja jb lk jd je jf ll jh ji jj lm jl jm jn jo hn dt translated">在函数式<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>，<strong class="it hv">中，变形</strong>将列表的折叠推广到任意代数数据类型，这可以被描述为初始代数</p></blockquote><p id="616e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对大多数人来说可能是完全难以理解的。这很遗憾，因为变形既是一个非常有用又相当简单的概念，可以用来产生更干净(主观上)和更安全/更少bug(客观上)的代码。</p><h1 id="82b5" class="ln kh hu bd ki lo lp lq km lr ls lt kq lu lv lw kt lx ly lz kw ma mb mc kz md dt translated">Lambda访问者模式</h1><p id="29e5" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">虽然术语catamorphism可能还没有进入主流Java词典，但是将principal编纂成四人组设计原则已经进入了主流词典。visitor模式定义了一种实现catamorphisms的麻烦而复杂的方式(这可能是它没有被广泛使用的原因)。幸运的是，随着Java 8的到来，实现visitor模式(以及更一般的catamorphisms)变得简单多了。</p><h1 id="1373" class="ln kh hu bd ki lo lp lq km lr ls lt kq lu lv lw kt lx ly lz kw ma mb mc kz md dt translated">可选的同态</h1><p id="c4d2" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">当实现一个变形时，目标是以一种安全的、穷尽的方式提供对一个类型的关键结构信息的访问。Java 8的可选类可以处于两种状态之一</p><blockquote class="me"><p id="90ca" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">呈现(有一些数据)</p><p id="08a1" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">空的(没有数据)</p></blockquote><p id="ccb6" class="pw-post-body-paragraph ir is hu it b iu mo iw ix iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo hn dt translated">Optional的变形可以写成两个函数</p><blockquote class="me"><p id="10e0" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated"><em class="mt"> Present:接受可选值的j.u .函数</em></p><p id="63b9" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated"><em class="mt"> Empty:一个j.u.Supplier，被执行以检索一个值</em></p></blockquote><p id="4722" class="pw-post-body-paragraph ir is hu it b iu mo iw ix iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo hn dt translated">catamorphism的调用者提供了两种函数类型的lambda(或其他实现),只有其中一个根据状态被选择性地执行。</p><p id="724b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以简单地如下定义可选的同态</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mu"><img src="../Images/974f055c9daba5781dafa848bfa4acdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYJbye6LlX5KqksxJ1YDGw.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">This is the catamorphism implementation for Optional in cyclops-react Optionals companion class</figcaption></figure><p id="5a50" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了使用catamorphism，我们提供了要处理的可选函数和要执行的函数。在下面的代码中，a将保存我们的供应商返回的值，b将保存我们的函数执行的结果(其中输入参数是可选的10的值)。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/8877c323e7db3b0a6904b2983144c7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*Bk5ZRB3Nmfw9qG6_kyxnfg.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">a will be -1, b will be 20</figcaption></figure><h2 id="57ce" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">可选模式匹配</h2><p id="48e6" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">事实证明，当我们对Optional使用catamorphism时，我们正在做的事情非常类似于函数式语言(以及像Scala这样的双范式语言)中的模式匹配。也就是说，我们正在解构可选实例，并根据其内部状态选择适当的案例/函数来执行。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff mw"><img src="../Images/a6790f7ada944cc793613eb571936439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*bsDAFWjAa9zFJoCePQ3HoA.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Scala pattern matching code for Option</figcaption></figure><p id="18c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Scala模式匹配on选项的代码最终非常类似于我们的visitor/catamorphism Optional代码。</p><h2 id="a36e" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">为什么这样好？</h2><p id="ffb6" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Scala中的模式匹配不仅仅是Java的Switch语句的更强大版本。Scala编译器还能够检测开发人员是否已经覆盖了解构的所有可能情况，如果没有，就会发出警告或出错。</p><p id="f3d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，如果Java开发人员利用了catamorphisms，编译器将迫使他们为可选的(或被检查的类型)所有可能的状态提供实现。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mx"><img src="../Images/9da4ccbf4b5c09cdaed06e4c03ba2faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*0iDaoyXgAgWrKGnN_ys8RA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Javac would help us if we used our visit method!</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff my"><img src="../Images/162707b8662d2d6668c33ad1737121ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C547D5BdRsA6qdzFz-5GgA.jpeg"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Photo by <a class="ae jp" href="http://unsplash.com/photos/PC_lbSSxCZE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kristopher Roller</a> on <a class="ae jp" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a898" class="ln kh hu bd ki lo lp lq km lr ls lt kq lu lv lw kt lx ly lz kw ma mb mc kz md dt translated">吸气剂破坏封装</h1><p id="85c8" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">Scala有case类的概念。Case类是非常简单的类，具有可以非常简洁地定义的不可变字段。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mz"><img src="../Images/f6e25171f3cd9a40f88e040a93233570.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*xda9BBLxDQrhLUfuM4qgdw.png"/></div></div></figure><p id="8fc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在Java中定义一个类似的类，虽然稍微大一点，但也非常清楚编译后的类的实际结构。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff na"><img src="../Images/6614a31d56f2670385dd7f7412ec94ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Iy8HDkn91d6BQOpM_leQXA.png"/></div></figure><p id="7a2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，一旦创建，用法是非常相似的</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/69351e3dd6bae29315e5fbf2f80c6f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*rLJp72XIx_eQvBSf90nPfg.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Scala case class usage</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff na"><img src="../Images/9922d40d67a8a1cb135e23187b95fe6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*ysusw1BG6TFCHcJA_bUZbg.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Java case class usage</figcaption></figure><p id="7f82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了一点之外，由于Book缺少catamorphism Java实现，我们可以在Scala中进行模式匹配，但不能在Java中进行</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/13cb76c4aa073045c8d6181bf158c7c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*LLYx8SR2D0xTYCnERQu7zA.png"/></div></figure><p id="f38b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是这很容易解决</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nd"><img src="../Images/7d4455aca2e4269e2920069d6d6fa515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQ7Mm0wN2rgrwqsR9dBOog.png"/></div></div></figure><p id="c229" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Java中，我们现在有了一个额外的选项，使我们的case类成员成为私有的，并通过catamorphism强制所有的访问。这样做对于一个简单的类(比如我们书中的例子)的好处是很小的，但是正如我们所看到的，对于Optional来说，即使是一点点额外的复杂性也意味着错误会开始渗入我们的代码库。让我们通过引入书籍的两个新子类——小说和非小说来看看这一点。</p><h2 id="296a" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">小说或非小说</h2><p id="9c9c" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们可以重构我们的Book类，做一些改动</p><ol class=""><li id="3cb4" class="ne nf hu it b iu iv iy iz jc ng jg nh jk ni jo nj nk nl nm dt translated">我们使Book成为一个抽象类，因为我们现在有两种具体类型(小说和非小说)</li><li id="b573" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">我们定义了两个子类型(小说和非小说)</li><li id="a2a6" class="ne nf hu it b iu nn iy no jc np jg nq jk nr jo nj nk nl nm dt translated">我们将所有字段都设为私有(以保持使用我们的Book实例的代码简单！)</li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ns"><img src="../Images/d5f8f2a3270e6a1c6812424fb154b95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhbXGMhMp7X7JOBvCBNEMg.png"/></div></div></figure><p id="ac37" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类别有几个值得注意的属性，唯一可以定义的具体书籍类型是小说和非小说。这是由私有构造函数强制执行的。此外，对我们的Book实例的内部状态或结构的所有访问都是通过我们最初的catamorphism来控制的。</p><h2 id="1aae" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">我们如何区别对待小说和非小说</h2><p id="73e0" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">现在我们有两种类型的书，我们可能会尝试通过传统的Java if / then / else语句来处理它们。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nt"><img src="../Images/c5bf4a1fb9b2980e7bef8c209485eb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2pXZAlj7gFZl-DkyLx6LQ.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Even for such a relatively trivial example, if / then / else can cause bugs : note the semicolon! a is alway 1</figcaption></figure><p id="e306" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个更好的方法是定义另一个catamorphism，它覆盖可能的书籍类型。除了我们接受两个单参数函数之外，这个函数的实现看起来很像我们的Optional函数的实现。一个接收虚构的实例，另一个接收非虚构的实例。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nu"><img src="../Images/6272e6be6c28fbafdf7e170264731632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oWsnlcfU71zrX-Aih886g.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">catamorphism over Book type</figcaption></figure><p id="6492" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以将错误的if / then / else语句重写为更加安全的语句</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nv"><img src="../Images/5d922cdc45072be4e845b55387a1987c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IayL3R2tKeAQ5iioJkN6FA.png"/></div></div></figure><h2 id="c656" class="kg kh hu bd ki kj kk kl km kn ko kp kq jc kr ks kt jg ku kv kw jk kx ky kz la dt translated">or(或Xor)型的同态</h2><p id="9620" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">我们刚刚为一本既可以是小说也可以是非小说的书推导出了变形。这可以被概括为可以是两个其他类型之一的类型(例如，类型T1、类型T2)。表示这一点的常见数据结构是两者之一类型。(cyclops-react提供了懒惰的&amp;反应式实现，可以选择多达5个选项，并提供了一个名为Xor——eXclusive or的数据结构的热切版本)。就像当一个字段可以为空时，我们如何使用Optional，而不是一致地重新实现来表示继承层次，我们可以利用现有的数据结构。</p><p id="22b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以重构我们的Book类来使用这两者之一</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nw"><img src="../Images/fd13296ce6573eb8d5226e27e7c2b0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vn65XWns5vLSh3YdFXvY7g.png"/></div></div></figure><p id="61e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于书籍类型的模式匹配，我们可以使用匹配方法</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nx"><img src="../Images/89b1ba378cbbef8a6dd06236358b62e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5lqogSj8QehMpnQF8VttQ.png"/></div></div></figure><h1 id="c4ac" class="ln kh hu bd ki lo lp lq km lr ls lt kq lu lv lw kt lx ly lz kw ma mb mc kz md dt translated">列表的同态</h1><p id="3d4e" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">当列表在函数中实现时，它们通常是按照头和尾来构造的(递归)</p><blockquote class="me"><p id="d554" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">标题:第一个值</p><p id="82a5" class="mf mg hu bd mh mi mj mk ml mm mn jo ek translated">Tail:包含头部和尾部的列表</p></blockquote><p id="6b10" class="pw-post-body-paragraph ir is hu it b iu mo iw ix iy mp ja jb jc mq je jf jg mr ji jj jk ms jm jn jo hn dt translated">列表的变形由一个双参数函数(或双函数)组成，它接受列表的第一个值和尾部(列表的其余部分)。我们可以在cyclops-react中使用扩展列表类型(ListX)轻松实现这一点。ListX可以包装任何标准的j.u.List，并增加了许多有用的功能。即使j . u . list(通常)不是按照头部和尾部实现的，我们也可以抽象地(或虚拟地)这样表示它们，并且我们的简单同态仍然可以应用。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff ny"><img src="../Images/f06a49e1a20dd70b9d8dc7ed71b2e504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_6tr4ip0KYG963Q6g7mWA.png"/></div></div></figure><p id="4b33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用Scala模式匹配，我们可以通过添加头部和递归处理尾部，将一个字符串列表折叠(或缩减)成一个字符串。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff nz"><img src="../Images/1e86f56d23c867d652aac9b820f8539d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6VQHgBEaAKLD4pQq."/></div></div></figure><p id="961e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Java中，我们可以用列表变形做同样的事情</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff oa"><img src="../Images/6f2b6e79ecf19befe3efc0f7d781de8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxzmGQZd8TX_gb-uvaz4WQ.png"/></div></div></figure><h1 id="bd94" class="ln kh hu bd ki lo lp lq km lr ls lt kq lu lv lw kt lx ly lz kw ma mb mc kz md dt translated">实现自己的变形</h1><p id="4311" class="pw-post-body-paragraph ir is hu it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hn dt translated">在本文中，我们展示了为一个核心Java 8类型(可选的)实现catamorphism(或模式匹配)是多么简单。然后通过一个工作实例，我们用Java实现了一个非常简单的Case类，它有自己的变形。我们展示了如何通过实现<em class="lj">或者</em>类型的变形来简化Java中继承层次的工作。最后，我们实现了j.u.List的函数式变形，尽管它没有公开头和尾的简单递归数据结构。</p><p id="e198" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些变形都是用3行或更少的代码实现的，但是它们允许我们在我们为其创建的类型的结构的重要方面进行模式匹配。您也可以在自己的代码库中这样做。</p><p id="2182" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下次你发现自己在纠结一个复杂的if / then/ else序列或case语句时，问问这是否可以以某种方式简化，几乎可以肯定的是，你的对象结构中有一些东西可以指导你创建简单的变形，这将提高你的代码的健壮性。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="ob oc l"/></div></figure></div></div>    
</body>
</html>