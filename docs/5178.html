<html>
<head>
<title>Abstract Classes in TypeScript: Text &amp; Video</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的抽象类:文本和视频</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/abstract-classes-in-typescript-text-video-cda9a4e6a56a?source=collection_archive---------0-----------------------#2017-07-14">https://medium.com/hackernoon/abstract-classes-in-typescript-text-video-cda9a4e6a56a?source=collection_archive---------0-----------------------#2017-07-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="1480" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是摘自我最近免费出版的关于打字本<a class="ae jp" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言、<a class="ae jp" href="https://www.gitbook.com/book/pagalvin/yet-another-typescript-book/details" rel="noopener ugc nofollow" target="_blank"> <em class="jq">又一本打字本</em></a><em class="jq"/>(<a class="ae jp" href="https://www.gitbook.com/book/pagalvin/yet-another-typescript-book/details" rel="noopener ugc nofollow" target="_blank">https://www . git Book . com/Book/pagal vin/Yet-Another-TypeScript-Book/details</a>)的<a class="ae jp" href="https://hackernoon.com/tagged/book" rel="noopener ugc nofollow" target="_blank">书</a>。</p><p id="bc0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它来自第九章“深度课程”在这里:</p><h1 id="c38b" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">抽象类</h1><p id="291b" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">抽象类完善了TypeScript对这种性质的层次结构的支持。抽象类看起来和感觉上像标准类，但有一个关键的例外:抽象类可能永远不会被实例化。如果JavaScript是您的第一和主要编程语言，这可能看起来很奇怪。然而，抽象类和接口使开发人员能够自然而优雅地表达许多常见的软件设计模式。让我们考虑一个例子。</p><p id="08c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象你正在写一个游戏。玩家在二维地图上放置不同类型的军事基地(例如“陆军”、“海军”)。碱基有一些共同的特征，如“名字”，但在重要的细节上彼此不同。陆军基地由士兵组成，而海军基地由船只组成。最后，在运行时，玩家可以“激活”一个基地。这就触发了基地在游戏中做一些有意义的事情。这里有一个简单的建模方法:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="01ec" class="ld js hu kz b fv le lf l lg lh">interface Activatable {<br/>    ActivateSelf: () =&gt; void;<br/>}</span><span id="cbf9" class="ld js hu kz b fv li lf l lg lh">class NaiveBase {<br/>    private _myName: string;<br/>    public get Name() { return this._myName; }<br/>    constructor (name: string) {<br/>        this._myName = name;<br/>    }<br/>}</span><span id="8be7" class="ld js hu kz b fv li lf l lg lh">class NaiveArmyBase extends NaiveBase implements Activatable{<br/>    private _totalSolders: number;<br/>    public get TotalSolders() { return this._totalSolders; }</span><span id="6162" class="ld js hu kz b fv li lf l lg lh">    constructor(name: string, totalSolders: number) {<br/>        super(name);<br/>        this._totalSolders = totalSolders;<br/>    }</span><span id="89c4" class="ld js hu kz b fv li lf l lg lh">    public ActivateSelf() {<br/>        throw "Not yet implemented";<br/>    }<br/>}</span><span id="5bab" class="ld js hu kz b fv li lf l lg lh">class NaiveNavyBase extends NaiveBase implements Activatable {<br/>    private _totalShips: number;<br/>    public get TotalShips() { return this._totalShips; }</span><span id="f794" class="ld js hu kz b fv li lf l lg lh">    constructor(name: string, totalShips: number) {<br/>        super(name);<br/>        this._totalShips = totalShips;<br/>    }</span><span id="ac40" class="ld js hu kz b fv li lf l lg lh">    public ActivateSelf() {<br/>        throw "Not yet implemented";<br/>    }<br/>}</span><span id="efb4" class="ld js hu kz b fv li lf l lg lh">const naiveArmyBase = new NaiveArmyBase("First army base", 100);<br/>const naiveNavyBase = new NaiveNavyBase("First navy base", 3);</span><span id="eafa" class="ld js hu kz b fv li lf l lg lh">// This is allowed but makes no sense:<br/>const someOtherBase = new NaiveBase("what kind of base is this?");</span></pre><p id="d19d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，这已经很简单了。一个<code class="eh lj lk ll kz b">NaiveBase</code>类保存一个私有属性<code class="eh lj lk ll kz b">_myName</code>，并提供一个get访问器来检索该值。另外两个类扩展了它并添加了它们自己的属性:<code class="eh lj lk ll kz b">NaiveArmyBase</code>和<code class="eh lj lk ll kz b">NaiveNavyBase</code>。</p><p id="adfa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">陆军和海军基类都实现了<code class="eh lj lk ll kz b">Activatable</code>接口，尽管在这个例子中，每个类的<code class="eh lj lk ll kz b">ActiveSelf()</code>方法都抛出了一个异常。</p><p id="2991" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种建模方法有一个问题:没有简单朴素的基础。玩家从不创造普通的基地，他们总是创造一种特殊的基地。然而，没有什么可以阻止代码这样做。</p><p id="3706" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里还有另一个问题。这种方法迫使我们在每个类上实现<code class="eh lj lk ll kz b">Activatable</code>接口。我们可以在基类上实现它，但这只会使第一个问题复杂化——现在我们已经在一个不应该实例化的类上实现了一个接口。</p><p id="826b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">抽象类为我们解决了这个问题。下面是使用抽象类重写的代码:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="9053" class="ld js hu kz b fv le lf l lg lh">interface Activatable {<br/>    ActivateSelf: () =&gt; void;<br/>}</span><span id="465c" class="ld js hu kz b fv li lf l lg lh">abstract class AbstractBase implements Activatable{<br/>    private _myName: string;<br/>    public get Name() { return this._myName; }</span><span id="1ba9" class="ld js hu kz b fv li lf l lg lh">    constructor (name: string) {<br/>        this._myName = name;<br/>    }</span><span id="cd17" class="ld js hu kz b fv li lf l lg lh">    abstract ActivateSelf(): void;<br/>}</span><span id="ce22" class="ld js hu kz b fv li lf l lg lh">class ArmyBase extends AbstractBase {<br/>    private _totalSolders: number;<br/>    public get TotalSolders() { return this._totalSolders; }</span><span id="358a" class="ld js hu kz b fv li lf l lg lh">    constructor(name: string, totalSolders: number) {<br/>        super(name);<br/>        this._totalSolders = totalSolders;<br/>    }</span><span id="4648" class="ld js hu kz b fv li lf l lg lh">    public ActivateSelf() {<br/>        throw "Not yet implemented";<br/>    }<br/>}</span><span id="1b0a" class="ld js hu kz b fv li lf l lg lh">class NavyBase extends AbstractBase {<br/>    private _totalShips: number;<br/>    public get TotalShips() { return this._totalShips; }</span><span id="6215" class="ld js hu kz b fv li lf l lg lh">    constructor(name: string, totalShips: number) {<br/>        super(name);<br/>        this._totalShips = totalShips;<br/>    }</span><span id="c628" class="ld js hu kz b fv li lf l lg lh">    public ActivateSelf() {<br/>        throw "Not yet implemented";<br/>    }<br/>}</span><span id="0bfb" class="ld js hu kz b fv li lf l lg lh">const armyBase = new ArmyBase("First army base", 100);<br/>const navyBase = new NavyBase("First navy base", 3);<br/>const anotherArmyBase: Activatable = new ArmyBase("Second army base", 250);</span><span id="baaf" class="ld js hu kz b fv li lf l lg lh">// Compiler throws an error - abstract classes can not be instantiated:<br/>const someOtherKindOfBase = new AbstractBase("what kind of base is this?");</span></pre><p id="a0b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个例子介绍了<code class="eh lj lk ll kz b">abstract</code>关键字。我们现在有一个抽象类，<code class="eh lj lk ll kz b">Base</code>。这个抽象类实现了<code class="eh lj lk ll kz b">Activatable</code>接口。这样做，您可以看到TypeScript抽象功能的另一个特征:您可以将类和<em class="jq">类成员</em>标记为抽象。(事实上，如果该类包含任何抽象成员，则必须将其标记为abstract)。可激活的接口需要一个方法，<code class="eh lj lk ll kz b">ActiveSelf</code>。然而，这种方法只对“真正的”基地——陆军和海军基地有意义。因此，我们将ActivateSelf方法本身标记为抽象的:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="b367" class="ld js hu kz b fv le lf l lg lh">abstract ActivateSelf(): void;</span></pre><p id="afe7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个抽象的ActivateSelf方法满足可激活接口的要求。这是完美的，因为一个普通的“基地”不能有意义地激活自己——只有陆军和海军基地可以做到这一点。同时，它强制子类实现该方法。这有两个好处:</p><ol class=""><li id="22c9" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">你不能忘记这么做，因为IDE和编译器不允许你这么做。</li><li id="2307" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">由于子类实现了接口，我们可以在需要的时候编写代码来利用它们的类型<code class="eh lj lk ll kz b">Activatable</code>。</li></ol><p id="8ced" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">抽象基类展示了另一个特性:抽象类可以定义非抽象类成员。因为每个基类都有一个名字，不管基类是什么类型，定义一个具体的<code class="eh lj lk ll kz b">_myName</code>属性和相关的getter是有意义的。子类继承这些具体的类成员(属性和方法),就像它们继承具体的类一样。</p><p id="f0e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">陆军和海军基地使用相同的<code class="eh lj lk ll kz b">extends</code>关键字扩展抽象类，就像它是一个具体类一样。</p><p id="fe0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总结这个例子，您可以看到新建陆军和海军基地的工作方式与简单例子中的方式相同:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="24b6" class="ld js hu kz b fv le lf l lg lh">const armyBase = new ArmyBase("First army base", 100);<br/>const navyBase = new NavyBase("First navy base", 3);</span></pre><p id="0c2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于两种类型的基都实现了Activatable，因此您可以这样做:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="272c" class="ld js hu kz b fv le lf l lg lh">const anotherArmyBase: Activatable = new ArmyBase("Second army base", 250);<br/>const activatableNavyBase = &lt;Activatable&gt; navyBase;</span></pre><p id="e7fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们把这一切放在一个视频里:</p><figure class="ku kv kw kx fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><figure class="ku kv kw kx fq ma"><div class="bz el l di"><div class="md mc l"/></div></figure></div></div>    
</body>
</html>