<html>
<head>
<title>13 things you need to know about React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于React你需要知道的13件事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/13-things-you-need-to-know-about-react-d2e6a6422552?source=collection_archive---------0-----------------------#2016-12-22">https://medium.com/hackernoon/13-things-you-need-to-know-about-react-d2e6a6422552?source=collection_archive---------0-----------------------#2016-12-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/982583780dae78fd2356c6bb3511056e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A4AvUb6umxuZNDEB.jpg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek"><em class="ih">Image by </em><a class="ae ii" href="https://www.flickr.com/photos/livenature/" rel="noopener ugc nofollow" target="_blank"><em class="ih">Franco Folini</em></a></figcaption></figure><div class=""/><p id="33ab" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我已经使用React一年多了。我也在进行培训，帮助人们从零开始学习。我注意到在每次训练中，我都在一遍又一遍地解释同一套概念。我认为如果你想“说话反应”，这些概念是必不可少的。如果你正在学习它，你可能会有兴趣阅读这篇文章。</p><h1 id="e18d" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">1)它不是一个框架</h1><p id="0a98" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">Angular或Ember是已经为你做了一些决定的框架。React只是一个库，你需要自己做所有的决定。它侧重于帮助您使用组件构建用户界面。</p><p id="5a95" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">它对你的服务器通讯、翻译、路由等没有帮助。一些人认为这是一个弱点。我同意一位智者曾经说过的话:</p><blockquote class="lj lk ll"><p id="c1a6" class="ji jj lm jk b jl jm jn jo jp jq jr js ln ju jv jw lo jy jz ka lp kc kd ke kf hn dt translated"><em class="il">“框架解决了它的创造者的问题”~我的一个导师</em></p></blockquote><p id="9c06" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">React很薄，很容易与其他第三方库混合使用。丰富的JS生态系统，什么都有一个库。你可以选择你最喜欢的一个，然后把它插上，而不用处理框架的设计决策/限制。</p><p id="7d3c" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">当然还有<a class="ae ii" rel="noopener" href="/@ericclemmons/javascript-fatigue-48d4011b6fc4#.ovtpj2ypn">大名鼎鼎的JS疲劳</a>。如果你也有同样的感觉，并且不想自己做每一个决定，做一个30分钟的研究，选择一个<a class="ae ii" href="http://andrewhfarmer.com/starter-project/" rel="noopener ugc nofollow" target="_blank">固执己见的初学者工具包/样板</a>，改变你想要的，然后使用它。</p><h1 id="761a" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">2) JSX</h1><p id="0b88" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在看React例子的时候，你可能已经看到过<a class="ae ii" href="https://facebook.github.io/react/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>在工作。但是React代码也可以用普通的JS编写:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="b42b" class="lz kh il lv b fv ma mb l mc md">const rootElement =<br/> React.createElement(‘div’, {},<br/>   React.createElement(‘h1’, {style: {color: ‘red’}}, <br/>     ‘The world is yours’),<br/>   React.createElement(‘p’, {}, <br/>     ‘Say hello to my little friend’)<br/> )</span><span id="8e8f" class="lz kh il lv b fv me mb l mc md">ReactDOM.render(rootElement, document.getElementById(‘app’))</span></pre><p id="6204" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有些人不喜欢将整个标记代码写成函数调用。这可能就是为什么脸书的人想出了JSX——一个“React.createElement(组件，道具，…子元素)函数的语法糖”。</p><p id="0ce1" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这就是为什么我们可以将上面的例子重构为:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="52c5" class="lz kh il lv b fv ma mb l mc md">const RootElement = (<br/>  &lt;div&gt;<br/>    &lt;h1 style={{color: red}}&gt;The world is yours&lt;/h1&gt;<br/>    &lt;p&gt;Say hello to my little friend&lt;/p&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="f70a" class="lz kh il lv b fv me mb l mc md">ReactDOM.render(RootElement, document.getElementById('app'))</span></pre><p id="78d7" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在构建过程中<a class="ae ii" href="https://babeljs.io/docs/plugins/preset-react/" rel="noopener ugc nofollow" target="_blank"> Babel </a>会将标记转换成普通的JS。</p><h1 id="9b6f" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">3)是JavaScript</h1><p id="e2ef" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">要在React中动态生成标记，还可以使用JS:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="5a08" class="lz kh il lv b fv ma mb l mc md">&lt;select value={this.state.value} onChange={this.handleChange}&gt;<br/>  {somearray.map(element =&gt; &lt;option value={element.value}&gt;<br/>                              {element.text}<br/>                            &lt;/option&gt;)}<br/>&lt;/select&gt;</span></pre><p id="9408" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在上面的例子中，使用<code class="eh mf mg mh lv b">map</code>函数将<code class="eh mf mg mh lv b">somearray</code>数组映射到一列<code class="eh mf mg mh lv b">&lt;option&gt;</code>元素。这里唯一不同于普通HTML的是<code class="eh mf mg mh lv b">&lt;select&gt;</code>元素上的<code class="eh mf mg mh lv b">value</code>，它为您设置了<code class="eh mf mg mh lv b">selected</code>属性。</p><p id="444b" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">但是并不要求使用它:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="f770" class="lz kh il lv b fv ma mb l mc md">&lt;select onChange={this.handleChange}&gt;<br/>  {somearray.map(element =&gt; (<br/>      &lt;option<br/>        value={element.value}<br/>        selected={this.state.value === element.value}<br/>      &gt;<br/>        {element.text}<br/>      &lt;/option&gt;<br/>    ))}<br/>&lt;/select&gt;</span></pre><p id="3071" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">许多流行的框架使用模板语言进行类似上面的操作。每个框架都有自己的框架。所以每次你想使用一个框架的时候，你都需要学习一种新的模板语言，它的特点和缺点。</p><blockquote class="lj lk ll"><p id="2c87" class="ji jj lm jk b jl jm jn jo jp jq jr js ln ju jv jw lo jy jz ka lp kc kd ke kf hn dt translated"><em class="il">上面的代码显示了一个关于缺少</em>键<em class="il">属性的警告。要了解原因和解决方法，请访问</em> <a class="ae ii" href="https://facebook.github.io/react/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank"> <em class="il">本页</em> </a> <em class="il">或阅读您的开发工具中的错误消息；).</em></p></blockquote><p id="6827" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我记得我第一次在Angular 1中使用<code class="eh mf mg mh lv b">&lt;select&gt;</code>控件。有一个特殊的<code class="eh mf mg mh lv b">ngOptions</code>指令会为你生成所有可能的<code class="eh mf mg mh lv b">&lt;options&gt;</code>。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="11d8" class="lz kh il lv b fv ma mb l mc md">&lt;select<br/>  ng-model="selectedItem"<br/>  ng-options="item as item.name for item in items"&gt;<br/>&lt;/select&gt;</span></pre><p id="76a9" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">直到今天我也不知道<code class="eh mf mg mh lv b">item as item.name for item</code>是什么意思。</p><p id="456f" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有比我更聪明的人，他们记住了如何使用各种模板语言。我经常从后端切换到前端开发。有很长一段时间我根本不做前端。如果你不使用它，知识就会消失。这就是为什么死记硬背对我不起作用。我对<code class="eh mf mg mh lv b">map()</code>功能和HTML很熟悉，所以React方式对我很有吸引力。</p><p id="0ac3" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">另一个好处是静态代码分析是免费的。lint JS肯定比定制模板标记更容易。</p><p id="3769" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">对我来说，模板是字符串驱动的开发。没有严肃的林挺。只是HTML中的一些魔术，没有以任何方式检查。JSX给JS添加了更多的东西，使它更加强大。这也是我不同意人们称JSX为模板语言的原因。</p><h1 id="d2d4" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">4)它是陈述性的</h1><p id="754f" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在React中，您使用声明式风格来编写组件。让我们来看看前面的例子<code class="eh mf mg mh lv b">&lt;select&gt;</code>:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="911c" class="lz kh il lv b fv ma mb l mc md">&lt;select value={this.state.value} onChange={this.handleChange}&gt;<br/>  {somearray.map(element =&gt; &lt;option value={element.value}&gt;<br/>                              {element.text}<br/>                            &lt;/option&gt;)}<br/>&lt;/select&gt;</span></pre><p id="2bf2" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在这个<code class="eh mf mg mh lv b">&lt;select&gt;</code>示例中，您没有使用<code class="eh mf mg mh lv b">for</code>循环来手动创建映射集合。你不是在说<em class="lm">应该做什么</em>，而是说<em class="lm">应该是什么样子</em>。</p><h1 id="7f8b" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">5)你将关注点分开</h1><p id="d000" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在React中，你将HTML、JS和CSS作为一个组件放在一起。如果您想在网格上显示一行，您可以创建一个<code class="eh mf mg mh lv b">Row</code>组件，并将HTML、逻辑和行为放在一个文件中。</p><p id="1676" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">多年来，我们将JS、HTML和CSS分成不同的文件。皮特·亨特称之为技术分离。它不应该与关注点分离相混淆。</p><p id="cfce" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果我认为这种“缺乏分离”很奇怪，我经常会受到质疑。但让我感到奇怪的是，人们经常举一些例子来捍卫将HTML和JS分开的策略:</p><p id="65e9" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">“如果你把HTML和JS放在不同的文件中，你可以很容易地替换HTML并保持JS不变”。</p><p id="1d0c" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果你仔细想想，事情并不是这样的。对HTML结构的大多数更改都需要重构JS逻辑。</p><blockquote class="lj lk ll"><p id="5ea5" class="ji jj lm jk b jl jm jn jo jp jq jr js ln ju jv jw lo jy jz ka lp kc kd ke kf hn dt translated"><em class="il">“显示逻辑和标记不可避免地紧密耦合”~皮特·亨特</em></p></blockquote><p id="7d65" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果您将文本输入更改为复选框，您需要重写您的逻辑。不要逃避。</p><h1 id="d4b7" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">6)数据下降</h1><p id="4f3a" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在React中，数据沿着组件树向下。如果你想将数据从父组件传递到子组件，你需要使用<a class="ae ii" href="https://facebook.github.io/react-native/docs/props.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jk im">道具</strong> </a>。从JSX的观点来看，道具是HTML的属性。</p><p id="5d5d" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">父组件:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="57de" class="lz kh il lv b fv ma mb l mc md">&lt;div&gt;<br/>  &lt;Greetings color={red} text='Hello' /&gt;<br/>&lt;/div&gt;</span></pre><p id="c341" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在子组件中，<code class="eh mf mg mh lv b">this.props</code>下有道具。</p><p id="ad4b" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">子组件:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="93ad" class="lz kh il lv b fv ma mb l mc md">const Greetings = React.createClass({<br/>  render () {<br/>    const {color, text} = this.props<br/>    const divStyle = {padding: 10, backgroundColor: 'black'}<br/>    const headingStyle = {color: color}</span><span id="9cea" class="lz kh il lv b fv me mb l mc md">    return (<br/>      &lt;div style={divStyle}&gt;<br/>        &lt;h1 style={headingStyle}&gt;{text}&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><h1 id="c55b" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">7)状态</h1><p id="51bc" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">到目前为止，我们只讨论了静态组件，静态数据沿着组件树向下传递。通常，需要创建一个状态随时间变化的<a class="ae ii" href="https://facebook.github.io/react/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jk im">有状态组件</strong> </a>。</p><p id="67c5" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们考虑一个<code class="eh mf mg mh lv b">&lt;input&gt;</code>,您可以在这里输入文本，文本将显示在下面。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="6fd0" class="lz kh il lv b fv ma mb l mc md">const InputBox = React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      text: ''<br/>    }<br/>  },</span><span id="fddf" class="lz kh il lv b fv me mb l mc md">  changeText (event) {<br/>    this.setState({text: event.target.value})<br/>  },</span><span id="312c" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;input type='text' onChange={this.changeText} <br/>          placeholder='text' value={this.state.text} /&gt;<br/>        &lt;span&gt;{this.state.text}&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="09eb" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">开始时，您设置组件的默认状态。在这种情况下，我们希望有一个空的<code class="eh mf mg mh lv b">text</code>值。为此，您使用组件方法<code class="eh mf mg mh lv b">getInitialState()</code>，该方法必须返回组件的状态对象。</p><p id="d043" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">为了更新状态，一个事件处理器<code class="eh mf mg mh lv b">changeText()</code>被分配给<code class="eh mf mg mh lv b">onChange</code>事件。要更新状态，React期望您使用内置的<code class="eh mf mg mh lv b"><a class="ae ii" href="https://facebook.github.io/react/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank">setState()</a></code>方法。</p><p id="0ee5" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">状态更新将被调度，组件将在更新完成后重新呈现。<code class="eh mf mg mh lv b">setState()</code>需要使用call来通知React挂起的状态更改，以便它可以应用这些更改。没有任何类型的循环来跟踪是否发生了变化。</p><p id="41ab" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">你需要记住<code class="eh mf mg mh lv b">setState()</code>是异步的。结果不会立竿见影。以下示例显示了应用更改后立即访问状态的好方法和坏方法:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="a287" class="lz kh il lv b fv ma mb l mc md">// BAD:<br/>// ...<br/>someFunction (value) {<br/>  this.setState({someValue: value})<br/>  // may not be changed at this point<br/>  console.log('New value: ', this.state.someValue)<br/>}<br/>// ...</span><span id="a01c" class="lz kh il lv b fv me mb l mc md">// GOOD:<br/>// ...<br/>someFunction (value) {<br/>  this.setState({someValue: value}, () =&gt; {<br/>    // do stuff with new state<br/>    console.log('New value: ', this.state.someValue)<br/>  })<br/>}<br/>// ...</span></pre><p id="62e7" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">好吧，但是如果需要将状态更改传播给父组件呢？</p><h1 id="e723" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">8)事件上升</h1><p id="3168" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">假设我们有一个<code class="eh mf mg mh lv b">Parent</code>组件，它需要从前面例子的子组件<code class="eh mf mg mh lv b">InputBox</code>中获取数据。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="2344" class="lz kh il lv b fv ma mb l mc md">const Parent = React.createClass({<br/>  gimmeThatState (textFromInput) {<br/>    console.log(textFromInput)<br/>    // or this.setState({text: textFromInput})<br/>  },</span><span id="1c0f" class="lz kh il lv b fv me mb l mc md">render () {<br/>    &lt;InputBox pushChangesUp={this.gimmeThatState} /&gt;<br/>  }<br/>})</span></pre><p id="aaf4" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><code class="eh mf mg mh lv b">Parent</code>组件向下传递一个函数(作为道具)，这个函数可以被<code class="eh mf mg mh lv b">InputBox</code>用来向上推一些数据。</p><p id="1d46" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">更新后的<code class="eh mf mg mh lv b">InputBox</code>可能是这样的:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="77a8" class="lz kh il lv b fv ma mb l mc md">const InputBox = React.createClass({<br/>  propTypes: {<br/>    pushChangesUp: React.PropTypes.func.isRequired<br/>  },</span><span id="ec97" class="lz kh il lv b fv me mb l mc md">  getInitialState () {<br/>    return {<br/>      text: ''<br/>    }<br/>  },</span><span id="5fba" class="lz kh il lv b fv me mb l mc md">  changeText (event) {<br/>    this.setState({text: event.target.value})<br/>  },</span><span id="695e" class="lz kh il lv b fv me mb l mc md">  pushChangesUp () {<br/>    this.props.pushChangesUp(this.state.text)<br/>  }</span><span id="7182" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;input type='text' onChange={this.changeText} <br/>          placeholder='text' value={this.state.text} /&gt;<br/>        &lt;span&gt;{this.state.text}&lt;/span&gt;<br/>        &lt;button onClick={this.pushChangesUp}&gt;<br/>          Push changes up<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="17ec" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">您首先看到的是组件声明开头的一个<code class="eh mf mg mh lv b">propTypes</code>属性。这是用来验证道具的。对我来说，它的作用类似于面向对象编程中的接口。通过查看<code class="eh mf mg mh lv b">propTypes</code>，我立即知道我需要向组件提供什么来使其工作。</p><p id="21c5" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">接下来，本地<code class="eh mf mg mh lv b">pushChangesUp()</code>事件处理程序被分配给按钮上的<code class="eh mf mg mh lv b">onClick</code>事件。点击时，该函数使用props中的<code class="eh mf mg mh lv b">pushChangesUp()</code>将数据向上推。</p><p id="6e0d" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在，<code class="eh mf mg mh lv b">Parent</code>组件可以以自己的状态保存数据，并将其传递给不同的组件。</p><h1 id="998f" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">9)渲染的工作原理</h1><p id="601d" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">每个<code class="eh mf mg mh lv b">setState()</code>调用通知React状态变化。然后，React调用<code class="eh mf mg mh lv b">render()</code>方法来更新内存中的组件表示(<a class="ae ii" href="http://reactkungfu.com/2015/10/the-difference-between-virtual-dom-and-dom/" rel="noopener ugc nofollow" target="_blank">虚拟DOM </a>)并将其与浏览器中呈现的内容进行比较。如果有变化，React会对DOM进行尽可能小的更新。</p><p id="3857" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">子组件知道它们需要重新渲染，因为它们的道具改变了。</p><p id="3d6f" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我经常把它比作Git中的diff机制。有两个组件树快照，React比较并交换需要交换的内容。</p><p id="2a25" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我在寻找一个聪明的图表来描述渲染流程，但是没有找到。不过你可以在这里了解更多。</p><h1 id="eef3" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">10)构图是关键</h1><p id="99ae" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">拥有状态的父组件通常被称为<strong class="jk im">容器组件</strong>。他们负责状态管理和渲染孩子(这听起来好奇怪)。子组件用于触发从父组件传递下来的事件处理程序(如前面示例中的<code class="eh mf mg mh lv b">InputBox</code>组件)并显示数据。</p><p id="4e21" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">负责显示数据的子组件被称为<strong class="jk im">表示组件</strong>。</p><p id="e6a0" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">容器组件往往负责取数据、API调用(见<code class="eh mf mg mh lv b"><a class="ae ii" href="https://facebook.github.io/react/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentDidMount()</a></code>生命周期方法)等等。您应该将它放在一个地方，以避免在表示组件中出现副作用。除了显示数据之外，这些应该尽可能地简单。</p><p id="5856" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这种关注点和术语的分离是由《T4》的作者丹·阿布拉莫夫推广的。你可以在他的文章中了解更多。</p><p id="1d0f" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">你可以看到这一切都吻合在一起。当每个组件遵循单一责任原则时，它可以与其他组件组合并重用。</p><p id="8ec0" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">最大的挑战是弄清楚如何划分这些责任，以及将国家置于何处。如果你想了解更多关于这个话题的信息，请搜索<a class="ae ii" href="https://facebook.github.io/react/docs/thinking-in-react.html" rel="noopener ugc nofollow" target="_blank">“在反应中思考”</a>文章。</p><h1 id="20b7" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">11)保持小政府</h1><p id="81af" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在我的训练中，经常有一个涉及某种列表过滤的练习。假设你有一个待办事项列表:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="578d" class="lz kh il lv b fv ma mb l mc md">const initialState = [<br/>  {id: 1, text: 'laundry'},<br/>  {id: 2, text: 'shopping'}<br/>  // ...<br/>]</span><span id="4bb8" class="lz kh il lv b fv me mb l mc md">const List = React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      todos: initialState<br/>    }<br/>  },</span><span id="3b1e" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ul&gt;<br/>          {this.state.todos.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="46ea" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在，您想添加一个搜索框。50%的人会选择这种方法的一些变体:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="9d47" class="lz kh il lv b fv ma mb l mc md">const initialState = [<br/>  {id: 1, text: 'laundry'},<br/>  {id: 2, text: 'shopping'}<br/>  // ...<br/>]</span><span id="c71b" class="lz kh il lv b fv me mb l mc md">const List = React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      todos: initialState,<br/>      filteredTodos: null<br/>    }<br/>  },</span><span id="4377" class="lz kh il lv b fv me mb l mc md">  search (searchText) {<br/>    const filteredTodos = this.state.todos.filter(todo =&gt; <br/>      todo.text.indexOf(searchText) &gt; 0)</span><span id="d63a" class="lz kh il lv b fv me mb l mc md">    this.setState({filteredTodos: filteredTodos})<br/>  },</span><span id="d9f3" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    // get todos from state<br/>    const {filteredTodos, todos} = this.state</span><span id="b52d" class="lz kh il lv b fv me mb l mc md">    // if there are filtered todos use them<br/>    const list = filteredTodos === null ? todos : filteredTodos</span><span id="4695" class="lz kh il lv b fv me mb l mc md">    return (<br/>      &lt;div&gt;<br/>        &lt;SearchBox onChange={this.search} /&gt;<br/>        &lt;ul&gt;<br/>          {list.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="6022" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">你在这里看到的是重复的状态，两个真实的来源和意大利面条式代码的介绍。假设您想要更新一个打开了搜索过滤器的待办事项。</p><p id="8bc8" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">什么更好？让州政府尽可能的小。如果某个东西可以被<a class="ae ii" href="https://facebook.github.io/react/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state" rel="noopener ugc nofollow" target="_blank">即时计算</a>那么它就应该是。</p><p id="0751" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里有一个更好的解决方案:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="22a5" class="lz kh il lv b fv ma mb l mc md">const initialState = [<br/>  {id: 1, text: 'laundry'},<br/>  {id: 2, text: 'shopping'}<br/>  // ...<br/>]</span><span id="c76e" class="lz kh il lv b fv me mb l mc md">const List = React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      todos: initialState,<br/>      searchText: null<br/>    }<br/>  },</span><span id="98f6" class="lz kh il lv b fv me mb l mc md">  search (searchText) {<br/>    this.setState({searchText: searchText})<br/>  },</span><span id="35cd" class="lz kh il lv b fv me mb l mc md">  filter (todos) {<br/>    if (!this.state.searchText) {<br/>      return todos<br/>    }</span><span id="542a" class="lz kh il lv b fv me mb l mc md">    return todos.filter(todo =&gt; <br/>      todo.text.indexOf(this.state.searchText) &gt; 0)<br/>  },</span><span id="1a9b" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    const {todos} = this.state</span><span id="58a6" class="lz kh il lv b fv me mb l mc md">    return (<br/>      &lt;div&gt;<br/>        &lt;SearchBox onChange={this.search} /&gt;<br/>        &lt;ul&gt;<br/>          {this.filter(todos).map(todo =&gt; &lt;li key={todo.id}&gt;<br/>                                           {todo.text}<br/>                                         &lt;/li&gt;)}<br/>        &lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="81e4" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里只保留了用于在呈现之前过滤列表的<code class="eh mf mg mh lv b">searchText</code>。更干净的方法，更小的政府，没有重复。</p><h1 id="49c8" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">12)条件渲染</h1><p id="345c" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在前面的示例中，列表是根据一些条件逻辑呈现的。如果满足某些条件，通常需要呈现标记的一部分，如果不满足，则呈现另一部分。在React中，有几种方法可以做到这一点。</p><h2 id="f6ee" class="lz kh il bd ki mi mj mk km ml mm mn kq jt mo mp ku jx mq mr ky kb ms mt lc mu dt translated">三元运算符</h2><p id="37fe" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">在JSX中，可以使用<a class="ae ii" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>来执行条件渲染:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="ac3e" class="lz kh il lv b fv ma mb l mc md">React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      hideTodos: true<br/>    }<br/>  },</span><span id="77b8" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>      {<br/>        hideTodos ? 'Sorry there is no data' : &lt;TodoList /&gt;<br/>      }<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="068f" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">可能的变化:</p><ul class=""><li id="2b73" class="mv mw il jk b jl jm jp jq jt mx jx my kb mz kf na nb nc nd dt translated"><code class="eh mf mg mh lv b">return</code>表达式外的三元运算符</li><li id="6dff" class="mv mw il jk b jl ne jp nf jt ng jx nh kb ni kf na nb nc nd dt translated">if/else块在<code class="eh mf mg mh lv b">return</code>表达式之外</li></ul><h2 id="1a55" class="lz kh il bd ki mi mj mk km ml mm mn kq jt mo mp ku jx mq mr ky kb ms mt lc mu dt translated">助手功能</h2><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="f9ec" class="lz kh il lv b fv ma mb l mc md">React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      hideTodos: true<br/>    }<br/>  },</span><span id="fadb" class="lz kh il lv b fv me mb l mc md">  renderTodos () {<br/>    if (this.state.hideTodos) {<br/>      return 'Sorry there is no data'<br/>    }</span><span id="e43e" class="lz kh il lv b fv me mb l mc md">    return &lt;TodoList /&gt;<br/>  }</span><span id="3e4c" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>      {<br/>        this.renderTodos()<br/>      }<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span></pre><p id="1e92" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这是一个有用的方法，但是当组件更大时，你需要在助手和一个<code class="eh mf mg mh lv b">render()</code>方法之间来回切换。</p><h2 id="f3f0" class="lz kh il bd ki mi mj mk km ml mm mn kq jt mo mp ku jx mq mr ky kb ms mt lc mu dt translated">一个组件</h2><p id="6667" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">这可能是最干净的方法，作为<a class="ae ii" href="http://martinfowler.com/bliki/FeatureToggle.html" rel="noopener ugc nofollow" target="_blank">功能切换</a>效果很好。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="e1df" class="lz kh il lv b fv ma mb l mc md">React.createClass({<br/>  getInitialState () {<br/>    return {<br/>      hideTodos: true<br/>    }<br/>  },</span><span id="2dec" class="lz kh il lv b fv me mb l mc md">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;HideIf condition={this.state.hideTodos}&gt;<br/>          &lt;TodoList /&gt;<br/>        &lt;/HideIf&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>})</span><span id="c28a" class="lz kh il lv b fv me mb l mc md">const HideIf = React.createClass({<br/>  render () {<br/>    if (this.props.condition) {<br/>      return &lt;span&gt;'Sorry there is no data'&lt;/span&gt;<br/>    }</span><span id="0d3b" class="lz kh il lv b fv me mb l mc md">    // children is what's inside &lt;HideIf&gt; element<br/>    return this.props.children <br/>  }<br/>})</span></pre><h1 id="f9c0" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">13)你不需要助焊剂</h1><p id="5a80" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">React新手最常见的误解可能是，您需要将它与Redux或其他Flux实现一起使用。</p><p id="ac2b" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Redux很棒。这是最受欢迎的Flux实现，这要归功于<a class="ae ii" href="https://egghead.io/courses/getting-started-with-redux" rel="noopener ugc nofollow" target="_blank">优秀的教程</a>，大量的特性和干净、实用、可测试的方法。但是你可能不需要它。</p><p id="4f9d" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果您正在学习React，如果您的应用程序很小，如果您不需要全局状态或者您在跟踪应用程序中的状态变化方面没有任何问题— <em class="lm">不要使用它</em>。</p><p id="bdec" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果你想了解更多，请阅读这里的<a class="ae ii" href="http://redux.js.org/docs/faq/General.html#general-when-to-use" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="543e" class="kg kh il bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">总结</h1><p id="2df5" class="pw-post-body-paragraph ji jj il jk b jl le jn jo jp lf jr js jt lg jv jw jx lh jz ka kb li kd ke kf hn dt translated">所以，这是我和人们讨论最多的反应概念列表。我强烈推荐阅读<a class="ae ii" href="https://facebook.github.io/react/docs/hello-world.html" rel="noopener ugc nofollow" target="_blank"> React docs </a>，因为如果你从头到尾阅读，这是最好的知识来源。我还推荐观看早期的React视频(从2013年到2014年)<a class="ae ii" href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" rel="noopener ugc nofollow" target="_blank">，描述脸书在创建React </a>时试图解决什么问题。这将有助于你认识到你是否有类似的问题<em class="lm">并做出反应，这将有助于你</em>或者你应该坚持使用其他技术。</p></div><div class="ab cl nj nk hc nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hn ho hp hq hr"><p id="28d2" class="pw-post-body-paragraph ji jj il jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">【aimforsimplicity.com】原载于<a class="ae ii" href="http://aimforsimplicity.com/post/13-things-you-need-to-know-about-react/" rel="noopener ugc nofollow" target="_blank"><em class="lm"/></a><em class="lm">。</em></p><div class="lq lr ls lt fq ab cb"><figure class="nq hw nr ns nt nu nv paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nq hw nr ns nt nu nv paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nq hw nr ns nt nu nv paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="lj lk ll"><p id="f922" class="ji jj lm jk b jl jm jn jo jp jq jr js ln ju jv jw lo jy jz ka lp kc kd ke kf hn dt translated"><a class="ae ii" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ii" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ii" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae ii" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ji jj lm jk b jl jm jn jo jp jq jr js ln ju jv jw lo jy jz ka lp kc kd ke kf hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ii" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ii" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="lq lr ls lt fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nw"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>