<html>
<head>
<title>Using the Redux Store Like a Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像使用数据库一样使用Redux存储</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/shape-your-redux-store-like-your-database-98faa4754fd5?source=collection_archive---------2-----------------------#2017-07-27">https://medium.com/hackernoon/shape-your-redux-store-like-your-database-98faa4754fd5?source=collection_archive---------2-----------------------#2017-07-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="268f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">Translations: <a class="ae jp" href="http://it.uu01.me/p/ovdfze.html" rel="noopener ugc nofollow" target="_blank">中文</a></p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/0a9300bf8810c741479c0fe54e876f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*b-Rc3m2h_oQjbplfvp9s6w.gif"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Your store data can be viewed from many angles by using indexes.</figcaption></figure><p id="dbd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最近我浏览了一些关于RC聊天系统的Javascript讨论，我注意到了Kate Ray提出的一个很好的问题:</p><blockquote class="kc kd ke"><p id="0a95" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated">我们应该如何组织redux存储中的数据？</p></blockquote><p id="bf3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是使用redux时的一个常见问题，当然也是我问过自己很多次的问题。我发现答案通常取决于我打算如何处理我的数据。</p><p id="8ddf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多事情需要考虑:我是否会像一个行列表一样频繁地迭代存储数据？我需要快速O(1)访问单个项目吗？</p><p id="68de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我在实践中见过很多方法，通常在访问时间和迭代的容易程度之间有一些折衷。</p><h1 id="6521" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">常见方法</h1><p id="2c0c" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">如果你存储一些数据，其中每一项都有一个id，你可以把你的存储设计成一个<code class="eh lm ln lo lp b">Object</code>或者一个<code class="eh lm ln lo lp b">Objects</code>的<code class="eh lm ln lo lp b">Array</code>。</p><p id="9335" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">扁平物体阵列</strong> <code class="eh lm ln lo lp b"><strong class="it hv">[{values}]</strong></code> <strong class="it hv"> : <br/> </strong>这是我见过的最常见的一种。这使得迭代变得容易，你可以按照特定的顺序存储数据，但是如果不进行迭代和过滤，你就不能通过<code class="eh lm ln lo lp b">id</code>或<code class="eh lm ln lo lp b">name</code>来访问特定的条目。</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="b695" class="lu kk hu lp b fv lv lw l lx ly">categories: [<br/>  {name: 'abs',  id: '32o8wafe', exercises: ['crunches', 'plank']},<br/>  {name: 'arms', id: 'oaiwefjo', exercises: [...]},<br/>  {name: 'legs', id: 'aoijwfeo', exercises: [...]},<br/>]</span></pre><p id="9fa8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">id为</strong> <code class="eh lm ln lo lp b"><strong class="it hv">{id: {values}}</strong></code> <strong class="it hv">的对象:<br/> </strong>这给了你快速O(1)访问每个条目的方法，但是当你使用<code class="eh lm ln lo lp b">Object.values()</code>进行迭代时，你不容易访问给定条目的<code class="eh lm ln lo lp b">id</code>。</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="c9dc" class="lu kk hu lp b fv lv lw l lx ly">categories: {<br/>  '32o8wafe': {name: 'abs',  exercises: ['crunches', 'plank']},<br/>  'oaiwefjo': {name: 'arms', exercises: [...]},<br/>  '3oij2e3c': {name: 'legs', exercises: [...]},<br/>}</span><span id="4dad" class="lu kk hu lp b fv lz lw l lx ly">Object.values(categories).map(row =&gt; // cant access id here)<br/>// it's possible to use Object.entries, but you still cant do row.id</span></pre><blockquote class="kc kd ke"><p id="ba9d" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated"><strong class="it hv">引人深思:</strong> <br/> <code class="eh lm ln lo lp b">Array</code> s和<code class="eh lm ln lo lp b">Object</code> s是JS 里的<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Description" rel="noopener ugc nofollow" target="_blank">同一个东西。<br/> (V8使用不同的内部表示来存储它们)</a></p></blockquote><h1 id="0eb3" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">将它构建成一个由<code class="eh lm ln lo lp b">id</code>索引的行组成的数据库</h1><p id="585e" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">在我们在<a class="ae jp" href="https://monadical.com" rel="noopener ugc nofollow" target="_blank"> Monadical </a>实现一个大型redux应用的过程中，我们偶然发现了一种不同的方法，这种方法使我们既可以轻松地与<code class="eh lm ln lo lp b">Object.values(state.categories)</code>进行迭代，又可以快速O(1)访问单个项目:</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="3db3" class="lu kk hu lp b fv lv lw l lx ly">categories: {<br/>  '32o8wafe': {id: '32o8wafe', name: 'abs',  exercises: [...]},<br/>  'oaiwefjo': {id: 'oaiwefjo', name: 'arms', exercises: [...]},<br/>  '3oij2e3c': {id: '3oij2e3c', name: 'legs', exercises: [...]},<br/>}</span></pre><p id="8b9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意<code class="eh lm ln lo lp b">id</code>既是行的键，也是行本身的属性。这一点点重复在访问时为我们提供了极大的灵活性。它还兼容redux docs推荐的<a class="ae jp" href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" rel="noopener ugc nofollow" target="_blank">标准化</a> ( <em class="kf">又名</em>扁平)形状。</p><p id="d619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在您可以遍历数据，并在迭代时访问<code class="eh lm ln lo lp b">id</code>!</p><p id="bda2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lm ln lo lp b">Object.values(categories).map(cat =&gt; ({id: cat.id, name: cat.name}))</code></p><p id="1e13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者通过<code class="eh lm ln lo lp b">id</code>即时访问任何单个项目！</p><p id="daf4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lm ln lo lp b">categories[‘32o8wafe’].name // 'abs'</code></p><p id="50ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们向前端发送的数据已经是这样的了，所以前端不需要做任何处理来产生<code class="eh lm ln lo lp b">id: values</code>的映射。这很容易从后端实现，因为您可能会从数据库中提取数据，而数据库中已经有一个可以用作键的<code class="eh lm ln lo lp b">id</code>字段。</p><h1 id="1370" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">索引的力量</h1><p id="d6c6" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">我们上面介绍的新形状是一个微不足道的变化，团队在设计redux商店时可能不会花太多时间仔细考虑。当我们使用除了<code class="eh lm ln lo lp b">id</code>之外的不同键访问存储数据时，真正的魔力就来了。</p><p id="eeea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们上面介绍的形状只是一个行列表，用一个键唯一地标识每一行。有了这样的商店，您可以生成索引，让您使用任何其他键进行<code class="eh lm ln lo lp b">O(1)</code>访问:</p><p id="55a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">按名称索引类别:</strong></p><p id="f5a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了创建索引，我们编写了一个函数，它获取商店数据，并返回一个映射<code class="eh lm ln lo lp b">name</code>-&gt;-T10】。</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="a26c" class="lu kk hu lp b fv lv lw l lx ly">const index_by_name = (categories) =&gt;<br/>    Object.values(categories)<br/>          .reduce((obj, row) =&gt; (obj[row.name] = row.id, obj), {})</span><span id="1244" class="lu kk hu lp b fv lz lw l lx ly">// {abs: '32o8wafe', arms: 'oaiwefjo', legs: '3oij2e3c'}</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ma"><img src="../Images/2e706a64faeb206ca1b55e47647b989b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3bELbeb5YMOFNwIotJ6QQ.png"/></div></div></figure><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="dec4" class="lu kk hu lp b fv lv lw l lx ly">const ids_by_name = index_by_name(categories)</span><span id="0255" class="lu kk hu lp b fv lz lw l lx ly">categories[ids_by_name['abs']] // {id: '32o8wafe', name: 'abs', ...}</span></pre><p id="27b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以为相同的数据构建任意多的索引，这就为您提供了基于任意列的O(1)访问，就像在数据库中一样。</p><p id="c38b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你的数据没有变化，你的索引只需要计算一次，否则应该用记忆函数重新计算。</p><blockquote class="kc kd ke"><p id="5887" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated"><strong class="it hv">思考的问题:</strong> <br/>如何为非惟一的键建立索引？</p></blockquote><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/c0b975b75c76e414aaa577262306629c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*z-jt1KCPbEFCaPBDOpSBrQ.gif"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Trippy photo break. Rest your eyes for a second, then read on :)</figcaption></figure><h1 id="3097" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">分类数据</h1><p id="53f5" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">如果您的<code class="eh lm ln lo lp b">categories</code>有一个固有的顺序(比如在一个数组中)，并且您需要能够在迭代您的数据时将它们按顺序排列，那该怎么办？</p><p id="2ad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可能会想这样做:</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="3b1d" class="lu kk hu lp b fv lv lw l lx ly">const category_order = ['32o8wafe', 'oaiwefjo', '3oij2e3c']<br/>category_order.map(id =&gt; categories[id])</span></pre><p id="0e79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个很好的方法，但是，它需要将一个数组与我们的数据分开来存储顺序，这是次优的。让我们用索引正确地做这件事。</p><p id="16b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们用一个指定每行位置的<code class="eh lm ln lo lp b">order</code>(或<code class="eh lm ln lo lp b">idx</code>)键从后端发送数据，然后我们<strong class="it hv">为</strong> <code class="eh lm ln lo lp b"><strong class="it hv">order</strong></code> <strong class="it hv">创建一个索引，就像我们为任何其他键</strong>创建索引一样:</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="bf69" class="lu kk hu lp b fv lv lw l lx ly">const ids_by_order =<br/>      Object.values(categories)<br/>            .reduce((ordered_ids, category) =&gt; {<br/>                        ordered_ids[category.order] = category.id<br/>                        return ordered_ids<br/>                    }, [])</span><span id="1057" class="lu kk hu lp b fv lz lw l lx ly">// ['32o8wafe', 'oaiwefjo', '3oij2e3c']</span></pre><p id="74c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意这个归约操作是如何产生一个索引<code class="eh lm ln lo lp b">Array</code>而不是一个<code class="eh lm ln lo lp b">Object</code>。在JS中，数组实际上只是一个带有键0、1、2…的对象，所以现在我们有O(1)个通过<code class="eh lm ln lo lp b">order</code>访问特定<code class="eh lm ln lo lp b">id</code>的方法，并且我们可以在有序列表中使用<code class="eh lm ln lo lp b">map</code>、<code class="eh lm ln lo lp b">filter</code>和<code class="eh lm ln lo lp b">reduce</code>进行迭代:</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="369f" class="lu kk hu lp b fv lv lw l lx ly">const second_category = categories[ids_by_order[1]]<br/>// {id: 'oaiwefjo', name: 'arms', order: '1'}</span><span id="da3f" class="lu kk hu lp b fv lz lw l lx ly">const ordered_names = ids_by_order.map(id =&gt; categories[id].name)<br/>// ['abs', 'arms', 'legs']</span></pre><blockquote class="kc kd ke"><p id="4663" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated"><strong class="it hv">思考:</strong> <br/>为什么即使您的订单号<a class="ae jp" href="http://www.htmlgoodies.com/beyond/javascript/dont-fear-sparse-arrays-in-javascript.html" rel="noopener ugc nofollow" target="_blank">有缺口</a>也能工作？例如0，2，41，399</p></blockquote><h1 id="5f23" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">记忆化</h1><p id="47a6" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">如果您的数据从不改变，您可以在启动时调用一次<code class="eh lm ln lo lp b">ids_by_key</code>,并在此后每次使用产生的索引作为静态对象。但是，如果您正在处理经常被访问的变化数据，内存化对于避免每次访问都重新计算索引(即O(n))是非常重要的。</p><p id="9209" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记忆索引选择器可以通过<a class="ae jp" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>来完成，或者通过编写一个<a class="ae jp" href="https://www.sitepoint.com/implementing-memoization-in-javascript/" rel="noopener ugc nofollow" target="_blank">自定义记忆器函数</a>(根据您的数据，这并不太难)。</p><p id="3ffa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">内存化索引意味着您可以在每次读取时调用index函数，而不是必须将索引存储在redux中。</p><p id="4297" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我上面描述的带索引的平面数据模式也符合库<a class="ae jp" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> Normalizr </a>使用的模式。如果您对存储数据感兴趣(按类型分隔)，并且喜欢本文中介绍的索引概念，那么不妨读一下Normalizr上的<a class="ae jp" href="https://tonyhb.gitbooks.io/redux-without-profanity/content/normalizer.html" rel="noopener ugc nofollow" target="_blank">Redux with promise docs</a>。</p><p id="f146" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为记忆化的替代方法，您可以在添加或删除键时改变现有的索引。您最终使用什么样的设计取决于您的数据访问模式。</p><blockquote class="kc kd ke"><p id="09ce" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated"><strong class="it hv">引人深思:</strong> <br/> Memoizing在不可变. js对象上使用的<code class="eh lm ln lo lp b">.hash()</code>是<a class="ae jp" href="https://egghead.io/lessons/javascript-lightning-fast-immutable-js-equality-checks-with-hash-codes" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">快速</strong> </a>。</p></blockquote><h1 id="2a61" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">高阶指数函数</h1><p id="f51d" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated"><strong class="it hv">所有的索引都是我们的数据的纯结果，</strong>所以我们也可以创建很酷的高阶索引函数(<em class="kf">又名</em>返回函数的函数)，例如:</p><pre class="jr js jt ju fq lq lp lr ls aw lt dt"><span id="a6fe" class="lu kk hu lp b fv lv lw l lx ly">const ids<!-- -->_by_key<!-- --> = (key) =&gt; (data) =&gt;  // make index(data) for key<br/>      Object.values(data)<br/>            .reduce((index, row) =&gt; {<br/>                        index[row[key]] = row.id<br/>                        return index<br/>                    }, {})</span><span id="97ae" class="lu kk hu lp b fv lz lw l lx ly">const ids_by_name = ids_by_key('name')  // returns an index function<br/>const abs_id = ids_by_name(categories)['abs']<br/>// '32o8wafe'</span></pre><blockquote class="kc kd ke"><p id="3d45" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated"><strong class="it hv">思考的食粮:</strong> <br/>编写一个索引生成器函数，使索引基于两个键的元组:<code class="eh lm ln lo lp b">`${row[key1]}-${row[key2]}` -&gt; id</code></p></blockquote><h1 id="22c1" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">这些有什么关系呢？</h1><blockquote class="kc kd ke"><p id="5114" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated">React和Flux/Redux解决了[…]渲染和状态管理。现在有可能构建真正高级的web应用程序，专注于实际领域，而不是挣扎于底层实现。</p><p id="5554" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated">然而，问题是系统在不断增长。我们正在构建更多的用户界面，加载和转换更多的数据…</p></blockquote><p id="fc96" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">— Roman Liutikov: <a class="ae jp" rel="noopener" href="/@roman01la/on-web-apps-and-databases-c026f77b93f4">关于网络应用和数据库</a></p><p id="91b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着前端开始接近后端的复杂性，我们最终会手动重新实现已经在后端存在了几十年的东西:数据库、消息队列和其他典型的仅服务器基础设施。许多被认为是现代的前端模式——比如函数式反应式编程——从Windows 3.1 开始就已经存在了。</p><p id="972d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们已经从90年代的SQL数据库中学到的状态管理经验可以应用到我们的前端，帮助我们保持数据的清晰、优雅和一致性。使用索引来避免重复和跳转到一个集中的、一致的数据集的特定部分就是这样一个例子，我相信还有更多这样的例子我还没有发现。</p><h1 id="5e2d" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">进一步阅读</h1><p id="7b47" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">如果你想在浏览器中获得更多类似数据库的特性，请查看:<a class="ae jp" href="https://github.com/tommikaikkonen/redux-orm" rel="noopener ugc nofollow" target="_blank"> redux-orm </a>、<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Glossary/IndexedDB" rel="noopener ugc nofollow" target="_blank">indexed db</a>(Web SQL的替代品)和<a class="ae jp" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>。但是请记住，不要开始安装库，直到您确切知道为什么需要它们。</p><ul class=""><li id="21d5" class="mf mg hu it b iu iv iy iz jc mh jg mi jk mj jo mk ml mm mn dt translated"><a class="ae jp" href="http://redux.js.org/docs/basics/Reducers.html#designing-the-state-shape" rel="noopener ugc nofollow" target="_blank">http://redux . js . org/docs/basics/reducers . html # design-the-state-shape</a></li><li id="2895" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" rel="noopener ugc nofollow" target="_blank">http://redux . js . org/docs/recipes/reducers/normalizingstateshape . html</a></li><li id="0c1d" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="https://egghead.io/lessons/javascript-redux-normalizing-the-state-shape" rel="noopener ugc nofollow" target="_blank">https://egghead . io/lessons/JavaScript-redux-normalizing-the-state-shape</a></li><li id="7aa6" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="https://stackoverflow.com/questions/33940015/how-to-choose-the-redux-state-shape-for-an-app-with-list-detail-views-and-pagina" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/33940015/how-to-choose-the-redux-state-shape for-a-app-with-list-detail-views-and-pagina</a></li><li id="d031" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="https://stackoverflow.com/questions/34995822/how-to-get-best-practice-react-redux-nested-array-data?noredirect=1&amp;lq=1" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/34995822/how-to-get-best-practice-react-redux-nested-array-data</a></li><li id="3cc2" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="https://codeburst.io/how-to-store-your-state-data-f17ceca37aa" rel="noopener" target="_blank">https://code burst . io/how-to-store-your-state-data-f17 ceca 37 aa</a></li><li id="a6ce" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="https://tonyhb.gitbooks.io/redux-without-profanity/content/normalizer.html" rel="noopener ugc nofollow" target="_blank">https://tonyhb . git books . io/redux-without-profanity/content/normalizer . html</a></li><li id="d4f1" class="mf mg hu it b iu mo iy mp jc mq jg mr jk ms jo mk ml mm mn dt translated"><a class="ae jp" href="https://github.com/tommikaikkonen/redux-orm" rel="noopener ugc nofollow" target="_blank">https://github.com/tommikaikkonen/redux-orm</a></li></ul><p id="b956" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt">—</p><blockquote class="kc kd ke"><p id="5ec7" class="ir is kf it b iu iv iw ix iy iz ja jb kg jd je jf kh jh ji jj ki jl jm jn jo hn dt translated"><strong class="it hv">TL；</strong> <br/>博士——以规范化形式<code class="eh lm ln lo lp b">{id: {id, attr1, attr2, attr3}}</code> <br/>存储您的冗余数据——创建<code class="eh lm ln lo lp b">{attr: id}</code>索引，以便其他关键字(如<code class="eh lm ln lo lp b">ids_by_name</code> <br/>)快速进行O(1)次访问——使用<code class="eh lm ln lo lp b">Array</code>索引<code class="eh lm ln lo lp b"><em class="hu">ids_by_order.map(id =&gt; data[id])</em></code> <em class="hu"> <br/> - </em>迭代排序后的数据——使用纯索引函数，如果您的数据频繁更改，请记住它们</p></blockquote><h1 id="bdb8" class="kj kk hu bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt">—</h1><p id="9b0c" class="pw-post-body-paragraph ir is hu it b iu lh iw ix iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo hn dt translated">希望你觉得这有用！如果有，给这篇文章一个💚，或者在twitter上ping我<a class="ae jp" href="https://twitter.com/theSquashSH" rel="noopener ugc nofollow" target="_blank"> @theSquashSH </a>。</p><p id="1f61" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你对涉及以太坊的很酷的Django + React/Redux项目感兴趣，<a class="ae jp" href="https://monadical.com" rel="noopener ugc nofollow" target="_blank"> Monadical正在招聘</a>远程&amp;本地开发人员(第一个月我们会带你去阳光明媚的麦德林)！</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff mt"><img src="../Images/1a04cde1bda1dd1c8ac4655c33c1ac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRMpX-1G6q12KDu23mGcvQ.png"/></div></div></figure></div></div>    
</body>
</html>