<html>
<head>
<title>express-fp: an Express wrapper for type safe request handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">express-fp:类型安全请求处理程序的快速包装器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/express-fp-an-express-wrapper-for-type-safe-request-handlers-f8c411cc4a7b?source=collection_archive---------12-----------------------#2017-11-12">https://medium.com/hackernoon/express-fp-an-express-wrapper-for-type-safe-request-handlers-f8c411cc4a7b?source=collection_archive---------12-----------------------#2017-11-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0a08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您是一名<a class="ae jp" href="https://hackernoon.com/tagged/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>用户，希望在您的节点web服务器中充分利用类型系统，我一直在做一些您可能感兴趣的事情:<a class="ae jp" href="https://github.com/OliverJAsh/express-fp" rel="noopener ugc nofollow" target="_blank"> express-fp </a>，这是一个<a class="ae jp" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a> web服务器库的包装器，在我们的请求处理器函数中提供更多的类型安全性。通过确保请求和响应的类型安全，我们可以避免许多常见的错误。</p><p id="8539" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然我在个人项目中积极地使用它，但这在很大程度上仍然是WIP。虽然没有真正的文档，但是如果您想尝试一下，静态类型和示例应该足以让您了解要点并开始学习。</p><p id="de10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当前的API非常类似于<a class="ae jp" href="https://www.playframework.com/" rel="noopener ugc nofollow" target="_blank"> Play框架</a>(特别是Scala Play)，因为Play是类型安全web服务器的一个很好的例子，也是我目前所熟悉的唯一一个类型良好的web服务器。</p><p id="d31f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说完这些，让我们来看看express-fp试图改进的一些事情。</p><h1 id="3f70" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">不要改变响应，而是将响应作为数据返回</h1><p id="6082" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Express中，通过改变响应对象来构造响应，并在完成后调用<code class="eh kt ku kv kw b">res.send</code>。如果您忘记调用<code class="eh kt ku kv kw b">res.send</code>，您的请求将被挂起，直到超时。</p><p id="c8ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在express-fp中，响应必须作为对象返回(使用<a class="ae jp" href="https://github.com/OliverJAsh/express-result-types" rel="noopener ugc nofollow" target="_blank"> express-result-types </a>)。如果你忘记返回，或者返回了错误的类型，类型系统就会抱怨。</p><h1 id="fd58" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">代替中间件和变体，构建纯粹的功能</h1><p id="8dd7" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Express中，请求通过一系列用户定义的“中间件”来处理，这些中间件通常会改变请求和响应对象。错误的一个常见来源是中间件出现的顺序错误。例如，B假设首先调用A，并且响应已经设置了响应头。然而，我们可以很容易地打破这种排序，我们将不会从类型系统得到关于这一点的警告。</p><p id="e5da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">中间件的常见用例包括:</p><ul class=""><li id="0c26" class="kx ky hu it b iu iv iy iz jc kz jg la jk lb jo lc ld le lf dt translated">解析请求体和查询</li><li id="7740" class="kx ky hu it b iu lg iy lh jc li jg lj jk lk jo lc ld le lf dt translated">异常处理</li></ul><p id="a6a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在express-fp中，中间件被功能组合所取代。请求不会通过多个处理程序，也没有<code class="eh kt ku kv kw b">next</code>功能。</p><p id="5195" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过组合纯函数，类型系统完全知道所有的输入和输出，保证正确的顺序。</p><p id="ff56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据需要，解析可以在请求处理程序中处理。</p><p id="34ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">多亏了纯函数，我们不需要异常处理程序。在需要错误的地方，我们可以使用<code class="eh kt ku kv kw b">Either</code>将它们作为值返回。</p><h1 id="52df" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">类型安全传入值的验证(请求正文，查询)</h1><p id="5fdb" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">在Express中，请求体和查询可以是任何东西。我们可以很容易地断言类型，例如<code class="eh kt ku kv kw b">req.body as MyBody</code>，但这无助于在运行时验证类型——<code class="eh kt ku kv kw b">req.body</code>在运行时可以是任何东西。</p><p id="2d30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">express-fp使用奇妙的<a class="ae jp" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>来验证从外部进入应用程序的值。如果你以前使用过<a class="ae jp" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank"> Joi </a>，那么<a class="ae jp" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>是类似的，除了它可以使用TypeScript。一旦一个值被验证，<a class="ae jp" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>将自动用它的静态类型注释这个值。</p><p id="3aed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在express-fp中，我们只能通过定义用于验证的“运行时类型”来访问请求体。作为回报，我们得到一个<code class="eh kt ku kv kw b">Either</code>类型— <em class="ll">包含验证错误的</em>或被验证的主体。如果主体有效，<a class="ae jp" href="https://github.com/gcanti/io-ts#typescript-integration" rel="noopener ugc nofollow" target="_blank">类型系统将已经知道主体的形状</a>，而不必在单独的类型接口中重复它。</p><p id="a17a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在express-fp中，请求查询被公开为<code class="eh kt ku kv kw b">Map&lt;string, string | string[]&gt;</code>，它与定义良好的URL查询参数相匹配。由您来提取和验证查询参数。</p><h1 id="97d5" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="ad5c" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">要查看所有这些功能的组合，请查看<a class="ae jp" href="https://github.com/OliverJAsh/express-fp/blob/e6c13ddc4a2c337f319e1409f941b4a53e228dc9/src/example.ts#L23" rel="noopener ugc nofollow" target="_blank">示例</a>。你可以在<a class="ae jp" href="https://github.com/OliverJAsh/express-fp" rel="noopener ugc nofollow" target="_blank"> OliverJAsh/express-fp </a>的<a class="ae jp" href="https://hackernoon.com/tagged/github" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到资源库。</p><p id="0702" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我写这篇博客的主要动机是想得到一些反馈，所以如果你动心了，请试一试，并让我知道你的想法。如果你有任何想法，请在评论中联系我，<a class="ae jp" href="https://twitter.com/OliverJAsh" rel="noopener ugc nofollow" target="_blank">在Twitter上</a>，或者通过<a class="ae jp" href="https://github.com/OliverJAsh/express-fp/issues" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>。沿着这条路走下去，我希望写一篇更深入的文章，用内联的例子。</p><figure class="lm ln lo lp fq lq"><div class="bz el l di"><div class="lr ls l"/></div></figure></div></div>    
</body>
</html>