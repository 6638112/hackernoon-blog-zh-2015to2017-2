<html>
<head>
<title>Using Yarn with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带Docker的纱线</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-yarn-with-docker-c116ad289d56?source=collection_archive---------0-----------------------#2016-10-13">https://medium.com/hackernoon/using-yarn-with-docker-c116ad289d56?source=collection_archive---------0-----------------------#2016-10-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="23f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/facebook" rel="noopener ugc nofollow" target="_blank">脸书</a>最近<a class="ae jp" href="https://code.facebook.com/posts/1840075619545360" rel="noopener ugc nofollow" target="_blank">发布了</a> <a class="ae jp" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>，这是一个新的<a class="ae jp" href="https://hackernoon.com/tagged/nodejs" rel="noopener ugc nofollow" target="_blank"> Node.js </a>包管理器，构建在npm注册表之上，大大减少了安装时间，并提供了开箱即用的确定性构建。</p><p id="8ef9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">决定论一直是npm的一个问题，像<code class="eh jq jr js jt b">npm shrinkwrap</code>这样的解决方案<a class="ae jp" href="http://jonnyreeves.co.uk/2016/npm-shrinkwrap-sucks/" rel="noopener ugc nofollow" target="_blank">并不能</a> <a class="ae jp" href="https://github.com/npm/npm/issues/11736" rel="noopener ugc nofollow" target="_blank">很好的</a>。这使得基于<code class="eh jq jr js jt b">npm</code>的系统很难用于多个开发人员和持续集成。另外，<code class="eh jq jr js jt b">npm</code>在复杂的<code class="eh jq jr js jt b">package.json</code>文件中的缓慢会导致长的构建时间，这在使用Docker进行本地开发时是一个严重的障碍。</p><p id="467f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文讨论如何使用Yarn和Docker进行Node.js开发和部署。</p><figure class="jv jw jx jy fq jz fe ff paragraph-image"><div class="fe ff ju"><img src="../Images/02c378238c108e53f74e54ecf270b188.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*dlutGqw-8yKyVFtWmtXVMg.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><a class="ae jp" href="https://xkcd.com/1742/" rel="noopener ugc nofollow" target="_blank">xkcd</a> take on installing code</figcaption></figure><h1 id="27df" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="8fa5" class="le lf hu it b iu lg iy lh jc li jg lj jk lk jo ll lm ln lo dt translated">复制样板文件:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="e06d" class="lt kh hu jt b fv lu lv l lw lx">git clone <a class="ae jp" href="https://github.com/mfornasa/DockerYarn.git" rel="noopener ugc nofollow" target="_blank">https://github.com/mfornasa/DockerYarn.git</a></span></pre><ul class=""><li id="5927" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">输入目录:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="28b6" class="lt kh hu jt b fv lu lv l lw lx">cd DockerYarn</span></pre><ul class=""><li id="78eb" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">构建容器:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="062f" class="lt kh hu jt b fv lu lv l lw lx">./build.sh</span></pre><ul class=""><li id="1023" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">运行它:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="e57d" class="lt kh hu jt b fv lu lv l lw lx">docker run yarn-demo node -e "console.log('Hello, World')"</span></pre><p id="1684" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在你第一次构建容器时，Yarn为你获取<code class="eh jq jr js jt b">npm</code>依赖项。之后，Yarn只在你修改你的<code class="eh jq jr js jt b">package.json</code>的时候执行，它使用之前执行的缓存。在它的上面，你有<strong class="it hv">确定性</strong>:每次在每台机器上安装相同的依赖树。而且<strong class="it hv">它的速度非常快</strong>！</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="1288" class="kg kh hu bd ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz mm lb lc ld dt translated">我们开始吧</h1><p id="3b23" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">该过程适用于Mac和Linux。我们将进入节点6的<a class="ae jp" href="https://hub.docker.com/r/risingstack/alpine/tags/" rel="noopener ugc nofollow" target="_blank">rising stack</a>Node . js Docker图像。继续之前，请在机器上安装纱线。</p><ul class=""><li id="8679" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">在本地文件夹中下载Yarn安装包:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="7296" class="lt kh hu jt b fv lu lv l lw lx">wget <a class="ae jp" href="https://yarnpkg.com/latest.tar.gz" rel="noopener ugc nofollow" target="_blank">https://yarnpkg.com/latest.tar.gz</a></span></pre><ul class=""><li id="aaf5" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">创建新的<code class="eh jq jr js jt b">Dockerfile</code>:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="7f4b" class="lt kh hu jt b fv lu lv l lw lx">FROM risingstack/alpine:3.4-v6.7.0-4.0.0</span><span id="bee9" class="lt kh hu jt b fv mq lv l lw lx">WORKDIR /opt/app</span><span id="a46c" class="lt kh hu jt b fv mq lv l lw lx"># Install yarn from the local .tgz<br/>RUN mkdir -p /opt<br/>ADD latest.tar.gz /opt/<br/>RUN mv /opt/dist /opt/yarn<br/>ENV PATH "$PATH:/opt/yarn/bin"</span><span id="e7c7" class="lt kh hu jt b fv mq lv l lw lx"># Install packages using Yarn<br/>ADD package.json /tmp/package.json<br/>RUN cd /tmp &amp;&amp; yarn<br/>RUN mkdir -p /opt/app &amp;&amp; cd /opt/app &amp;&amp; ln -s /tmp/node_modules</span></pre><p id="e9b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是基于一个<a class="ae jp" href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" rel="noopener ugc nofollow" target="_blank">众所周知的</a>技巧，利用Docker层缓存来避免每次构建容器时重新安装所有模块。这样，Yarn只有在你改变 <code class="eh jq jr js jt b"><strong class="it hv">package.json</strong></code>的时候才执行<strong class="it hv">(当然还有第一次)。</strong></p><ul class=""><li id="c231" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">初始化<code class="eh jq jr js jt b">package.json</code></li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="c1c3" class="lt kh hu jt b fv lu lv l lw lx">yarn init</span></pre><ul class=""><li id="20aa" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">添加您的第一个包:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="6ffc" class="lt kh hu jt b fv lu lv l lw lx">yarn add react</span></pre><ul class=""><li id="5fa4" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">构建并运行您的新容器:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="30a1" class="lt kh hu jt b fv lu lv l lw lx">docker build . -t yarn-demo<br/>docker run yarn-demo node -e "console.log('Hello, World')"</span></pre><p id="fa83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你！你在Docker中使用了<code class="eh jq jr js jt b">yarn</code>。</p><h1 id="2321" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">等等！“<code class="eh jq jr js jt b">yarn.lock”</code>呢？</h1><p id="2bfc" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">Yarn存储每个包和子包的确切版本，以便能够在每次运行时复制完全相同的依赖树。<code class="eh jq jr js jt b">package.json</code>和<code class="eh jq jr js jt b">yarn.lock</code>都必须签入源代码管理。当我们在容器内运行纱线时，我们需要取回<code class="eh jq jr js jt b">yarn.lock</code>。幸运的是，每次运行后提取<code class="eh jq jr js jt b">yarn.lock</code>并不难。只需将<code class="eh jq jr js jt b">Dockerfile</code>中的<code class="eh jq jr js jt b">ADD</code>线更改如下:</p><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="e925" class="lt kh hu jt b fv lu lv l lw lx">ADD package.json yarn.lock /tmp/</span></pre><p id="99b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">并使用以下命令构建容器:</p><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="eccd" class="lt kh hu jt b fv lu lv l lw lx">docker build . -t yarn-demo; docker run --rm --entrypoint cat yarn-demo:latest /tmp/yarn.lock &gt; yarn.lock</span></pre><p id="4c9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建完成后，<code class="eh jq jr js jt b">yarn.lock</code>被复制到您的工作目录，它将在下一次Docker运行时被重用，每次安装相同的依赖项。</p><p id="ce42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你！现在你有了<strong class="it hv">决定性的</strong>纱线执行。</p><h1 id="cf57" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">等等！现在，纱线在每个容器制造中执行</h1><p id="3351" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">这是正确的，我们现在在每个构建中运行纱线，即使<code class="eh jq jr js jt b">package.json</code>没有被修改。这是因为<code class="eh jq jr js jt b">yarn.lock</code>每次都从容器中复制到您的工作目录中，即使它没有被更改，从而使Docker层缓存无效。要解决这个问题，我们需要复制<code class="eh jq jr js jt b">yarn.lock</code>只有当它真的改变了。为此:</p><ul class=""><li id="7ca4" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">创建一个<code class="eh jq jr js jt b">build.sh</code>文件:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="0829" class="lt kh hu jt b fv lu lv l lw lx">#!/bin/bash</span><span id="bb60" class="lt kh hu jt b fv mq lv l lw lx">docker build . -t yarn-demo</span><span id="9154" class="lt kh hu jt b fv mq lv l lw lx">docker run --rm --entrypoint cat yarn-demo:latest /tmp/yarn.lock &gt; /tmp/yarn.lock<br/>if ! diff -q yarn.lock /tmp/yarn.lock &gt; /dev/null  2&gt;&amp;1; then<br/>  echo "We have a new yarn.lock"<br/>  cp /tmp/yarn.lock yarn.lock<br/>fi</span></pre><ul class=""><li id="e308" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">使其可执行:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="ccbd" class="lt kh hu jt b fv lu lv l lw lx">chmod +x build.sh</span></pre><ul class=""><li id="136b" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">用它来构建容器:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="3ba6" class="lt kh hu jt b fv lu lv l lw lx">./build.sh</span></pre><ul class=""><li id="ac08" class="le lf hu it b iu iv iy iz jc ly jg lz jk ma jo ll lm ln lo dt translated">然后运行容器:</li></ul><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="1a26" class="lt kh hu jt b fv lu lv l lw lx">docker run yarn-demo node -e "console.log('Hello, World')"</span></pre><p id="8dd7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你！你现在有了一个<strong class="it hv">确定性的</strong>纱线执行，只有当你改变 <code class="eh jq jr js jt b"><strong class="it hv">package.json</strong></code>时，纱线才被执行<strong class="it hv">。</strong></p><h1 id="119c" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">纱包缓存怎么办？</h1><p id="4be6" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc mn je jf jg mo ji jj jk mp jm jn jo hn dt translated">Yarn的另一个强大特性是包缓存，它存储在本地文件系统中，以避免再次下载包。到目前为止，我们的过程没有在容器构建上维护缓存。对于大的<code class="eh jq jr js jt b">package.json</code>文件来说，这可能是一个问题。</p><p id="12e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面的<code class="eh jq jr js jt b">build.sh</code>通过在你的工作目录中保存纱线缓存来解决这个问题。</p><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="1e59" class="lt kh hu jt b fv lu lv l lw lx">#!/bin/bash</span><span id="2531" class="lt kh hu jt b fv mq lv l lw lx"># Init empty cache file<br/>if [ ! -f .yarn-cache.tgz ]; then<br/>  echo "Init empty .yarn-cache.tgz"<br/>  tar cvzf .yarn-cache.tgz --files-from /dev/null<br/>fi</span><span id="3307" class="lt kh hu jt b fv mq lv l lw lx">docker build . -t yarn-demo</span><span id="6583" class="lt kh hu jt b fv mq lv l lw lx">docker run --rm --entrypoint cat yarn-demo:latest /tmp/yarn.lock &gt; /tmp/yarn.lock<br/>if ! diff -q yarn.lock /tmp/yarn.lock &gt; /dev/null  2&gt;&amp;1; then<br/>  echo "Saving Yarn cache"<br/>  docker run --rm --entrypoint tar yarn-demo:latest czf - /root/.yarn-cache/ &gt; .yarn-cache.tgz<br/>  echo "Saving yarn.lock"<br/>  cp /tmp/yarn.lock yarn.lock<br/>fi</span></pre><p id="3ceb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还需要将此添加到您的<code class="eh jq jr js jt b">Dockerfile</code>中，在<code class="eh jq jr js jt b">ADD package.json...</code>行之后:</p><pre class="jv jw jx jy fq lp jt lq lr aw ls dt"><span id="231a" class="lt kh hu jt b fv lu lv l lw lx"># Copy cache contents (if any) from local machine<br/>ADD .yarn-cache.tgz /</span></pre><p id="9d1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缓存文件并不意味着被推送到repo，所以它应该被添加到一个<code class="eh jq jr js jt b">.gitignore</code>文件中。</p><p id="4a12" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次祝贺你！你现在有了一个<strong class="it hv">确定性的</strong>纱线执行，只有当你改变 <code class="eh jq jr js jt b"><strong class="it hv">package.json</strong></code>时才执行<strong class="it hv">，它使用<strong class="it hv">纱线缓存</strong>。用真实项目中的一个复杂的<code class="eh jq jr js jt b">package.json</code>文件来试试吧，你会惊讶的！</strong></p><blockquote class="mr"><p id="0f74" class="ms mt hu bd mu mv mw mx my mz na jo ek translated"><em class="nb">如果你喜欢这个作品，点击下面的“</em><strong class="ak"><em class="nb">”♥︎</em></strong><em class="nb">”按钮。更多关于DevOps和Docker的文章，请加入我的<a class="ae jp" href="http://eepurl.com/clAQDb" rel="noopener ugc nofollow" target="_blank">邮件列表</a>。</em></p></blockquote><div class="nc nd ne nf ng ab cb"><figure class="nh jz ni nj nk nl nm paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nh jz ni nj nk nl nm paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nh jz ni nj nk nl nm paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nn no np"><p id="f922" class="ir is nq it b iu iv iw ix iy iz ja jb nr jd je jf ns jh ji jj nt jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是这个家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is nq it b iu iv iw ix iy iz ja jb nr jd je jf ns jh ji jj nt jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="jv jw jx jy fq jz fe ff paragraph-image"><a href="https://goo.gl/Ahtev1"><div class="fe ff nu"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></a></figure><figure class="jv jw jx jy fq jz"><div class="bz el l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>