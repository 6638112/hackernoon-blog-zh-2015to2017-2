<html>
<head>
<title>Presentations With Spectacle — How I Modularize My Deck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">展示奇观——我如何模块化我的甲板</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/presentations-with-spectacle-how-i-modularize-my-deck-775c082cef08?source=collection_archive---------2-----------------------#2017-01-29">https://medium.com/hackernoon/presentations-with-spectacle-how-i-modularize-my-deck-775c082cef08?source=collection_archive---------2-----------------------#2017-01-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="43eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">访问</strong><a class="ae jp" href="https://www.mikenikles.com" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">【https://www.mikenikles.com】</strong></a><strong class="it hv">获取我的最新博文。</strong></p><p id="9bea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我第一次遇到<a class="ae jp" href="http://formidable.com/open-source/spectacle/" rel="noopener ugc nofollow" target="_blank">奇观</a>时，我喜欢它是如何容易上手的，以及它是用React构建的。我每天都写React代码，为什么不用它来创建演示呢？有一段时间一切都很顺利，直到我意识到。/presentation/index.js 文件开始超过几百行。</p><blockquote class="jq jr js"><p id="946b" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">一定有办法把我的幻灯片模块化！</p></blockquote><p id="cbd2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">TL；dr: </strong>代码可从<a class="ae jp" href="https://github.com/mikenikles/presentations/tree/master/packages/blog-post-source" rel="noopener ugc nofollow" target="_blank">https://github . com/mikenikles/presentations/tree/master/packages/blog-post-source</a>获得</p><h1 id="3c6b" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">从“奇观样板”开始</h1><p id="f7a7" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">正如Github repo中所推荐的，我从克隆<strong class="it hv">biggest-boilerplate</strong>repo开始，并删除了<strong class="it hv">。git </strong>文件夹:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="94ed" class="lj jy hu lf b fv lk ll l lm ln">$ git clone git@github.com:FormidableLabs/spectacle-boilerplate.git blog-post-source<br/>$ cd blog-post-source<br/>$ rm -fr .git</span></pre><p id="da10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，您可以使用<code class="eh lo lp lq lf b">npm install</code>安装依赖项，并使用<code class="eh lo lp lq lf b">npm start</code>开始演示。它将在<a class="ae jp" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000上提供。</a></p><h1 id="7ff0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">为每张幻灯片创建一个文件夹</h1><p id="a70d" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">样板演示文稿中有四张幻灯片。让我们创造一个<strong class="it hv">。/presentation/slides </strong>目录，我们将把每张幻灯片移动到它自己的子文件夹中。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="d45c" class="lj jy hu lf b fv lk ll l lm ln">$ cd ./presentation<br/>$ mkdir slides &amp;&amp; cd slides<br/>$ mkdir 1 &amp;&amp; mkdir 2 &amp;&amp; mkdir 3 &amp;&amp; mkdir 4</span></pre><p id="52f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还希望每个文件夹中有一个<strong class="it hv"> index.js </strong>文件。这是每张幻灯片内容的位置。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="662f" class="lj jy hu lf b fv lk ll l lm ln">$ touch ./1/index.js &amp;&amp; touch ./2/index.js &amp;&amp; touch ./3/index.js &amp;&amp; touch ./4/index.js</span></pre><p id="e45f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这给我们留下了以下目录结构:</p><figure class="la lb lc ld fq ls fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/32f8350e986a627228a3b83031db2745.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*yJwtS9V5bhjoZuY_mslrXg.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Each slide has its own folder. The slide content lives in <strong class="bd lz">./presentation/slides/[slide-number]/index.js</strong></figcaption></figure><p id="5df7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">提交</em>:<a class="ae jp" href="https://github.com/mikenikles/presentations/commit/5d208f669c633da7d95424d48e62588081bd7d56" rel="noopener ugc nofollow" target="_blank">https://github . com/mikenikles/presentations/Commit/5d 208 f 669 c 633 da 7d 95424d 48 e 62588081 bd7d 56</a></p><h1 id="b011" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">填充每张幻灯片的内容</h1><p id="6fa2" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">奇观样板报告已经在<strong class="it hv">中提供了每张幻灯片的内容。/presentation/index.js </strong>。我们需要做的就是将每个<code class="eh lo lp lq lf b">&lt;Slide /&gt;</code>反应组件移动到其对应的<strong class="it hv">中。/presentation/slides/[slide-number]/index . js</strong>文件。</p><p id="d491" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们一起来看第一张幻灯片。</p><figure class="la lb lc ld fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ma"><img src="../Images/65b46909a0b7978a9cebf10cee335d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKyP-hsdXHYEjOUNw4WNeg.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Cut and paste that to ./presentation/slides/1/index.js</figcaption></figure><p id="f8e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还必须给<strong class="it hv">添加一些导入语句。/presentation/slides/1/index . js</strong>。此外，让我们确保导出此幻灯片的代码。最终文件如下所示:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="f12b" class="lj jy hu lf b fv lk ll l lm ln">import React from "react";<br/>import { Heading, Slide, Text } from "spectacle";</span><span id="9bce" class="lj jy hu lf b fv mf ll l lm ln">export default (<br/>  &lt;Slide transition={["zoom"]} bgColor="primary"&gt;<br/>    &lt;Heading size={1} fit caps lineHeight={1} textColor="secondary"&gt;<br/>        Spectacle Boilerplate<br/>    &lt;/Heading&gt;<br/>    &lt;Text margin="10px 0 0" textColor="tertiary" size={1} fit bold&gt;<br/>        open the presentation/index.js file to get started<br/>    &lt;/Text&gt;<br/>  &lt;/Slide&gt;<br/>);</span></pre><p id="a342" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对其余幻灯片执行相同的步骤。</p><p id="b84b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">提交</em>:<a class="ae jp" href="https://github.com/mikenikles/presentations/commit/a45f144247d0e4f0c39d922a9a23cf73c05c0a32" rel="noopener ugc nofollow" target="_blank">https://github . com/mikenikles/presentations/Commit/a45f 144247d 0 E4 f 0 c 39d 922 a9 a 23 cf 73 c 05 c0a 32</a></p><h1 id="f1da" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">动态加载幻灯片</h1><p id="b371" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">最后，我们必须动态加载每张幻灯片。这听起来比实际更棘手。概括地说，需要执行以下步骤:</p><ol class=""><li id="c11a" class="mg mh hu it b iu iv iy iz jc mi jg mj jk mk jo ml mm mn mo dt translated">用<code class="eh lo lp lq lf b">import()</code>动态加载所有幻灯片。</li><li id="691f" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">将加载的幻灯片提供给<code class="eh lo lp lq lf b">Presentation</code>组件的状态。</li><li id="fd22" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">在执行上述步骤1和2时，用占位符组件填充状态。</li><li id="973f" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">为每个动态加载的幻灯片提供一个独特的<code class="eh lo lp lq lf b">key</code>道具。</li></ol><h2 id="374e" class="lj jy hu bd jz mu mv mw kd mx my mz kh jc na nb kl jg nc nd kp jk ne nf kt ng dt translated">1.用<code class="eh lo lp lq lf b">import()</code>动态加载所有幻灯片</h2><p id="2e4b" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">在<strong class="it hv">中。/presentation/index.js </strong>，我们定义了所有幻灯片的列表以及它们的顺序。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="e414" class="lj jy hu lf b fv lk ll l lm ln">const slidesImports = [<br/>  import("./slides/1"),<br/>  import("./slides/2"),<br/>  import("./slides/3"),<br/>  import("./slides/4")<br/>];</span></pre><p id="1df0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个<code class="eh lo lp lq lf b">import()</code>语句都返回一个承诺。所以<code class="eh lo lp lq lf b">slidesImports</code>是一系列承诺。我们可以利用这一点，使用<code class="eh lo lp lq lf b">Promise.all()</code> <a class="ae jp" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank">函数</a>等待所有幻灯片导入完毕。稍后会有更多内容。</p><h2 id="475e" class="lj jy hu bd jz mu mv mw kd mx my mz kh jc na nb kl jg nc nd kp jk ne nf kt ng dt translated">2.将加载的幻灯片提供给<code class="eh lo lp lq lf b">Presentation</code>组件的状态。</h2><p id="d363" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated"><code class="eh lo lp lq lf b">Presentation</code>组件需要一个<code class="eh lo lp lq lf b">state</code>，一旦加载的幻灯片可用，我们就在那里提供它们。我们在<code class="eh lo lp lq lf b">constructor()</code>中填充一个空数组，并用<code class="eh lo lp lq lf b">componentDidMount()</code>生命周期方法中的实际幻灯片内容替换它。新的<code class="eh lo lp lq lf b">Presentation </code>组件现在看起来像这样:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="1878" class="lj jy hu lf b fv lk ll l lm ln">export default class Presentation extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="9211" class="lj jy hu lf b fv mf ll l lm ln">    this.state = {<br/>      slides: [] // A placeholder for slides once they're loaded.<br/>    };<br/>  }</span><span id="15e2" class="lj jy hu lf b fv mf ll l lm ln">  componentDidMount() {<br/>    const importedSlides = [];<br/>    Promise.all(slidesImports).then((slidesImportsResolved) =&gt; {<br/>      slidesImportsResolved.forEach((slide) =&gt; {<br/>        importedSlides.push(slide.default);<br/>      });<br/>      this.setState({ slides: importedSlides });<br/>    });<br/>  }</span><span id="d2a5" class="lj jy hu lf b fv mf ll l lm ln">  render() {<br/>    return (<br/>      &lt;Deck transition={["zoom", "slide"]} transitionDuration={500} theme={theme}&gt;<br/>      &lt;/Deck&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="ac56" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们快完成了。接下来，让我们更新<code class="eh lo lp lq lf b">render()</code>函数并实际渲染所有幻灯片。</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="e3e3" class="lj jy hu lf b fv lk ll l lm ln">render() {<br/>  const { slides } = this.state;<br/>  return (<br/>    &lt;Deck transition={["zoom", "slide"]} transitionDuration={500} theme={theme}&gt;<br/>      {<br/>        slides.map((slide) =&gt; {<br/>          return slide;<br/>        })<br/>      }<br/>    &lt;/Deck&gt;<br/>  );<br/>}</span></pre><p id="a392" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们查看<a class="ae jp" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>时，我们在浏览器控制台中看到一个空白屏幕和以下错误:</p><figure class="la lb lc ld fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff nh"><img src="../Images/fd90876a1bd80aedc2c77b3fcd40524e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkocPh9sUDVgQwIKMOB5Aw.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Browser console error based on the current code</figcaption></figure><p id="d6a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">仔细查看第415行的<strong class="it hv"> manager.js </strong>,可以发现该错误是由以下代码行引起的:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="5ec3" class="lj jy hu lf b fv lk ll l lm ln">children: _react.Children.toArray(child.props.children),</span></pre><p id="a7a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据错误消息，我们知道<code class="eh lo lp lq lf b">child</code>就是<code class="eh lo lp lq lf b">undefined</code>。这很容易解决。</p><h2 id="34f0" class="lj jy hu bd jz mu mv mw kd mx my mz kh jc na nb kl jg nc nd kp jk ne nf kt ng dt translated">3.在执行上述步骤1和2时，用占位符组件填充状态</h2><p id="297c" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">当第一次调用<code class="eh lo lp lq lf b">Presentation</code>组件的<code class="eh lo lp lq lf b">render()</code>函数时，<code class="eh lo lp lq lf b">this.state.slides</code>被设置为空数组。telegraph不喜欢这样，所以让我们提供一些占位符幻灯片，直到我们的真实幻灯片被导入并添加到状态中。</p><p id="c566" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以提供一个空幻灯片，直到<code class="eh lo lp lq lf b">this.state.slides</code>可用，大致如下:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="4a70" class="lj jy hu lf b fv lk ll l lm ln">render() {<br/>  const { slides } = this.state;<br/>  return (<br/>    &lt;Deck transition={["zoom", "slide"]} transitionDuration={500} theme={theme}&gt;<br/>      {<br/>        slides.length ? slides.map((slide) =&gt; {<br/>          return slide;<br/>        }) : &lt;Slide /&gt;<br/>      }<br/>    &lt;/Deck&gt;<br/>  );<br/>}</span></pre><p id="206e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们在<a class="ae jp" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>加载第一张幻灯片时，这实际上工作得很好。但是，尝试导航到第二张幻灯片，并在<a class="ae jp" href="http://localhost:3000/#/1" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/#/1</a>重新加载页面。<em class="jt">错误</em>。</p><p id="5e58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这告诉我们，在第一次调用<code class="eh lo lp lq lf b">Presentation</code>组件的<code class="eh lo lp lq lf b">render()</code>函数时，telegypt需要知道一个演示需要的幻灯片的确切数量。</p><p id="3d23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很简单，让我们通过将<code class="eh lo lp lq lf b">constructor()</code>函数从:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="7c80" class="lj jy hu lf b fv lk ll l lm ln">constructor(props) {<br/>  super(props);</span><span id="7305" class="lj jy hu lf b fv mf ll l lm ln">  this.state = {<br/>    slides: []<br/>  };<br/>}</span></pre><p id="e1e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">收件人:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="0d2a" class="lj jy hu lf b fv lk ll l lm ln">constructor(props) {<br/>  super(props);</span><span id="d25d" class="lj jy hu lf b fv mf ll l lm ln">  this.state = {<br/>    slides: Array(slidesImports.length).fill(&lt;Slide key="loading" /&gt;)<br/>  };<br/>}</span></pre><p id="c160" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们基本上用将要导入的幻灯片的确切数量来填充状态的<code class="eh lo lp lq lf b">slides</code>属性。在上面的代码片段中，我们呈现了一个空的<code class="eh lo lp lq lf b">&lt;Slide /&gt;</code>组件，但是我们也可以设计一个漂亮的幻灯片来显示“Loading…”微调器。</p><p id="a01e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在回到<a class="ae jp" href="http://localhost:3000/#/1" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/#/1</a>，欣赏你演示的第二张幻灯片，不要出现我们之前看到的严重错误。</p><p id="42e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">等一下，我说得太早了…</p><figure class="la lb lc ld fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff ni"><img src="../Images/79b6029042f9709bbf7fa4e6d499ea5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqnYlKKfO0_gAG0ZbyY9-Q.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Each &lt;Slide /&gt; component requires a unique “key” prop</figcaption></figure><p id="2865" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">哦，是的，没错。<a class="ae jp" href="https://facebook.github.io/react/docs/lists-and-keys.html#keys" rel="noopener ugc nofollow" target="_blank">错误信息中的链接</a>解释了为什么<code class="eh lo lp lq lf b">key</code>道具很重要。</p><h2 id="36bf" class="lj jy hu bd jz mu mv mw kd mx my mz kh jc na nb kl jg nc nd kp jk ne nf kt ng dt translated">4.为每个动态加载的载玻片提供独特的<code class="eh lo lp lq lf b">key</code>支撑</h2><p id="3f08" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">为此，我们有两种选择:</p><ol class=""><li id="1f86" class="mg mh hu it b iu iv iy iz jc mi jg mj jk mk jo ml mm mn mo dt translated">给<strong class="it hv">内的每个<code class="eh lo lp lq lf b">&lt;Slide /&gt;</code>组件增加一个<code class="eh lo lp lq lf b">key</code>支柱。/presentation/slides/[幻灯片编号]/index.js </strong>。</li><li id="6078" class="mg mh hu it b iu mp iy mq jc mr jg ms jk mt jo ml mm mn mo dt translated">在<code class="eh lo lp lq lf b">Presentation</code>组件的<code class="eh lo lp lq lf b">render()</code>函数中动态提供<code class="eh lo lp lq lf b">key</code>道具。</li></ol><p id="5c9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">选项1听起来很简单，但我们将选择选项2，因为它使以后重新排列幻灯片更容易。如果单个幻灯片<code class="eh lo lp lq lf b">index.js</code>文件不知道它们在演示文稿中的位置，我们可以简单地将幻灯片的文件夹从<code class="eh lo lp lq lf b">1</code>重命名为<code class="eh lo lp lq lf b">3</code>，将幻灯片从演示文稿的第一个位置移动到第三个位置。</p><p id="12cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lo lp lq lf b">render()</code>函数的更新后的<code class="eh lo lp lq lf b">&lt;Deck /&gt;</code>组件现在看起来像这样:</p><pre class="la lb lc ld fq le lf lg lh aw li dt"><span id="3f67" class="lj jy hu lf b fv lk ll l lm ln">&lt;Deck transition={["zoom", "slide"]} transitionDuration={500} theme={theme}&gt;<br/>  {<br/>    slides.map((slide, index) =&gt; {<br/>      return React.cloneElement(slide, {key: index});<br/>    })<br/>  }<br/>&lt;/Deck&gt;</span></pre><p id="f62b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jt">提交</em>:<a class="ae jp" href="https://github.com/mikenikles/presentations/commit/2c8630086548405e7d7ac2394d087fcfe504b06c" rel="noopener ugc nofollow" target="_blank">https://github . com/mikenikles/presentations/Commit/2c 8630086548405 e 7d 7 AC 2394d 087 fcfe 504 b 06 c</a></p><h1 id="b8a7" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">结论</h1><p id="fc2e" class="pw-post-body-paragraph ir is hu it b iu kv iw ix iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo hn dt translated">使用这种方法，我现在可以轻松地模块化我的眼镜演示。事实上，我可以把这个提升到一个全新的水平…</p><p id="08bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我可以用常用幻灯片的集合创建一个NPM模块，例如我在每次演示时使用的“关于我”的幻灯片。每当我想在演示文稿中使用它时，我可以简单地将它作为依赖项添加到我的<strong class="it hv"> package.json </strong>文件中，并将其导入到我的演示文稿中正确的索引处。</p><p id="6c88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您有任何问题，请随时联系我们！</p><div class="la lb lc ld fq ab cb"><figure class="nj ls nk nl nm nn no paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nj ls nk nl nm nn no paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nj ls nk nl nm nn no paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="jq jr js"><p id="f922" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated"><a class="ae jp" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是阿妹家庭的一员。我们现在<a class="ae jp" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jp" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="ir is jt it b iu iv iw ix iy iz ja jb ju jd je jf jv jh ji jj jw jl jm jn jo hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jp" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jp" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="la lb lc ld fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="fe ff np"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>