<html>
<head>
<title>The Curious Case of Pid Namespaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pid名称空间的奇怪情况</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-curious-case-of-pid-namespaces-1ce86b6bc900?source=collection_archive---------1-----------------------#2017-06-10">https://medium.com/hackernoon/the-curious-case-of-pid-namespaces-1ce86b6bc900?source=collection_archive---------1-----------------------#2017-06-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div class="fe ff hs"><img src="../Images/c645d55c406ffb220ea0c32167c65084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*sXTl8KP1W6gsYACGaji-gw.png"/></div></figure><div class=""/><div class=""><h2 id="c176" class="pw-subtitle-paragraph iy ia ib bd b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp ek translated">以及容器如何共享它们</h2></div><p id="7aca" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">名称空间是linux容器的主要组件之一。名称空间提供了共享资源的隔离:它们为每个应用程序提供了自己独特的系统视图。由于名称空间，每个docker容器似乎都有自己的文件系统和网络。Linux在许多版本中逐渐增加了名称空间支持。由于这种逐渐的变化，每种类型的名称空间都有其独特的挑战。Pid名称空间特别需要特殊处理，尤其是当涉及多个进程时。</p><h2 id="1f3d" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">Linux中的PID</h2><p id="d06a" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">linux中的进程存在于一个树状结构中。内核中的每个进程都有一个唯一的进程标识符，简称为“pid”。中每个进程的记录跟踪其直接父进程的pid。当通过<a class="ae lm" href="http://man7.org/linux/man-pages/man2/fork.2.html" rel="noopener ugc nofollow" target="_blank"> fork </a> syscall创建进程时，pid也被传递给父进程。内核为子进程生成一个新的pid，并将标识符返回给调用进程，但是由父进程手动跟踪这个pid。</p><p id="5626" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">内核启动的第一个进程的pid为1。这个过程被称为初始化过程，或简称为“初始化”。init的父pid是pid 0，表示它的父是内核。Pid 1是用户空间进程树的根:通过递归地跟随每个进程的父进程，可以从任何进程到达linux系统上的pid 1。如果pid 1死了，内核就会死机，你必须重启机器。</p><h2 id="343c" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">名称空间的快速概述</h2><p id="f77e" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated"><a class="ae lm" href="https://lwn.net/Articles/531114/" rel="noopener ugc nofollow" target="_blank"> Linux名称空间</a>是使用<a class="ae lm" href="http://man7.org/linux/man-pages/man2/unshare.2.html" rel="noopener ugc nofollow" target="_blank"> unshare </a> syscall创建的，传递一组表示要创建哪些名称空间的标志。在大多数情况下，unshare会让您直接进入新的名称空间。例如，当一个进程创建一个网络名称空间时，它会立即看到一个没有设备的空网络视图。</p><p id="20df" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">pid名称空间<a class="ae lm" href="https://lwn.net/Articles/531419/" rel="noopener ugc nofollow" target="_blank">有点不同</a>:当您取消共享pid名称空间时，进程不会立即进入新的名称空间。而是要求分叉。子进程进入pid名称空间，成为pid 1。这赋予了它特殊的属性。</p><p id="d47a" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">同样重要的是要注意，pid名称空间创建了流程层次结构的单独视图。换句话说，分叉的进程实际上有两个pid:它在名称空间内有pid 1，在名称空间外有不同的pid。</p><h2 id="a22d" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">命名空间中的Pid 1</h2><p id="410d" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">在名称空间中，与其他进程相比，init (pid 1)有三个独特的特性:</p><p id="1b62" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">1)它不会自动获得默认的信号处理程序，因此发送给它的信号会被忽略，除非它为该信号注册了信号处理程序。(这就是为什么许多docker化的进程无法响应ctrl-c，而您被迫用类似‘docker kill’的东西杀死它们)。</p><p id="bff5" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">2)如果命名空间中的另一个进程在其子进程之前终止，则它的子进程将被重定为pid 1。这允许init从进程中收集退出状态，以便内核可以将其从进程表中删除。</p><p id="8c8e" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">3)如果它死亡，pid名称空间中的每一个其他进程将被强制终止，并且该名称空间将被清理。</p><p id="dcee" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">很明显，init进程与容器的生命周期紧密相关。</p><h2 id="df3e" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">码头工人的“错误”</h2><p id="f71e" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">Docker(和runc)运行指定为容器入口点(或cmd)的进程，作为新pid名称空间中的pid 1。这可能会导致应用程序进程出现一些意外行为，因为它通常不是作为pid 1运行的。如果它不建立自己的信号处理程序，发信号的进程就不会工作。如果它派生出一个在任何孙进程退出之前死亡的子进程，僵尸进程会在容器中累积，可能会填满进程表。</p><p id="3dfc" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">Docker对这件事一直不闻不问。可以在你的容器中运行一个特殊的init进程，并把它fork-exec到应用程序进程中，许多容器这样做是为了避免这些问题。这个决定的一个不幸的副作用是容器变得更加复杂。一旦容器有了真正的init系统，人们倾向于嵌入多个进程，这牺牲了依赖隔离的一些好处。Docker缺乏对pods的本地支持只会加剧这个问题。</p><h2 id="d9bd" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">Rkt“解决方案”</h2><p id="6d1f" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">Rkt对这个问题采取了一种更理智的方法。它假设您正在启动的进程不是一个init进程，所以它为您创建一个init进程(systemd ),然后让systemd为容器进程创建一个文件系统名称空间并启动它。Systemd成为名称空间中的pid 1，容器进程作为pid 2运行。这意味着如果容器提供了一个init进程，它将作为pid 2运行，但是这在实践中很少引起问题。</p><h2 id="093f" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">更简单的选择</h2><p id="6ff6" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">对于单个进程，像systemd这样的高级init系统是多余的，但是期望容器构建者理解pid名称空间和init进程的细微差别是错误的。有一个更简单的解决方案，但是它要求容器的生成者代表用户充当init。</p><p id="da3d" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在分叉到pid名称空间之后，spawner可以再次分叉，而不是立即执行容器进程。第二个分支允许容器生成者成为pid 1。它可以设置信号处理程序将所有信号传递给孩子。然后，它可以收获僵尸，直到其子进程死亡，此时，它可以收集容器进程的退出状态，并将其传递给容器化系统。这意味着信号按预期工作(我可以再次ctrl-c我的进程！)和丧尸妥妥的收割。</p><p id="be73" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">请注意，从docker 1.13开始，类似的替代方案已经可用。启动容器时可以传递<code class="eh ln lo lp lq b">--init</code>标志，这将导致docker为您启动一个简单的init进程。然而，这个选项似乎没有被广泛使用，而且在我的实验中，它似乎有一些缺陷。我发现了这样的场景，当我按ctrl-c键控制进程时，init进程不会停止，直到被手动终止。</p><h2 id="4c44" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">一个容器中有多个容器</h2><p id="df46" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">多个相关的进程一起运行通常是有益的，但是最好将这些进程分别捆绑起来，这样就可以隔离它们的依赖关系。为了实现这一点，rkt和kubernetes引入了豆荚的概念。pod是一组共享一些名称空间的相关容器。在rkt实现中，除了文件系统名称空间之外，每个名称空间都是共享的。</p><p id="cbc7" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">因为kubernetes也支持pods，所以它使用docker说明了一种类似的方法。由于pid名称空间的上述问题，kubernetes还没有在同一个pod 中的容器之间共享pid名称空间。这是不幸的，因为这意味着同一个pod中的进程不能相互发送信号。此外，pod中的每个容器都有前面提到的init问题:每个容器进程都将作为pid 1运行。</p><p id="9272" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">rkt方法优于pod。您不需要在容器中运行init进程，但是创建多个可以相互通信甚至相互发送信号的进程是很容易的。不幸的是，当我们开始讨论向现有的pod添加容器时，情况就不那么简单了。</p><h2 id="f620" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">向Pod添加容器</h2><p id="4974" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">通过<a class="ae lm" href="http://blog.kubernetes.io/2016/12/container-runtime-interface-cri-in-kubernetes.html" rel="noopener ugc nofollow" target="_blank">容器运行时接口</a>，kubernetes引入了pod沙箱的概念。这允许容器运行时在启动容器之前分配资源。虽然对联网特别有用，但该概念还允许向现有的pod添加容器。如果您首先创建pod沙箱，然后一个接一个地启动容器，为什么不允许稍后添加一个额外的容器呢？这对于数据库备份或日志收集等周期性任务尤其有用。</p><p id="359e" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">Rkt引入了对这一特性的实验支持，允许创建独立于任何容器的pod。容器(或者rkt术语中的“应用程序”)可以在以后从pod中添加或删除。Rkt通过在没有运行单元的情况下启动systemd来实现这一点。然后，它与pod的systemd通信，按需启动新的应用程序。这个解决方案非常优雅，尽管在这个模型中，init进程有额外的特权，并引入了新的攻击媒介。rkts沙盒模型中的systemd进程:</p><ul class=""><li id="eaa9" class="lr ls ib js b jt ju jw jx jz lt kd lu kh lv kl lw lx ly lz dt translated">有权访问主机的文件系统名称空间，因此它可以为它启动的容器创建文件系统名称空间。</li><li id="c65f" class="lr ls ib js b jt ma jw mb jz mc kd md kh me kl lw lx ly lz dt translated">必须维护全部特权，因为它不知道每个新应用程序将需要的特权集。</li><li id="98fc" class="lr ls ib js b jt ma jw mb jz mc kd md kh me kl lw lx ly lz dt translated">对容器中运行的所有其他进程都是可见的。</li></ul><p id="d3a3" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在非沙盒模型中，init进程可以启动子进程，然后放弃这些特权以最小化危害的影响。</p><h2 id="fa11" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">沙箱和Pid命名空间</h2><p id="55bc" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">有几种不同的方法来处理init、沙箱和pid名称空间。每种方法都有一些缺点。以下是可用的选项:</p><ol class=""><li id="9fe7" class="lr ls ib js b jt ju jw jx jz lt kd lu kh lv kl mf lx ly lz dt translated">Pid名称空间不是与沙箱一起创建的。相反，每个容器都有自己的pid名称空间。这符合kubernetes目前的工作方式，并且可以受益于上面提到的处理单个进程的更简单的init策略。这种方法的主要缺点是pod中的进程不能相互发送信号。</li><li id="4ba5" class="lr ls ib js b jt ma jw mb jz mc kd md kh me kl mf lx ly lz dt translated">Pid名称空间不是与沙箱一起创建的。相反，pid名称空间是在沙箱中启动第一个容器时创建的。在这种模式下，进程可以相互发送信号。缺点是启动的第一个进程成为pod的“主进程”。如果它死了，所有其他容器进程都将被内核终止。主流程必须存在于pod的整个生命周期中。</li><li id="09e7" class="lr ls ib js b jt ma jw mb jz mc kd md kh me kl mf lx ly lz dt translated">Pid名称空间是与沙箱一起创建的。沙箱包括一个智能初始化进程，可用于启动其他进程。这就是rkt应用程序沙盒的工作方式。如上所述，缺点是init进程特权过多，引入了新的安全攻击媒介。</li><li id="3074" class="lr ls ib js b jt ma jw mb jz mc kd md kh me kl mf lx ly lz dt translated">Pid名称空间是与沙箱一起创建的。沙箱包括一个简单的init进程，该进程只处理信号和收割僵尸。其他每个进程都进入pid名称空间，但是在名称空间之外仍然有一个活动的父进程。因为init进程没有启动新的容器，所以它不需要维护特权或访问主机文件系统。这种方法的缺点是，在名称空间中，每个进程似乎都有一个pid为0的父进程，因此进程树的正常树状结构被破坏了。</li><li id="0d18" class="lr ls ib js b jt ma jw mb jz mc kd md kh me kl mf lx ly lz dt translated">pid名称空间和init与选项四完全相同。其他每个进程都进入pid名称空间并守护(父进程退出)。内核将<a class="ae lm" href="https://lwn.net/Articles/532748/" rel="noopener ugc nofollow" target="_blank">将进程重新初始化为init </a>，这将修复选项四的损坏的进程树。这种情况下的缺点是在后台化变得困难之后从外部监控新流程。集装箱化系统被迫通过pid跟踪过程，而不是简单地等待过程。</li></ol><p id="6367" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">那么这些选项中哪一个是最好的呢？这两种情况都有道理，但我更倾向于选择4和5。事实上，人们可以根据流程的预期生命周期在它们之间进行选择。第五个选项非常适合长时间运行的流程，尤其是对于docker，无论如何，流程生成者最终都会使流程变得混乱。如果流程是一个较短的任务，使用选项四并将流程与pid流程树分开会使事情变得非常简单。</p><p id="448b" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">看起来kubernetes正在做一些工作来创建一个可以充当init的<a class="ae lm" href="https://github.com/kubernetes/kubernetes/commit/81d27aa23969b77f5e7e565b0b69234537b0503e" rel="noopener ugc nofollow" target="_blank">暂停容器</a>。一旦kubernetes支持共享pid名称空间，option 5很快就会跟上。</p><h2 id="22e8" class="km kn ib bd ko kp kq kr ks kt ku kv kw jz kx ky kz kd la lb lc kh ld le lf lg dt translated">结论</h2><p id="71b3" class="pw-post-body-paragraph jq jr ib js b jt lh jc jv jw li jf jy jz lj kb kc kd lk kf kg kh ll kj kk kl hn dt translated">pid名称空间中隐藏着相当多的复杂性。今天集装箱化系统所做的选择有明显的缺点，可以通过采用替代方法来避免。虽然docker中单个容器的缺点已经被很好地理解了，并且有一个合理的解决方法，但是允许容器生成者充当init将会简化容器构建者的工作。</p><p id="09f5" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">当涉及到容器组时，独立init的rkt方法优于docker方法。它允许进程通过信号进行通信，这在当前使用kubernetes pod模型是不可能的。然而，一旦包含了延迟启动容器，即使rkt的方法也开始显示出一些缺点。</p><p id="343f" class="pw-post-body-paragraph jq jr ib js b jt ju jc jv jw jx jf jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">对于延迟启动容器，最引人注目的方法是启动一个简单的init进程和pid名称空间，但是通过容器生成器生成新的容器进程。这允许init进程放弃特权，关闭攻击媒介。spawner可以选择对新流程进行daemonize，保持流程树的一致性，或者它可以作为新流程的父流程，从而简化流程管理。</p><div class="mg mh mi mj fq ab cb"><figure class="mk hw ml mm mn mo mp paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mk hw ml mm mn mo mp paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mk hw ml mm mn mo mp paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mq mr ms"><p id="f922" class="jq jr mt js b jt ju jc jv jw jx jf jy mu ka kb kc mv ke kf kg mw ki kj kk kl hn dt translated"><a class="ae lm" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae lm" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae lm" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>，并乐意<a class="ae lm" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jq jr mt js b jt ju jc jv jw jx jf jy mu ka kb kc mv ke kf kg mw ki kj kk kl hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae lm" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae lm" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="fe ff mx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>