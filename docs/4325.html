<html>
<head>
<title>How to Build a React Website Powered by the Cosmic JS GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个由Cosmic JS GraphQL API支持的React网站</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-build-a-react-website-powered-by-the-cosmic-js-graphql-api-1fc246137b57?source=collection_archive---------8-----------------------#2017-05-25">https://medium.com/hackernoon/how-to-build-a-react-website-powered-by-the-cosmic-js-graphql-api-1fc246137b57?source=collection_archive---------8-----------------------#2017-05-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bbb6ed3517cbe4531c5f776ae55fe8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYu0TuplST9zSNzYP05bvQ.jpeg"/></div></div></figure><p id="fbe7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章最初出现在宇宙JS博客上。</p><p id="3533" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">构建和维护一个React应用程序绝非易事。有很多教程涵盖了制作React应用程序的技术方面，但与任何技术一样，通常很难找到关于最佳实践的信息。</p><p id="8aa5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本帖中，我们将探索一些我们在为客户开发React/GraphQL应用时学到的技巧、诀窍和技术。希望这些能帮助你提高项目的性能，简化维护。</p><h1 id="380c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="59b9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://cosmicjs.com/apps/react-graphql-blog/demo" rel="noopener ugc nofollow" target="_blank">查看演示</a> <br/> <a class="ae ka" href="https://cosmicjs.com/apps/react-graphql-blog" rel="noopener ugc nofollow" target="_blank">在Cosmic JS上安装app</a><br/><a class="ae ka" href="https://github.com/cosmicjs/react-graphql-blog" rel="noopener ugc nofollow" target="_blank">在GitHub上查看代码库</a></p><h1 id="dac5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">你可能不需要国家</h1><p id="92d7" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您使用React已经有一段时间了，那么在开始一个新项目时，您的第一反应可能是建立一个状态管理库，比如Redux、MobX或freactal。这些对于状态管理来说是非常强大的解决方案，可以使处理大型应用程序的状态变得更加容易管理。</p><p id="5e14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，像任何库一样，除非确实需要，否则不应该开始使用这些状态管理解决方案！对于一个简单的博客，就像我们今天要构建的，你真正需要的唯一状态就是当前的URL。</p><p id="c6eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">“但是！”我听到你哭喊“我将如何存储/缓存/处理我通过网络从Cosmic JS这样的伟大服务中获取的API优先的数据？”。别担心！在本文的后半部分，我们将探索GraphQL，这是一个以声明方式从服务器获取数据的系统，特别是Apollo GraphQL客户端，用于简单地与GraphQL接口。</p><p id="53cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我们关注的是一个简单的、仅供查看的应用程序，但是值得一提的是，基于类的React组件提供的状态对于只影响应用程序局部的状态来说已经足够了。Dan abra mov(Redux的创建者)在这里写了更多关于这个主题的细节</p><h1 id="6b0c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用路由存储您的视图信息</h1><p id="0807" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当然，如果我们没有一些状态，我们只是一次显示整个web应用程序。幸运的是，你的浏览器提供了一个内置的状态存储，包括撤销历史、无摩擦共享和一个简单的界面:你的URL栏。</p><p id="18bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">出色的React路由器库提供了一个简单而富于表现力的界面来导航您的应用。我们示例应用程序中的大部分路由都是在以下文件中处理的:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="5558" class="ln kc hu lj b fv lo lp l lq lr">// src/components/posts.js</span><span id="5b75" class="ln kc hu lj b fv ls lp l lq lr">import styled from "styled-components";<br/>import { Route, Switch, } from "react-router";</span><span id="1bad" class="ln kc hu lj b fv ls lp l lq lr">import Post, { Blank, Home, FourOhFour, } from "./post";<br/>import Sidebar from "./Sidebar";</span><span id="e56b" class="ln kc hu lj b fv ls lp l lq lr">const PostsStyled = styled.div`<br/>    background-color: ${R.path(["theme", "white",])};<br/>    flex-direction: row;<br/>`;</span><span id="455e" class="ln kc hu lj b fv ls lp l lq lr">export default () =&gt; (<br/>   &lt;PostsStyled&gt;</span><span id="7653" class="ln kc hu lj b fv ls lp l lq lr">        &lt;Route path = "/post" component = { Sidebar } /&gt;</span><span id="15c3" class="ln kc hu lj b fv ls lp l lq lr">        &lt;Switch&gt; <br/>            &lt;Route path = "/post/:postSlug" component = { Post } /&gt;<br/>            &lt;Route path = "/post/" component = { Blank } /&gt;<br/>            &lt;Route path = "/" exact component = { Home } /&gt;<br/>            &lt;Route component = { FourOhFour } /&gt;<br/>        &lt;/Switch&gt;</span><span id="5501" class="ln kc hu lj b fv ls lp l lq lr">    &lt;/PostsStyled&gt;<br/>);</span></pre><p id="84dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一种方法为任何以/post开头的URL呈现侧栏</p><p id="5ae0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Switch组件用匹配的路径呈现它的第一个孩子。我们的路由配置执行以下操作:</p><ul class=""><li id="daf8" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">如果URL是/post/some-post-slug，我们显示带有slug some-post-slug的帖子</li><li id="cf30" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">如果网址是/post，我们只显示侧边栏，让你选择一篇文章</li><li id="ede0" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">如果URL是/我们显示主页</li><li id="6cf7" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">对于任何其他网址，我们显示404页</li></ul><p id="c83e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些意味着我们可以通过改变URL在应用程序的所有不同视图之间切换。</p><p id="a75e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React路由器提供了一个链接组件，它的作用就像一个增压的<a>标签。你应该使用链接来链接那些不在你网站之外的超链接。</a></p><h1 id="5ddb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">样式组件和主题提供者位于你的样式之上</h1><p id="e138" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">像SASS这样的CSS预编译器首先使web开发人员能够开始在他们的样式中使用变量和函数。然后React出现了，并普及了内嵌风格系统:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7c80" class="ln kc hu lj b fv lo lp l lq lr">&lt;div<br/>   style = {{<br/>      display: "flex",<br/>      backgroundColor: "red",<br/>      color: "white",<br/>      margin: "4px",<br/>   }}<br/>/&gt;</span></pre><p id="52e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最热门的新趋势是Styled Components，它允许您通过指定一个组件来创建新的组件，以及您想要应用于它的CSS样式。这些样式会自动加上厂商前缀，最终都会转换成样式表。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1fd4" class="ln kc hu lj b fv lo lp l lq lr">const Link = styled.a`<br/>   color: white;<br/>   font-size: 0.8em;<br/>   text-decoration: none;<br/>`;</span></pre><p id="2dc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">样式化组件还提供了一种设置全局变量的方法，这些变量由每个样式化组件继承。ThemeProvider组件可用于为每个样式化组件提供变量，如下所示:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d636" class="ln kc hu lj b fv lo lp l lq lr">const theme = {<br/>    white: "#fff",<br/>    blue: "#00afd7",<br/>};</span><span id="5a59" class="ln kc hu lj b fv ls lp l lq lr">export default () =&gt; (<br/>    &lt;ThemeProvider theme = { theme }&gt;<br/>      &lt;App/&gt;<br/>    &lt;/ThemeProvider&gt;<br/>);</span></pre><p id="e87d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，作为App子组件的每个样式化组件都可以使用样式中的函数来访问这些变量:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="a556" class="ln kc hu lj b fv lo lp l lq lr">const Link = styled.a`<br/>   color: ${ (props) =&gt; props.theme.blue };<br/>   font-size: 0.8em;<br/>   text-decoration: none;<br/>`</span></pre><p id="1e01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">主题对象可以是任何javascript对象，而${ }块中的函数可以是任何函数，所以在样式化的组件中可以做大量很酷的事情，同时仍然将所有变量保存在一个统一的地方。</p><h1 id="37fb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">GraphQL</h1><p id="2220" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">GraphQL是一个声明性的、自我文档化的API规范，它允许您只向API请求您需要的数据。它对您的API施加了一些限制和想法，允许GraphQL客户端创建一些非常酷的特性，包括:</p><ul class=""><li id="bf27" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">自动缓存。</li><li id="22bb" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">从存储的数据中智能解析数据请求。</li><li id="2922" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">将数据获取连接到显示数据的组件。</li></ul><p id="7312" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将仔细检查并解释我们在示例项目中使用的所有步骤，但是如果您想要GraphQL协议的更完整的解释，您可以在这里阅读它的全文。</p><p id="2911" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Cosmic JS提供的GraphQL API有3个查询:</p><ul class=""><li id="495f" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">objects:获取桶中的所有对象</li><li id="8043" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">objectsByType:获取桶中某一类型的所有对象</li><li id="0e2a" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">object:通过slug获取特定对象</li></ul><p id="68bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里完整记录了这些查询。</p><h1 id="ebda" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">设置Cosmic JS GraphQL API</h1><p id="d018" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">首先我们需要设置我们的ApolloClient:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d08b" class="ln kc hu lj b fv lo lp l lq lr">//src/GraphQL/index.js</span><span id="20b8" class="ln kc hu lj b fv ls lp l lq lr">import { ApolloClient, createNetworkInterface, } from "react-apollo";</span><span id="b714" class="ln kc hu lj b fv ls lp l lq lr">const networkInterface = createNetworkInterface({<br/>    uri: "https://graphql.cosmicjs.com/v1",<br/>});</span><span id="a14e" class="ln kc hu lj b fv ls lp l lq lr">const client = new ApolloClient({<br/>    networkInterface,<br/>});</span><span id="08c5" class="ln kc hu lj b fv ls lp l lq lr">export default client;</span></pre><p id="fc11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们使用ApolloProvider将它提供给应用程序的其余部分:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9e57" class="ln kc hu lj b fv lo lp l lq lr">//src/app.js</span><span id="da30" class="ln kc hu lj b fv ls lp l lq lr">import React from "react";<br/>import { ApolloProvider, } from "react-apollo";<br/>import styled, { ThemeProvider, } from "styled-components";</span><span id="95cf" class="ln kc hu lj b fv ls lp l lq lr">import client from "./GraphQL";</span><span id="15e4" class="ln kc hu lj b fv ls lp l lq lr">export default () =&gt; (<br/>    &lt;ThemeProvider theme = { theme }&gt;<br/>        &lt;ApolloProvider client = { client }&gt;<br/>         &lt;App /&gt;<br/>        &lt;/ApolloProvider&gt;<br/>    &lt;/ThemeProvider&gt;<br/>);</span></pre><p id="98ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Apollo provider意味着我们的应用程序中的任何组件都可以将自己连接到GraphQL查询，这意味着每个组件都可以要求客户端准确获取呈现自己所需的数据。不用担心多个组件向服务器发送垃圾请求；ApolloClient自己处理缓存和重复数据删除！</p><p id="033d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始探索如何在这个应用程序中使用GraphQL之前，我们现在将花一点时间来探索一些可以让graph QL更好用的方法。在这篇博文中，我们没有包括运行这个示例所需的所有代码，但是您可以在这里找到我们演示项目的源代码。跟着走！</p><h1 id="cede" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用片段重用数据</h1><p id="a449" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有时，您希望在两个不同的查询中从一个对象获得相同的字段，GraphQL提供了一个以片段形式实现这一点的系统。片段允许你从一个对象中挑选一些字段，并且只要求这些字段。</p><p id="cd01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，在侧边栏中，我们只需要一篇文章的一些基本信息:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3bcb" class="ln kc hu lj b fv lo lp l lq lr">fragment PostPreview on Object {<br/>    slug<br/>    typeSlug: type_slug<br/>    title<br/>    modifiedAt: modified_at<br/>}</span></pre><p id="0b07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是在帖子本身中，我们想要所有的信息，再加上更多:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b13e" class="ln kc hu lj b fv lo lp l lq lr">fragment PostAllContent on Object {<br/>    ...PostPreview<br/>    content<br/>    metadata<br/>    order<br/>}</span></pre><p id="a205" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们可以在侧栏使用的查询中使用PostPreview片段:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0df5" class="ln kc hu lj b fv lo lp l lq lr"># getAllPostsQuery<br/>query($bucketSlug: String! $readKey: String!){<br/>    objects: objectsByType(bucket_slug: $bucketSlug, read_key: $readKey, type_slug: "posts") {<br/>        ...PostPreview<br/>    }<br/>}</span></pre><p id="01de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">和Post组件使用的查询中的PostAllContent片段</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d4b2" class="ln kc hu lj b fv lo lp l lq lr"># getPostQuery<br/>query($bucketSlug: String! $readKey: String! $postSlug: String!){<br/>    object(bucket_slug: $bucketSlug, read_key: $readKey, slug: $postSlug) {<br/>        ...PostAllContent<br/>    }<br/>}</span></pre><p id="640a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">碎片之所以伟大，有两个原因:</p><ol class=""><li id="2a59" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz mh lz ma mb dt translated">它们允许您模块化和重用您想要从查询中获得的属性</li><li id="4a11" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz mh lz ma mb dt translated">它们确保应该获得相同信息的两个查询始终保持同步，因此Apollo可以成功地缓存结果</li></ol><h1 id="bfd4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">使用组件属性作为查询参数</h1><p id="0985" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">您会注意到上面的查询有2/3的输入字段:</p><ul class=""><li id="36fb" class="lt lu hu je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb dt translated">$bucketString:我们要从中获取对象的桶的段</li><li id="8ccd" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">$readKey:从桶中读取的读取键(如果需要)</li><li id="a718" class="lt lu hu je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb dt translated">$postSlug:我们想要获取的特定对象的Slug(如果需要的话)</li></ul><p id="bccd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些变量用于将查询导向正确的数据。Apollo为我们提供了一个强大的API来设置这些变量，但通常对于简单的组件，使用props来设置它们会更容易:</p><h2 id="cc0e" class="ln kc hu bd kd mi mj mk kh ml mm mn kl jn mo mp kp jr mq mr kt jv ms mt kx mu dt translated">默认道具</h2><p id="1d57" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于在我们的应用程序中相同的变量，比如$bucketSlug，我们可以使用它们的defaultProps将它们添加到我们的组件中:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d75e" class="ln kc hu lj b fv lo lp l lq lr">//src/components/sidebar.js</span><span id="0071" class="ln kc hu lj b fv ls lp l lq lr">const Sidebar = graphql(getAllPostsQuery, { name: "allPosts", })(<br/>   props =&gt; (<br/>      &lt;SidebarStyled&gt;<br/>         &lt;Nav&gt;<br/>            &lt;SidebarText&gt;<br/>               Posts<br/>            &lt;/SidebarText&gt;</span><span id="101e" class="ln kc hu lj b fv ls lp l lq lr">            {<br/>            props.allPosts.loading<br/>               ? &lt;Loading /&gt;<br/>               : props.allPosts.objects.map(({ slug, ...rest }) =&gt; (<br/>                  &lt;PostLink key = { slug } slug = { slug } { ...rest } /&gt;<br/>               ))<br/>            }</span><span id="dcb9" class="ln kc hu lj b fv ls lp l lq lr">         &lt;/Nav&gt;<br/>      &lt;/SidebarStyled&gt;<br/>   )<br/>);</span><span id="4a5e" class="ln kc hu lj b fv ls lp l lq lr">SideBar.defaultProps = {<br/>    bucketSlug: config.bucket.slug,<br/>    readKey: config.bucket["read_key"],<br/>};</span></pre><h2 id="9b19" class="ln kc hu bd kd mi mj mk kh ml mm mn kl jn mo mp kp jr mq mr kt jv ms mt kx mu dt translated">动态道具</h2><p id="8ca6" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">对于因组件的不同实例而变化的变量，如$postSlug，您可以将它们作为道具传递给组件的每个实例:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="cf8d" class="ln kc hu lj b fv lo lp l lq lr">//src/components/post.js<br/>const PostWrapper = GraphQL(getPostQuery)(props =&gt; (<br/>    &lt;PostContainerStyled&gt;<br/>        {<br/>         props.data.loading<br/>            ? &lt;Loading /&gt;<br/>            : &lt;Post<br/>               noShare = { props.noShare }<br/>               title = { R.path(["data", "object", "title",])(props) }<br/>               content = { R.path(["data", "object", "content",])(props) }<br/>               /&gt;<br/>      }<br/>    &lt;/PostContainerStyled&gt;<br/>));</span><span id="d16d" class="ln kc hu lj b fv ls lp l lq lr">PostWrapper.defaultProps = {<br/>    bucketSlug: config.bucket.slug,<br/>    readKey: config.bucket["read_key"],<br/>};</span><span id="456b" class="ln kc hu lj b fv ls lp l lq lr">export const Home = () =&gt; &lt;PostWrapper noShare postSlug = "home" /&gt;;</span></pre><h1 id="88a0" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">预加载数据</h1><p id="9de9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在用户需要之前预取我们的数据总是好的，这加快了页面转换的时间，并有助于更好的UX，Apollo提供了一个非常简单的方法来做到这一点。</p><p id="cace" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当侧边栏获得显示每篇文章预览所需的查询时，它还执行另一个查询:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9fe2" class="ln kc hu lj b fv lo lp l lq lr">#getAllPostsWithExtraQuery<br/>query($bucketSlug: String! $readKey: String!){<br/>    objectsWithExtra: objectsByType(bucket_slug: $bucketSlug, read_key: $readKey, type_slug: "posts") {<br/>        ...PostAllContent<br/>    }<br/>}</span></pre><p id="440e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该查询获取每篇文章的所有字段，这意味着在我们导航到文章页面之前，所有数据都已经加载到缓存中。您可以使用react-apollo包中的compose函数将多个查询附加到一个组件上。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="eeb0" class="ln kc hu lj b fv lo lp l lq lr">//src/components/sidebar.js</span><span id="b544" class="ln kc hu lj b fv ls lp l lq lr">const Sidebar = compose(<br/>    GraphQL(getAllPostsQuery, { name: "allPosts", }),<br/>    GraphQL(getAllPostsWithExtraQuery, { name: "allPostsPreFetch", }),<br/>)(props =&gt; (<br/>    &lt;SidebarStyled&gt;<br/>        &lt;Nav&gt;<br/>            &lt;SidebarText&gt;<br/>                Posts<br/>            &lt;/SidebarText&gt;</span><span id="4b26" class="ln kc hu lj b fv ls lp l lq lr">            &lt;Line /&gt;</span><span id="b6cb" class="ln kc hu lj b fv ls lp l lq lr">            {props.allPosts.loading<br/>                ? &lt;Loading /&gt;<br/>                : props.allPosts.objects.map(({ slug, ...rest }) =&gt; (<br/>                    &lt;PostLink key = { slug } slug = { slug } { ...rest } /&gt;<br/>                    ))}</span><span id="61b3" class="ln kc hu lj b fv ls lp l lq lr">        &lt;/Nav&gt;<br/>    &lt;/SidebarStyled&gt;<br/>));</span><span id="7dc2" class="ln kc hu lj b fv ls lp l lq lr">SideBar.defaultProps = {<br/>    bucketSlug: config.bucket.slug,<br/>    readKey: config.bucket["read_key"],<br/>};</span></pre><p id="203c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，如果你只是这样做，你将看不到网络性能的改善，而且每次你加载一个新的帖子，你都必须发出一个新的网络请求。为了从这种预加载中受益，我们必须告诉ApolloClient更多的事情。</p><h1 id="9a9a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">教阿波罗你的数据的形状</h1><p id="64ae" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">默认情况下，ApolloClient假设API返回的每个对象都可以通过一个名为id或_id的字段来标识。在Cosmic JS中，每个物体都可以通过一个名为slug的字段来识别。</p><p id="0f39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">告诉阿波罗这件事很简单:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3a1c" class="ln kc hu lj b fv lo lp l lq lr">import { ApolloClient, createNetworkInterface, } from "react-apollo";<br/>import { toIdValue, } from "Apollo-client";</span><span id="5885" class="ln kc hu lj b fv ls lp l lq lr">// ------------------------------</span><span id="c87c" class="ln kc hu lj b fv ls lp l lq lr">const networkInterface = createNetworkInterface({<br/>    uri: "https://GraphQL.cosmicjs.com/v1",<br/>});</span><span id="d7e7" class="ln kc hu lj b fv ls lp l lq lr">const dataIdFromObject = ({ __typename, slug, }) =&gt; __typename + slug;</span><span id="9bed" class="ln kc hu lj b fv ls lp l lq lr">const customResolvers = {<br/>    Query: {<br/>        object: (_, args) =&gt;<br/>            toIdValue(<br/>                dataIdFromObject({ __typename: "Object", slug: args.slug, }),<br/>            ),<br/>    },<br/>};</span><span id="e3b3" class="ln kc hu lj b fv ls lp l lq lr">const client = new ApolloClient({<br/>    networkInterface,<br/>    dataIdFromObject,<br/>    customResolvers,<br/>});</span><span id="c607" class="ln kc hu lj b fv ls lp l lq lr">//------------------------------</span><span id="9406" class="ln kc hu lj b fv ls lp l lq lr">export default client</span></pre><p id="21f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">dataIdFromObject函数告诉ApolloClient如何从它获得的任何对象生成唯一的ID。</p><p id="59a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对象customResolvers告诉ApolloClient，每当我们进行对象查询时，我们可以尝试使用查询变量slug在缓存中查找。</p><p id="c649" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们的侧边栏使用getAllPostsWithExtraQuery预加载所有的帖子，将来任何获取帖子数据的调用都将由ApolloClient的缓存提供服务，而不是通过网络。</p><h1 id="e5a8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">用webpack加载GraphQL查询</h1><p id="2c72" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">最后，Apollo为我们提供了另一种漂亮的技术来改善开发人员的体验。</p><p id="b821" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您使用webpack作为构建系统的一部分，您可以将所有GraphQL查询和变体保存在单独的文件中，并像其他文件一样将它们导入javascript。这仅仅意味着可以从分区代码和语法突出显示中受益，这也意味着webpack可以在构建时将GraphQL查询预编译成Apollo自己的内部表示，而不是在用户的浏览器中。</p><p id="ba07" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将GraphQL加载器集成到webpack中很容易，您只需在webpack配置中包含以下代码:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3c4e" class="ln kc hu lj b fv lo lp l lq lr">module: {<br/>   rules: [<br/>      {<br/>         test: /\.(GraphQL|gql)$/,<br/>         exclude: /node_modules/,<br/>         loader: 'GraphQL-tag/loader',<br/>      },<br/>   ],<br/>},</span></pre><h1 id="8ad1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="3bef" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在你知道了一些我们从在生产应用中使用React和GraphQL中学到的技巧、诀窍和技术。如果你学到了什么，请分享这篇文章！</p><p id="7341" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你在用Cosmic JS <a class="ae ka" href="https://cosmicjs.com/community" rel="noopener ugc nofollow" target="_blank">制作一个静态网站，或者别的什么，联系我们的Slack </a>或者<a class="ae ka" href="https://twitter.com/cosmic_js" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，我们很想看看你在做什么。</p><p id="116b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇文章由<a class="ae ka" href="https://codogo.io/" rel="noopener ugc nofollow" target="_blank"> Codogo </a>撰写，这是一家屡获殊荣的数字机构，致力于创造令人惊叹的数字体验。</p><div class="le lf lg lh fq ab cb"><figure class="mv iv mw mx my mz na paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="mv iv mw mx my mz na paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="mv iv mw mx my mz na paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="nb nc nd"><p id="f922" class="jc jd ne je b jf jg jh ji jj jk jl jm nf jo jp jq ng js jt ju nh jw jx jy jz hn dt translated"><a class="ae ka" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae ka" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae ka" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae ka" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jc jd ne je b jf jg jh ji jj jk jl jm nf jo jp jq ng js jt ju nh jw jx jy jz hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae ka" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae ka" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="le lf lg lh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>