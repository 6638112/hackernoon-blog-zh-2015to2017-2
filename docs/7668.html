<html>
<head>
<title>Honor the byte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尊重字节</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/honor-the-byte-dbd314b3d506?source=collection_archive---------14-----------------------#2017-11-03">https://medium.com/hackernoon/honor-the-byte-dbd314b3d506?source=collection_archive---------14-----------------------#2017-11-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/bb52a07b343e046e319a37eee8454fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUBrdwkxy2IYC8vaLg2rvg.png"/></div></div></figure><div class=""/><div class=""><h2 id="6f47" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">或者:无害，编写可维护的代码</h2></div><p id="4d1a" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><em class="kq">我目前有一项光荣的任务，就是将一个遗留的react/jquery/material ecss代码库移植到react/material-ui。</em></p><p id="4dee" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><em class="kq">很痛，而且很痛。当我几周前开始做这件事时，我并没有真正意识到我正在做什么——现在我比以前更清楚了，但我仍然觉得完成这件事需要一段时间。<br/>几天前，下班后，一位同事问我为什么要创建一个</em> <code class="eh kr ks kt ku b"><em class="kq">Button</em></code> <em class="kq">组件，这是这个故事的灵感来源。</em></p><h2 id="8389" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">模块化</h2><p id="5892" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">在大学里，针对代码质量的讲座都提倡尽可能实践模块化。我可以看到这种方法的好处，但是我从来没有完全意识到如果你开始为忽略这种基本的编码实践寻找借口会发生什么。编写小型的自包含组件/函数比编写整体的“全部完成”有很大的优势，我想在下面的文章中强调这一点。</p><p id="4b11" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">我正在开发的应用程序到处都有代码重复巨大的React组件，它们在字符串模板中只有几个字的不同。100多行函数，只有一个数组选择器不同。最终我会夸大其词，但你会明白的:</p><blockquote class="lv lw lx"><p id="f601" class="ju jv kq jw b jx jy jg jz ka kb jj kc ly ke kf kg lz ki kj kk ma km kn ko kp hn dt translated">我应该帮忙解决这个问题还是逃跑？</p></blockquote><p id="58d5" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">显然我不能责怪之前的开发者— <strong class="jw ig">我过去也做过类似的事情</strong>。<strong class="jw ig"> </strong>项目发展迅速，变得比我们一开始想的还要复杂，仓促的设计决策有时会让我们焦头烂额。我们突然不得不抓住潜在投资者的最后期限，或者不得不随着需求的急剧变化而改变。在巨大的压力下，我们倾向于背叛自己的理想，并开始做(不仅仅是)像代码复制这样的事情，因为我们说服自己这样更快，我们可以在以后重构——即使我们知道得更好。</p><p id="9435" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">这是一个遗留的meteor应用程序，所以1.3之前的测试甚至从一开始就是一团糟。突然之间，节点环境变得非常快——变得更好——但是像这样的大型项目很难赶上作用域模块/es6/lodash/app-state/un maintained-packages和其他日常工作。</p><p id="f4ff" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">我们都知道历史上的成长项目，<em class="kq">它们几乎必须是混乱的。</em>另一方面，我们可以将它视为一种挑战——遗留代码通常包含一些有趣的解决方案，用于那些没有人首先注意到的特殊情况。</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="266c" class="mi kw if bd kx mj mk ml lb mm mn mo lf jl mp jm li jo mq jp ll jr mr js lo ms dt translated">为什么代码复制不好</h1><p id="a132" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">我不知道有谁会认为代码复制通常是件好事。尽管如此，我认为研究我们不一定意识到的代码复制的含义是很有趣的。</p><h2 id="0367" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">易测性</h2><p id="d2c1" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">由于没有中心定义，测试基本上变得不可能。当查看测试金字塔时，你基本上必须跳过所有的底层，直接开始集成测试。使用快照这样简单的UI测试工具是不可想象的。</p><h2 id="09cc" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">易用性</h2><p id="337f" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">在大多数情况下，你不会有一个简单的按钮，它总是有完全相同的类和属性。例如，在我们的代码库中，一些按钮在内联使用时包含一些额外的类，一些按钮包含用于遗留的jquery选择器的额外的类。</p><p id="26cd" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">css类的问题是，你必须记住它们——尤其是当你不遵循任何像BEM或SMACSS这样的准则时。这不是一个简单的任务，你不需要记住它们，而是在代码中寻找其他地方使用的类。这显然会减慢开发过程，而且对开发人员来说也不是一个好的体验。对于特定的元素，存在哪些类是不透明的。</p><p id="5af1" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">当使用组件时，您可以简单地定义可能的属性并将属性名映射到类。没那么难。</p><h2 id="da8c" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">易于改变</h2><p id="2279" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">当你可以一直进行简单的修改而不破坏东西时，代码是可维护的。让我们假设我想改变按钮的一些东西…例如，处理一些onClick ripple问题，或者“切换底层css框架”——你现在必须<strong class="jw ig">找到</strong>并改变所有实现某种按钮的地方——你很可能会错过至少一个。有了适当的组件结构，它将是一个简单的程序。</p><h2 id="6790" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">改变的勇气</h2><p id="4e72" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">问题是，特别是对于大的、重复的功能和组件，不仅是它们是<strong class="jw ig"> <em class="kq">大的</em> </strong>和<strong class="jw ig"> <em class="kq">重复的</em> </strong> <em class="kq">。最大的问题是，没有人有勇气去改变事情。不是因为他们不想，而是因为他们害怕打破某些东西，而没有注意到——每个人总是只触摸他/她真正需要触摸的代码。所以mess变得更乱，上面提到的点变得越来越差。一旦进入，就很难逃脱这个螺旋，因为你必须说服你的老板停下火车，让你做不一定影响产品可见价值的工作。清理工作没有直接的投资回报，所以你必须争取时间和资源。</em></p><h2 id="bcc4" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">代码大小</h2><p id="c19c" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">特别是在web开发中，代码大小是一个主要关注点。实际上，包的大小是200还是400kb很重要。所以有几次</p><pre class="mt mu mv mw fq mx ku my mz aw na dt"><span id="ac7b" class="kv kw if ku b fv nb nc l nd ne">React.createElement(Button, { onClick: handleClick })</span></pre><p id="e6bd" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">相对</p><pre class="mt mu mv mw fq mx ku my mz aw na dt"><span id="e958" class="kv kw if ku b fv nb nc l nd ne">React.createElement('button', { className: 'a lot of different classes', onClick: handleClick })</span></pre><p id="121b" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">实际上会对代码大小产生影响。当然，这是一个不考虑缩小和gzipping的超级简单的例子，但是随着组件和功能越来越复杂，优势就越来越明显。</p><p id="def4" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated"><strong class="jw ig"> Gzip: </strong>现在的大部分web服务器都支持Gzip，基本上是去掉重复的字符串(<a class="ae nf" href="http://www.infinitepartitions.com/art001.html" rel="noopener ugc nofollow" target="_blank">深度解释</a>)。这不会使论点无效，但在很多情况下会减少问题。</p><p id="fb22" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">Prepack:Facebook开发了一个非常酷的工具叫做Prepack，它也可以帮助优化功能。尽管如此，你不应该使用代码优化器作为编写糟糕代码的借口，而是应该使用它们来优化良好的代码。</p><h2 id="e636" class="kv kw if bd kx ky kz la lb lc ld le lf kd lg lh li kh lj lk ll kl lm ln lo lp dt translated">编译/传输时间</h2><p id="70ee" class="pw-post-body-paragraph ju jv if jw b jx lq jg jz ka lr jj kc kd ls kf kg kh lt kj kk kl lu kn ko kp hn dt translated">Javascipt是解释的，所以我不需要编译对吗？不。实际上你需要为不同的目标编译/传输它。不仅如此，对于面向web的应用程序来说尤其如此。你通常不能只写现代代码，然后在浏览器中运行它。你最有可能使用某种编译系统，它将一些语言特性翻译到一个较低的级别，使其可以被所有/旧的浏览器执行。拥有非模块化的重复代码很可能会增加构建时间并降低DX。</p><h1 id="1f74" class="mi kw if bd kx mj ng ml lb mm nh mo lf jl ni jm li jo nj jp ll jr nk js lo ms dt translated">结论</h1><blockquote class="lv lw lx"><p id="1089" class="ju jv kq jw b jx jy jg jz ka kb jj kc ly ke kf kg lz ki kj kk ma km kn ko kp hn dt translated">第一次做一件事，你就去做。当你第二次做类似的事情时，你会因为重复而退缩，但是你还是做了重复的事情。第三次你做类似的事情，你重构。</p><p id="0d9b" class="ju jv kq jw b jx jy jg jz ka kb jj kc ly ke kf kg lz ki kj kk ma km kn ko kp hn dt translated"><a class="ae nf" href="https://www.amazon.com/dp/0201485672/" rel="noopener ugc nofollow" target="_blank"> <em class="if">马丁·福勒等人</em> </a></p></blockquote><p id="6411" class="pw-post-body-paragraph ju jv if jw b jx jy jg jz ka kb jj kc kd ke kf kg kh ki kj kk kl km kn ko kp hn dt translated">不要等到上述声明无效。一旦发现缺陷，就重构你的代码。没有什么比保持代码整洁、可维护和可测试更重要的了。每次你推迟重构，你都在积极地创造工作，降低产品质量和开发者体验。</p><blockquote class="lv lw lx"><p id="3f2f" class="ju jv kq jw b jx jy jg jz ka kb jj kc ly ke kf kg lz ki kj kk ma km kn ko kp hn dt translated">当程序员失去了对清洁的恐惧，他们就去清洁！而且干净的代码更容易理解，更容易修改，更容易扩展。因为代码变得更简单，缺陷变得更不可能。代码库稳步改进，而不是我们的行业已经习惯的正常腐烂。</p><p id="3854" class="ju jv kq jw b jx jy jg jz ka kb jj kc ly ke kf kg lz ki kj kk ma km kn ko kp hn dt translated">哪个职业程序员会允许这种腐烂继续下去？</p><p id="ca50" class="ju jv kq jw b jx jy jg jz ka kb jj kc ly ke kf kg lz ki kj kk ma km kn ko kp hn dt translated"><a class="ae nf" href="https://www.amazon.de/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073" rel="noopener ugc nofollow" target="_blank"> <em class="if">《干净的编码者》，罗伯特·马丁</em> </a></p></blockquote></div></div>    
</body>
</html>