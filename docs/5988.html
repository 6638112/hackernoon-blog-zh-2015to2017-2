<html>
<head>
<title>How Iterables actually work in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中Iterables的实际工作方式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-iterables-actually-work-in-python-65c36ff91c1e?source=collection_archive---------6-----------------------#2017-08-28">https://medium.com/hackernoon/how-iterables-actually-work-in-python-65c36ff91c1e?source=collection_archive---------6-----------------------#2017-08-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ffbd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Python语言最令人印象深刻的特性之一是“for-each”循环结构的使用，自从我开始使用Python以来，这种循环结构一直令我敬畏。对于外行来说，这里有一个简单的<em class="jp"> for </em>循环，它打印前10个自然数:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="2ccb" class="jz ka hu jv b fv kb kc l kd ke">for num in range(1, 11):<br/>    print(num)</span></pre><p id="fa7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以以类似的方式循环遍历原始类型，如<em class="jp">列表、元组、字典</em>和<em class="jp">字符串</em>:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="6360" class="jz ka hu jv b fv kb kc l kd ke">numbers = [1, 2, 3, 4, 5]<br/>record = ('Kshitij', 21, 'Loves Python')<br/>details = {<br/>        'name': 'Kshitij',<br/>        'age': 21<br/>       }</span><span id="adc9" class="jz ka hu jv b fv kf kc l kd ke">for num in numbers:<br/>    print(num) # 1 2 3 4 5</span><span id="1d7a" class="jz ka hu jv b fv kf kc l kd ke">for data in record:<br/>    print(data) # Kshitij 21 Loves Python</span><span id="5d03" class="jz ka hu jv b fv kf kc l kd ke">for key, value in details.items():<br/>    print(key, value) # age 21 name Kshitij</span></pre><p id="632c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当一个人使用<code class="eh kg kh ki jv b">class</code>在Python中实现很少的数据结构时，他感觉到了对存储在其实例中的数据进行循环的欲望。这就是迭代器协议发挥作用的地方。</p><h2 id="0959" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">示例实现</h2><p id="71c9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">让我们假设我们的任务是实现一个<a class="ae lh" href="https://en.wikipedia.org/wiki/Standard_52-card_deck" rel="noopener ugc nofollow" target="_blank">标准的52副牌</a>。一个示例实现可能如下所示:</p><figure class="jq jr js jt fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="6c69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这对于创建新的<code class="eh kg kh ki jv b">Deck</code>实例并表示它很有效。然而，这个实现中的一个主要难点是缺乏迭代<code class="eh kg kh ki jv b">Deck</code>对象的能力。</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="0fd1" class="jz ka hu jv b fv kb kc l kd ke">&gt;&gt;&gt; from cards import Deck<br/>&gt;&gt;&gt; new_deck = Deck() # New deck instantiated<br/>&gt;&gt;&gt; print(new_deck)<br/>... # Works great<br/>&gt;&gt;&gt; for card in new_deck:<br/>...     print(card)</span><span id="ffbc" class="jz ka hu jv b fv kf kc l kd ke">TypeError: 'Deck' object is not iterable</span></pre><p id="5216" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">聪明的人可以探究实例<code class="eh kg kh ki jv b">new_deck</code>，并得出结论<code class="eh kg kh ki jv b">cards</code>属性保存了迭代所需的数据，事实上它是一个<code class="eh kg kh ki jv b">list</code>。有了这些知识，他可以如下破解上面的循环:</p><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="c356" class="jz ka hu jv b fv kb kc l kd ke">&gt;&gt;&gt; for card in new_deck.cards:<br/>...     print(card)<br/>Card(...)<br/>..<br/>..</span></pre><p id="54e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这段代码非常好用。然而，最终用户必须获得关于执行迭代的实现的内部信息。这使得我们的代码失去了数据抽象的优势，并导致实现的许多期望。</p><blockquote class="ll lm ln"><p id="48a6" class="ir is jp it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">一定有更好的办法！</p></blockquote><p id="ba48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Raymond Hettinger的热情推动下，我寻找方法来改进我的实现，以便与Python的<code class="eh kg kh ki jv b">for</code>循环相结合。</p><p id="70a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很快我就找到了答案——<strong class="it hv">迭代器协议。</strong></p><h1 id="091d" class="lr ka hu bd kj ls lt lu kn lv lw lx kr ly lz ma ku mb mc md kx me mf mg la mh dt translated">迭代器协议</h1><p id="3ec9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">为了学习什么是协议以及如何用Python实现它，我们需要理解一些基本术语。</p><h2 id="d0e4" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">可迭代的</h2><ul class=""><li id="db70" class="mi mj hu it b iu lc iy ld jc mk jg ml jk mm jo mn mo mp mq dt translated">它是任何你可以用for循环循环的对象。</li><li id="f7f1" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">可重复项不总是可索引的，不总是有长度的，也不总是有限的。</li><li id="241d" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">可以将一个iterable传递给<code class="eh kg kh ki jv b">iter()</code>内置函数，为它们获取一个迭代器。</li></ul><h2 id="c782" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">迭代程序</h2><ul class=""><li id="e9c5" class="mi mj hu it b iu lc iy ld jc mk jg ml jk mm jo mn mo mp mq dt translated">迭代器只有一个任务:返回iterable中的“下一个”项。</li><li id="7c8a" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated"><a class="ae lh" href="https://docs.python.org/3/glossary.html#term-iterator" rel="noopener ugc nofollow" target="_blank">迭代器</a>可以传递给内置的<code class="eh kg kh ki jv b">next</code>函数，从中获取下一项，如果没有下一项(因为我们到达了末尾)，将引发一个<code class="eh kg kh ki jv b">StopIteration</code>异常。</li><li id="26ce" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mn mo mp mq dt translated">迭代器在传递给内置的<code class="eh kg kh ki jv b">iter()</code>时返回自身。</li></ul><h1 id="e0da" class="lr ka hu bd kj ls lt lu kn lv lw lx kr ly lz ma ku mb mc md kx me mf mg la mh dt translated">协议</h1><h2 id="aa30" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">步骤01:<code class="eh kg kh ki jv b">iter()</code>内置如何工作？</h2><p id="23f6" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">每当解释器需要迭代一个对象<code class="eh kg kh ki jv b">x</code>，它会自动调用<code class="eh kg kh ki jv b">iter(x)</code>。<code class="eh kg kh ki jv b">iter</code>内置功能:</p><ol class=""><li id="bcd0" class="mi mj hu it b iu iv iy iz jc mw jg mx jk my jo mz mo mp mq dt translated">检查对象是否实现了，<code class="eh kg kh ki jv b">__iter__</code>方法，并调用它来获得一个<em class="jp">迭代器。</em></li><li id="876b" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">如果没有实现<code class="eh kg kh ki jv b">__iter__</code>方法，但是实现了<code class="eh kg kh ki jv b">__getitem__</code>方法，Python会创建一个<em class="jp">迭代器</em>，尝试从索引<code class="eh kg kh ki jv b">0</code>开始按顺序获取项目。</li><li id="f79f" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">如果失败，Python会抛出<code class="eh kg kh ki jv b">TypeError</code>异常，说<code class="eh kg kh ki jv b">&lt;classname&gt; object is not iterable</code>。</li></ol><h2 id="c6b7" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">步骤02:如何实现协议？</h2><p id="96f3" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我将介绍实现迭代器协议的两种方法:</p><h2 id="3b52" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">方法1:传统方式</h2><ol class=""><li id="1bb4" class="mi mj hu it b iu lc iy ld jc mk jg ml jk mm jo mz mo mp mq dt translated">创建一个表示<em class="jp">迭代器</em>(比如<strong class="it hv"> DeckIterator </strong> ) <em class="jp">的新类。</em></li><li id="276d" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">在<strong class="it hv"> DeckIterator中实现以下两种方法:</strong></li></ol><p id="4214" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jv b">__next__</code>:返回iterable中的下一项。</p><p id="867d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kg kh ki jv b">__iter__</code>:返回自身，即<code class="eh kg kh ki jv b">self</code>。</p><p id="6c33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.在您想要迭代其实例的类中定义一个<code class="eh kg kh ki jv b">__iter__</code>方法，即类<strong class="it hv"> Deck。</strong>该方法应该返回<strong class="it hv"> DeckIterator </strong>的一个实例。</p><figure class="jq jr js jt fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="3894" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">方法2:务实的方式</h2><ol class=""><li id="a061" class="mi mj hu it b iu lc iy ld jc mk jg ml jk mm jo mz mo mp mq dt translated">将<strong class="it hv"> Deck </strong>类中的<code class="eh kg kh ki jv b">__iter__</code>方法实现为<em class="jp">生成器函数</em>。</li></ol><figure class="jq jr js jt fq li"><div class="bz el l di"><div class="lj lk l"/></div></figure><h2 id="801c" class="jz ka hu bd kj kk kl km kn ko kp kq kr jc ks kt ku jg kv kw kx jk ky kz la lb dt translated">特征</h2><p id="1142" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">这是所有特性的列表，只要我们实现了协议，我们的对象就会神奇地支持这些特性。</p><ol class=""><li id="ee85" class="mi mj hu it b iu iv iy iz jc mw jg mx jk my jo mz mo mp mq dt translated">通过for循环进行迭代</li><li id="63c9" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">类似于元组的解包</li><li id="5ed5" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">可用于列表理解</li><li id="56ce" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">可用于消耗iterable的内置函数(如<code class="eh kg kh ki jv b">min</code>、<code class="eh kg kh ki jv b">max</code>)。</li></ol><pre class="jq jr js jt fq ju jv jw jx aw jy dt"><span id="c6ef" class="jz ka hu jv b fv kb kc l kd ke">&gt;&gt;&gt; new_deck = Deck()</span><span id="c311" class="jz ka hu jv b fv kf kc l kd ke">&gt;&gt;&gt; # 1. Looping through a for loop<br/>&gt;&gt;&gt; for card in new_deck:<br/>...     print(card) # Works great!</span><span id="ab7e" class="jz ka hu jv b fv kf kc l kd ke">&gt;&gt;&gt; # 2. Unpacking similarly to tuples<br/>&gt;&gt;&gt; first_card, *rest, last_card = new_deck</span><span id="2949" class="jz ka hu jv b fv kf kc l kd ke">&gt;&gt;&gt; # 3. List Comprehensions<br/>&gt;&gt;&gt; spades = [card for card in new_deck if card.suit == 'Spades']</span><span id="6ca6" class="jz ka hu jv b fv kf kc l kd ke">&gt;&gt;&gt; # 4. Built-in functions<br/>&gt;&gt;&gt; max_card, min_card = max(new_deck), min(new_deck)</span></pre><h1 id="7f28" class="lr ka hu bd kj ls lt lu kn lv lw lx kr ly lz ma ku mb mc md kx me mf mg la mh dt translated">吸取的教训:</h1><ol class=""><li id="d927" class="mi mj hu it b iu lc iy ld jc mk jg ml jk mm jo mz mo mp mq dt translated">Python中的迭代器不是类型的问题，而是协议的问题，也就是说，任何实现这个协议的类都可以被迭代。</li><li id="ca4c" class="mi mj hu it b iu mr iy ms jc mt jg mu jk mv jo mz mo mp mq dt translated">Python <em class="jp"> groks </em>迭代。</li></ol><p id="4fb8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望迭代器协议的知识能在你写Python的时候帮到你。为了提高对Python这一看似不被重视的特性的认识，我提议在PyCon India 2017 上做一个关于这个主题的<a class="ae lh" href="https://in.pycon.org/cfp/2017/proposals/iterators-generators-and-you~e9OYb/" rel="noopener ugc nofollow" target="_blank">演讲。</a></p></div></div>    
</body>
</html>