<html>
<head>
<title>Function decorators: Transforming callbacks into promises and back again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数装饰者:将回调转化为承诺，然后再转化回来</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/transforming-callbacks-into-promises-and-back-again-e274c7cf7293?source=collection_archive---------3-----------------------#2017-05-15">https://medium.com/hackernoon/transforming-callbacks-into-promises-and-back-again-e274c7cf7293?source=collection_archive---------3-----------------------#2017-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1490fe1d6a7c5392ec6f04d6df219414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8n3HWlG0xaVOuF07FMZlQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://pixabay.com/en/think-switch-arrows-rethinking-2177840/" rel="noopener ugc nofollow" target="_blank">geralt @ pixelbay</a></figcaption></figure><p id="838f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在JavaScript领域工作的每一天，都会遇到回调、承诺或async/await。对于如何处理异步代码，我有自己的偏好，尽管有时我没有选择，因为像<a class="ae jg" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank"> fs </a>、<a class="ae jg" href="https://serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器</a>、<a class="ae jg" href="https://www.npmjs.com/package/aws-sdk" rel="noopener ugc nofollow" target="_blank"> aws-sdk </a>等外部库。正在使用其他东西。</p><p id="d310" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我不喜欢任何代码库中的不一致性。所以，如果我从承诺开始，我会从头到尾使用承诺。</p><p id="3ab6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这提出了一个小问题；我如何在一个有外部库的项目中保持一致性？正如本文的标题所示，我对它们进行了改造。</p><h1 id="bbbf" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">回访和承诺</h1><p id="e20e" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我遇到的最常见的场景是一个使用节点样式回调的旧库，我更喜欢使用promises或async/await等类似的东西。</p><p id="2505" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回顾一下，典型的节点样式回调可能如下所示:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="cc06" class="lr kg hu ln b fv ls lt l lu lv">fs.readFile('./kittens.txt', (err, data) =&gt; {<br/>  if (err) throw err;<br/>  console.log(data);<br/>});</span></pre><p id="025c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但这是我想使用的方法:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="0556" class="lr kg hu ln b fv ls lt l lu lv">fs.readFile('./kittens.txt')<br/>  .then(data =&gt; console.log(data))</span></pre><p id="9f18" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，我只是踢踢腿，使用来自<a class="ae jg" href="http://bluebirdjs.com" rel="noopener ugc nofollow" target="_blank"> bluebird.js </a>的<a class="ae jg" href="http://bluebirdjs.com/docs/api/promise.promisify.html" rel="noopener ugc nofollow" target="_blank"> promisify </a>。这是最简单、最快和最懒惰的方法。但是…</p><blockquote class="lx"><p id="8d54" class="ly lz hu bd ma mb mc md me mf mg ke ek translated">导入一个库来使用单个函数是懒惰的，应该被禁止。</p></blockquote><p id="4584" class="pw-post-body-paragraph jh ji hu jj b jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka ml kc kd ke hn dt translated">…尤其是当所讨论的函数很容易编写的时候。(谷歌<a class="ae jg" href="https://encrypted.google.com/#q=leftpad%20broke%20the%20internet" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> leftpad爆料互联网</em> </a>)</p><p id="83e5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在停下来，看看node_modules文件夹的大小。太猥琐了！node_modules文件夹超过1GB甚至2GB的情况并不少见！</p><p id="ffcd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这些事情加起来。</p><h1 id="aa56" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">许诺</h1><p id="25c9" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们想要的叫做<strong class="jj hv">函数装饰器</strong>。</p><blockquote class="mm mn mo"><p id="73ac" class="jh ji lw jj b jk jl jm jn jo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ke hn dt translated">一个<strong class="jj hv"> <em class="hu">函数装饰器</em> </strong>是一个高阶函数，它以一个函数为自变量，返回另一个函数，返回的函数是自变量函数的变体。<a class="ae jg" href="https://leanpub.com/javascriptallongesix/read#decorators" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="75ff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个<code class="eh ms mt mu ln b">promisify</code>函数装饰器看起来像什么的例子:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="413a" class="lr kg hu ln b fv ls lt l lu lv">const readFile = promisify(fs.readFile)</span><span id="9a0b" class="lr kg hu ln b fv mv lt l lu lv">readFile<!-- -->('./kittens.txt')<br/>  .then(data =&gt; console.log(data))</span></pre><p id="a0d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">功能<code class="eh ms mt mu ln b">readFile</code>，仍然与<code class="eh ms mt mu ln b">fs.readFile</code>紧密相关，已经被转换成原始功能的变体。这是一个<strong class="jj hv">函数装饰器</strong>。</p><p id="4d6c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个应该很容易做。首先，我们创建一个带有1个参数的函数，并返回一个函数。当返回的函数被调用时，它将返回一个承诺。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="a02a" class="lr kg hu ln b fv ls lt l lu lv">function promisify(func) {<br/>  return () =&gt;<br/>    new Promise((resolve, reject) =&gt; { })<br/>}</span></pre><p id="9979" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在上面使用了关键字<code class="eh ms mt mu ln b">function</code>，因为我们需要访问<code class="eh ms mt mu ln b">this</code>，这对于箭头函数是不可用的。</p><p id="3e42" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意(下面)一个额外的参数，<code class="eh ms mt mu ln b">callback</code>是如何附加到<code class="eh ms mt mu ln b">args</code>的末尾的。这是因为我们的修饰函数不接受回调作为参数，但是原始函数<code class="eh ms mt mu ln b">func</code>接受。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="9a10" class="lr kg hu ln b fv ls lt l lu lv">func.apply(this, [...args, callback])</span></pre><p id="d8f3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">综合起来，它看起来像这样:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="968f" class="lr kg hu ln b fv ls lt l lu lv">function promisify(func) {<br/>  return (<strong class="ln hv">...args</strong>) =&gt;<br/>    new Promise((resolve, reject) =&gt; {<br/>      <strong class="ln hv">const callback = ???</strong></span><span id="ffda" class="lr kg hu ln b fv mv lt l lu lv"><strong class="ln hv">      func.apply(this, [...args, callback]);</strong><br/>    })<br/>}</span></pre><p id="de25" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后一步也是最简单的，创建<code class="eh ms mt mu ln b">callback</code>。<code class="eh ms mt mu ln b">callback</code>只是一个节点样式的<code class="eh ms mt mu ln b">callback </code>，它将基于<code class="eh ms mt mu ln b">err</code>的存在调用<code class="eh ms mt mu ln b">resolve</code>或<code class="eh ms mt mu ln b">reject</code>。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><h1 id="c6c0" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">回调</h1><p id="79c4" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我遇到了一个不太常见的情况，我需要的是相反的情况。我必须创建的函数需要是一个节点样式的回调函数。Uggg，我的代码已经用承诺写好了。</p><p id="1a56" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有问题的代码是针对AWS lambdas的，AWS lambdas通常使用回调来编写，所以我的代码最终看起来像这样:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="80cc" class="lr kg hu ln b fv ls lt l lu lv">module.exports.handler <strong class="ln hv">=</strong> function(event, context, <strong class="ln hv">callback</strong>) {<br/>  myHandler(event)<br/>    .then(data =&gt; <strong class="ln hv">callback(null, data)</strong>)<br/>    .catch(err =&gt; <strong class="ln hv">callback(err)</strong>)<br/>}</span></pre><p id="b3f6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我的库都是基于承诺的，所以我更喜欢这样写:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="fff4" class="lr kg hu ln b fv ls lt l lu lv">module.exports.handler = (event, context) =&gt;<br/>  myService(event) // note: I don’t need context.</span></pre><p id="a93c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我最终创建了<code class="eh ms mt mu ln b">promisify</code>、<code class="eh ms mt mu ln b">callbackify</code>的反向，所以我可以像这样创建我的lambda:</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="8ffa" class="lr kg hu ln b fv ls lt l lu lv">module.exports.handler = callbackify((event, context) =&gt;<br/>  myService(event))</span></pre><p id="e89c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为我们几乎和上面做的一样，所以我们可以更快一点。让我们用一个返回函数的参数<code class="eh ms mt mu ln b">func</code>创建<code class="eh ms mt mu ln b">callbackify</code>。因为返回的函数将args + callback作为参数，所以我们必须将它们分开。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="5f50" class="lr kg hu ln b fv ls lt l lu lv">function callbackify(func) {<br/>  return function(...args) {<br/><strong class="ln hv">    const onlyArgs = args.slice(0, args.length - 1)<br/>    const callback = args[args.length - 1]</strong><br/>  }<br/>}</span></pre><p id="4140" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，我们需要在<code class="eh ms mt mu ln b">func</code>上调用<code class="eh ms mt mu ln b">apply</code>，并传入我们的<code class="eh ms mt mu ln b">onlyArgs</code>。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure><h1 id="ba5e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">async/await如何适应这一切？</h1><p id="3107" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">async和await的操作几乎与promises完全一样，所以可以互换使用。</p><pre class="li lj lk ll fq lm ln lo lp aw lq dt"><span id="06f7" class="lr kg hu ln b fv ls lt l lu lv">const readFile = promisify(fs.readFile)<br/>const file = await readFile('./kittens.txt)</span><span id="ff7d" class="lr kg hu ln b fv mv lt l lu lv">console.log(file)</span></pre><p id="4547" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">看看这个，你可以等待一个节点风格的<code class="eh ms mt mu ln b">callback</code>函数。整洁！</p><h1 id="5828" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">外卖</h1><p id="92c3" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">无论你使用回调、承诺还是异步/等待，保持一致是最重要的。</p><p id="5453" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在导入库之前，尝试创建自己的函数。</p><p id="51e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想调整库函数的工作方式，创建一个<strong class="jj hv">函数装饰器</strong>。</p><h1 id="f69b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">开源代码库</h1><p id="eed0" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我把这些函数放在github上，这样我就可以很容易地把它们导入到我的项目中，因为我几乎在每个项目中都用到它们。你也可以使用它们。</p><div class="my mz fm fo na nb"><a href="https://github.com/joelnet/functional-helpers" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">Joel net/功能助手</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">功能助手—功能助手</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ja nb"/></div></div></a></div><h1 id="b62b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">有关系的</h1><p id="03a1" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated"><a class="ae jg" href="https://github.com/nodejs/node/compare/f72376d3230be7c968e392d59680bd01f8c20360...faf6654ff75e0f275afddfd980387235c3ddf103" rel="noopener ugc nofollow" target="_blank"> util.promisify正在被添加到节点</a></p><p id="2aba" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="http://bluebirdjs.com/docs/api/promise.promisify.html" rel="noopener ugc nofollow" target="_blank">蓝鸟的承诺</a></p><h1 id="26bc" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结束</h1><p id="62ab" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果您对此感兴趣，或者对函数式编程感兴趣，您可能会喜欢我的其他一些文章。</p><div class="my mz fm fo na nb"><a href="https://medium.com/@joelthoms/latest" rel="noopener follow" target="_blank"><div class="nc ab ej"><div class="nd ab ne cl cj nf"><h2 class="bd hv fv z el ng eo ep nh er et ht dt translated">乔尔·托马斯写的最新故事——中等</h2><div class="ni l"><h3 class="bd b fv z el ng eo ep nh er et ek translated">阅读乔尔·托马斯在Medium上写的最新故事。计算机科学家和技术布道者，拥有21年的…</h3></div><div class="nj l"><p class="bd b gc z el ng eo ep nh er et ek translated">medium.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np ja nb"/></div></div></a></div><p id="05e1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我知道这是一件小事，但当我在媒体和Twitter ( <a class="ae jg" href="https://twitter.com/joelnet" rel="noopener ugc nofollow" target="_blank"> @joelnet </a>)上收到这些后续通知时，我感到非常高兴。或者你觉得我满嘴屁话，在下面的评论里告诉我。</p><p id="56ae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">干杯！</p><div class="li lj lk ll fq ab cb"><figure class="nr iv ns nt nu nv nw paragraph-image"><a href="http://bit.ly/HackernoonFB"><img src="../Images/50ef4044ecd4e250b5d50f368b775d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0hqOaABQ7XGPT-OYNgiUBg.png"/></a></figure><figure class="nr iv ns nt nu nv nw paragraph-image"><a href="https://goo.gl/k7XYbx"><img src="../Images/979d9a46439d5aebbdcdca574e21dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Vgw1jkA6hgnvwzTsfMlnpg.png"/></a></figure><figure class="nr iv ns nt nu nv nw paragraph-image"><a href="https://goo.gl/4ofytp"><img src="../Images/2930ba6bd2c12218fdbbf7e02c8746ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*gKBpq1ruUi0FVK2UM_I4tQ.png"/></a></figure></div><blockquote class="mm mn mo"><p id="f922" class="jh ji lw jj b jk jl jm jn jo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ke hn dt translated"><a class="ae jg" href="http://bit.ly/Hackernoon" rel="noopener ugc nofollow" target="_blank">黑客中午</a>是黑客如何开始他们的下午。我们是<a class="ae jg" href="http://bit.ly/atAMIatAMI" rel="noopener ugc nofollow" target="_blank"> @AMI </a>家庭的一员。我们现在<a class="ae jg" href="http://bit.ly/hackernoonsubmission" rel="noopener ugc nofollow" target="_blank">接受投稿</a>并乐意<a class="ae jg" href="mailto:partners@amipublications.com" rel="noopener ugc nofollow" target="_blank">讨论广告&amp;赞助</a>机会。</p><p id="708a" class="jh ji lw jj b jk jl jm jn jo jp jq jr mp jt ju jv mq jx jy jz mr kb kc kd ke hn dt translated">如果你喜欢这个故事，我们推荐你阅读我们的<a class="ae jg" href="http://bit.ly/hackernoonlatestt" rel="noopener ugc nofollow" target="_blank">最新科技故事</a>和<a class="ae jg" href="https://hackernoon.com/trending" rel="noopener ugc nofollow" target="_blank">趋势科技故事</a>。直到下一次，不要把世界的现实想当然！</p></blockquote><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nx"><img src="../Images/be0ca55ba73a573dce11effb2ee80d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35tCjoPcvq6LbB3I6Wegqw.jpeg"/></div></div></figure></div></div>    
</body>
</html>